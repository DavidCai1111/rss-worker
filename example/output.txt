2015年五月7日晚上 7:14:38
大家对于富应用的前端，一个页面调用很多第三方平台的RESTful api的方式，有什么好建议吗？
<div class="markdown-text"><p>如果移到后端，逻辑会清晰点，但是后台服务器负荷会增加。
如果在前端，结果会直观，但是验证逻辑的代码量增加，而且service不通过后台就直接去第三方平台做get,put…的操作也觉得不是很安全。</p>
</div>

2015年五月7日晚上 6:01:50
JS.ORG：为 GitHub pages 上的 JavaScript project 提供免费的二级域名
<div class="markdown-text"><p>来自 <a href="http://js.org">JS.ORG</a> 的福利，为 JavaScript 项目或者个人 github pages 提供免费的二级域名，有需要的可以去申请个。</p>
<p>PS: CNodejs.org 或许也可以提供一个类似的功能。</p>
</div>

2015年五月7日下午 5:52:11
提一个小建议。
<div class="markdown-text"><p>刚才回答问题的时候发现一个小问题。js 代码块里面的汉字和字母宽度比不等于2，一般终端里面都是2倍的，导致下面的文字有些错位。
如果能改成2倍的话，就完美了。</p>
<pre class="prettyprint language-js"><code>PHP-&gt;Node.js─┬──读─┬──读经典的书
             │     └──读优质的代码
             ├──写─┬──边学边写点小代码
             │     └──写一些小玩意
             └──思─┬──刨根问底
                   ├──举一反三
                   └──用脑图
</code></pre></div>

2015年五月7日下午 5:47:27
求上谷歌方法
<div class="markdown-text"><p>本来不想买vpn
最近平常上的搜索都给封了
所以，便宜的vpn也认了
当然，还是免费的最好啦
对这种闭关锁国的寡妇网表示鄙视
各位大大，给点推荐吧</p>
</div>

2015年五月7日下午 4:58:47
tcp（net模块） 文件分包传输解决方案
<div class="markdown-text"><p>想知道各位有没有tcp 文件分包传输的解决方案。
附上找到的一个方案。<a href="http://yoyo.play175.com/p/nodejs-exbuffer.html">http://yoyo.play175.com/p/nodejs-exbuffer.html</a></p>
</div>

2015年五月7日下午 4:47:17
坛子之前有没有回复邮件提醒功能来着
<div class="markdown-text"><p>segmentfault里貌似不在线的用户回收到评论的邮件提醒。
隐约记得坛子好像有这功能，不知道是不是幻觉？
咋个判断要不要发邮件？</p>
</div>

2015年五月7日下午 4:35:57
lsyncd实时同步搭建指南——取代rsync+inotify
<h1>1. 几大实时同步工具比较</h1>

<h2>1.1 inotify + rsync</h2>

<p>最近一直在寻求生产服务服务器上的同步替代方案，原先使用的是<code>inotify +  rsync</code>，但随着文件数量的增大到100W+，目录下的文件列表就达20M，在网络状况不佳或者限速的情况下，变更的文件可能10来个才几M，却因此要发送的文件列表就达20M，严重减低的带宽的使用效率以及同步效率；更为要紧的是，加入inotifywait在5s内监控到10个小文件发生变化，便会触发10个rsync同步操作，结果就是真正需要传输的才2-3M的文件，比对的文件列表就达200M。使用这两个组合的好处在于，它们都是最基本的软件，可以通过不同选项做到很精确的控制，比如排除同步的目录，同步多个模块或同步到多个主机。</p>

<p>搭建过程参考 <a rel="nofollow" href="http://segmentfault.com/a/1190000002427568">Linux下同步工具inotify+rsync使用详解</a> 或<a rel="nofollow" href="http://seanlook.com/2014/12/12/rsync_inotify_setup/">这里</a>。</p>

<h2>1.2 sersync</h2>

<p>后来听同事说 <a rel="nofollow" href="http://www.ccvita.com/422.html">sersync</a> 这么个工具可以提高同步的性能，也解决了同步大文件时出现异常的问题，所以就尝试了一下。sersync是国内的一个开发者开源出来的，使用c++编写，采用多线程的方式进行同步，失败后还有重传机制，对临时文件过滤，自带crontab定时同步功能。网上看到有人说性能还不错，说一下我的观点：</p>

<ul>
<li>国产开源，文档不是很全，在2011年之后就没更新了（googlecode都要快关闭了，其实可以转交其他人维护），网上关于它的使用和讨论都止于10年了</li>
<li>采用xml配置文件的方式，可读性比较好，但是有些原生的有些功能没有实现就没法使用了</li>
<li>无法实现多目录同步，只能通过多个配置文件启动多个进程</li>
<li>文件排除功能太弱。这个要看需求，不是每个人都需要排除子目录。而对于我的环境中，这个功能很重要，而且排除的规则较多</li>
<li>虽然提供插件的功能，但很鸡肋，因为软件本身没有持续更新，也没有看到贡献有其它插件出现（可能是我知识面不够，还用不到里面的refreshCDN plugin）。</li>
</ul>
<p>虽然不懂c++，但大致看了下源码 <a rel="nofollow" href="http://code.google.com/p/sersync/source/browse/FileSynchronize.cpp">FileSynchronize</a>，拼接rsync命令大概在273行左右，最后一个函数就是排除选项，简单一点可以将<code>--exclude=</code>改成<code>--eclude-from</code>来灵活控制。有机会再改吧。</p>

<p>另外，在作者的文章 <a rel="nofollow" href="http://hi.baidu.com/johntech/item/a4a2060ecf3053c6905718e1">Sersync服务器同步程序 项目简介与设计框架</a> 评论中，说能解决上面 <code>rsync + inotify</code>中所描述的问题。阅读了下源码，这个应该是没有解决，因为在拼接rsync命令时，后面的目的地址始终是针对module的，只要执行rsync命令，就会对整个目录进行遍历，发送要比对的文件列表，然后再发送变化的文件。sersync只是减少了监听的事件，减少了rsync的次数——这已经是很大的改进，但每次rsync没办法改变。（如有其它看法可与我讨论）</p>

<p>其实我们也不能要求每一个软件功能都十分健全，关键是看能否满足我们当下的特定的需求。所谓好的架构不是设计出来的，而是进化来的。目前使用<code>sersync2</code>没什么问题，而且看了它的设计思路应该是比较科学的，特别是过滤队列的设计。双向同步看起来也是可以实现。</p>

<h2>1.3 lsyncd</h2>

<p>废话说这么多，本文就是介绍它了。有些博客说lsyncd是谷歌开源的，实际不是了，只是托管在了googlecode上而已，幸运的是已经迁移到github了：<a rel="nofollow" href="https://github.com/axkibe/lsyncd">https://github.com/axkibe/lsyncd</a> 。</p>



<p>Lysncd 实际上是lua语言封装了 inotify 和 rsync 工具，采用了 Linux 内核（2.6.13 及以后）里的 inotify 触发机制，然后通过rsync去差异同步，达到实时的效果。我认为它最令人称道的特性是，完美解决了 <code>inotify + rsync</code>海量文件同步带来的文件频繁发送文件列表的问题 —— 通过时间延迟或累计触发事件次数实现。另外，它的配置方式很简单，lua本身就是一种配置语言，可读性非常强。lsyncd也有多种工作模式可以选择，本地目录cp，本地目录rsync，远程目录rsyncssh。</p>

<p>实现简单高效的本地目录同步备份（网络存储挂载也当作本地目录），一个命令搞定。</p>

<h1>2. 使用 lsyncd 本地目录实时备份</h1>

<p>这一节实现的功能是，本地目录source实时同步到另一个目录target，而在source下有大量的文件，并且有部分目录和临时文件不需要同步。</p>

<h2>2.1 安装lsyncd</h2>

<p>安装<code>lsyncd</code>极为简单，已经收录在ubuntu的官方镜像源里，直接通过<code>apt-get install lsyncd</code>就可以。<br>
在Redhat系（我的环境是CentOS 6.2 x86_64 ），可以手动去下载 <a rel="nofollow" href="ftp://195.220.108.108/linux/fedora/linux/updates/21/x86_64/l/lsyncd-2.1.5-6.fc21.x86_64.rpm">lsyncd-2.1.5-6.fc21.x86_64.rpm</a>，但首先你得安装两个依赖<code>yum install lua lua-devel</code>。也可以通过在线安装，需要<code>epel-release</code>扩展包：</p>

<pre><code># rpm -ivh http://dl.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm
# yum install lsyncd
</code></pre>

<p><strong>源码编译安装</strong><br>
从源码编译安装可以使用最新版的lsyncd程序，但必须要相应的依赖库文件和编译工具：<code>yum install lua lua-devel asciidoc cmake</code>。</p>

<p>从 <a rel="nofollow" href="http://code.google.com/p/lsyncd/downloads/list">googlecode lsyncd</a> 上下载的<code>lsyncd-2.1.5.tar.gz</code>，直接<code>./configure</code>、<code>make &amp;&amp; make install</code>就可以了。</p>

<p>从github上下载<a rel="nofollow" href="https://github.com/axkibe/lsyncd/archive/master.zip">lsyncd-master.zip</a> 的2.1.5版本使用的是 cmake 编译工具，无法<code>./configure</code>：</p>

<pre><code># uzip lsyncd-master.zip
# cd lsyncd-master
# cmake -DCMAKE_INSTALL_PREFIX=/usr/local/lsyncd-2.1.5
# make &amp;&amp; make install
</code></pre>

<p>我这个版本编译时有个小bug，如果按照<code>INSTALL</code>在<code>build</code>目录中make，会提示：</p>

<pre><code>[100%] Generating doc/lsyncd.1
Updating the manpage
a2x: failed: source file not found: doc/lsyncd.1.txt
make[2]: *** [doc/lsyncd.1] Error 1
make[1]: *** [CMakeFiles/manpage.dir/all] Error 2
make: *** [all] Error 2
</code></pre>

<p>解决办法是要么直接在解压目录下cmake，不要<code>mkdir build</code>，要么在<code>CMakeList.txt</code>中搜索<code>doc</code>字符串，在前面加上<code>${PROJECT_SOURCE_DIR}</code>。</p>

<h2>2.2 lsyncd.conf</h2>

<p>下面都是在编译安装的情况下操作。</p>

<h3>2.2.1 lsyncd同步配置</h3>

<pre><code># cd /usr/local/lsyncd-2.1.5
# mkdir etc var
# vi etc/lsyncd.conf
settings {
    logfile      ="/usr/local/lsyncd-2.1.5/var/lsyncd.log",
    statusFile   ="/usr/local/lsyncd-2.1.5/var/lsyncd.status",
    inotifyMode  = "CloseWrite",
    maxProcesses = 7,
    -- nodaemon =true,
    }

sync {
    default.rsync,
    source    = "/tmp/src",
    target    = "/tmp/dest",
    -- excludeFrom = "/etc/rsyncd.d/rsync_exclude.lst",
    rsync     = {
        binary    = "/usr/bin/rsync",
        archive   = true,
        compress  = true,
        verbose   = true
        }
    }
</code></pre>

<p>到这启动 lsycnd 就可以完成实时同步了，默认的许多参数可以满足绝大部分需求，非常简单。</p>

<h3>2.2.2 lsyncd.conf配置选项说明</h3>

<p><strong>settings</strong><br>
里面是全局设置，<code>--</code>开头表示注释，下面是几个常用选项说明：</p>

<ul>
<li>
<code>logfile</code> 定义日志文件</li>
<li>
<code>stausFile</code> 定义状态文件</li>
<li>
<code>nodaemon=true</code> 表示不启用守护模式，默认</li>
<li>
<code>statusInterval</code> 将lsyncd的状态写入上面的statusFile的间隔，默认10秒</li>
<li>
<code>inotifyMode</code> 指定inotify监控的事件，默认是<code>CloseWrite</code>，还可以是<code>Modify</code>或<code>CloseWrite or Modify</code>
</li>
<li>
<code>maxProcesses</code> 同步进程的最大个数。假如同时有20个文件需要同步，而<code>maxProcesses = 8</code>，则最大能看到有8个rysnc进程</li>
<li>
<code>maxDelays</code> 累计到多少所监控的事件激活一次同步，即使后面的<code>delay</code>延迟时间还未到</li>
</ul>
<p><strong>sync</strong><br>
里面是定义同步参数，可以继续使用<code>maxDelays</code>来重写settings的全局变量。一般第一个参数指定<code>lsyncd</code>以什么模式运行：<code>rsync</code>、<code>rsyncssh</code>、<code>direct</code>三种模式：</p>

<ul>
<li><p><code>default.rsync</code> ：本地目录间同步，使用rsync，也可以达到使用ssh形式的远程rsync效果，或daemon方式连接远程rsyncd进程；<br><code>default.direct</code> ：本地目录间同步，使用<code>cp</code>、<code>rm</code>等命令完成差异文件备份；<br><code>default.rsyncssh</code> ：同步到远程主机目录，rsync的ssh模式，需要使用key来认证</p></li>
<li><p><code>source</code> 同步的源目录，使用绝对路径。</p></li>
<li><p><code>target</code> 定义目的地址.对应不同的模式有几种写法：<br><code>/tmp/dest</code> ：本地目录同步，可用于<code>direct</code>和<code>rsync</code>模式<br><code>172.29.88.223:/tmp/dest</code> ：同步到远程服务器目录，可用于<code>rsync</code>和<code>rsyncssh</code>模式，拼接的命令类似于<code>/usr/bin/rsync -ltsd --delete --include-from=- --exclude=* SOURCE TARGET</code>，剩下的就是rsync的内容了，比如指定username，免密码同步<br><code>172.29.88.223::module</code> ：同步到远程服务器目录，用于<code>rsync</code>模式<br>
三种模式的示例会在后面给出。</p></li>
<li><p><code>init</code> 这是一个优化选项，当<code>init = false</code>，只同步进程启动以后发生改动事件的文件，原有的目录即使有差异也不会同步。默认是<code>true</code></p></li>
<li><p><code>delay</code> 累计事件，等待rsync同步延时时间，默认15秒（最大累计到1000个不可合并的事件）。也就是15s内监控目录下发生的改动，会累积到一次rsync同步，避免过于频繁的同步。（可合并的意思是，15s内两次修改了同一文件，最后只同步最新的文件）</p></li>
<li>
<p><code>excludeFrom</code> 排除选项，后面指定排除的列表文件，如<code>excludeFrom = "/etc/lsyncd.exclude"</code>，如果是简单的排除，可以使用<code>exclude = LIST</code>。<br>
这里的排除规则写法与原生rsync有点不同，更为简单：</p>

<ul>
<li>监控路径里的任何部分匹配到一个文本，都会被排除，例如<code>/bin/foo/bar</code>可以匹配规则<code>foo</code>
</li>
<li>如果规则以斜线<code>/</code>开头，则从头开始要匹配全部</li>
<li>如果规则以<code>/</code>结尾，则要匹配监控路径的末尾</li>
<li>
<code>?</code>匹配任何字符，但不包括<code>/</code>
</li>
<li>
<code>*</code>匹配0或多个字符，但不包括<code>/</code>
</li>
<li>
<code>**</code>匹配0或多个字符，可以是<code>/</code>
</li>
</ul>
</li>
<li><p><code>delete</code> 为了保持target与souce完全同步，Lsyncd默认会<code>delete = true</code>来允许同步删除。它除了<code>false</code>，还有<code>startup</code>、<code>running</code>值，请参考 <a rel="nofollow" href="https://github.com/axkibe/lsyncd/wiki/Lsyncd%202.1.x%20%E2%80%96%20Layer%204%20Config%20%E2%80%96%20Default%20Behavior">Lsyncd 2.1.x ‖ Layer 4 Config ‖ Default Behavior</a>。</p></li>
</ul>
<p><strong>rsync</strong><br>
（提示一下，<code>delete</code>和<code>exclude</code>本来都是<strong>rsync</strong>的选项，上面是配置在<strong>sync</strong>中的，我想这样做的原因是为了减少rsync的开销）</p>

<ul>
<li>
<code>bwlimit</code> 限速，单位kb/s，与rsync相同（这么重要的选项在文档里竟然没有标出）</li>
<li>
<code>compress</code> 压缩传输默认为<code>true</code>。在带宽与cpu负载之间权衡，本地目录同步可以考虑把它设为<code>false</code>
</li>
<li>
<code>perms</code> 默认保留文件权限。</li>
<li>其它rsync的选项</li>
</ul>
<p>其它还有rsyncssh模式独有的配置项，如<code>host</code>、<code>targetdir</code>、<code>rsync_path</code>、<code>password_file</code>，见后文示例。<code>rsyncOps={"-avz","--delete"}</code>这样的写法在2.1.*版本已经不支持。</p>

<p><code>lsyncd.conf</code>可以有多个<code>sync</code>，各自的source，各自的target，各自的模式，互不影响。</p>

<h2>2.3 启动lsyncd</h2>

<p>使用命令加载配置文件，启动守护进程，自动同步目录操作。</p>

<pre><code>lsyncd -log Exec /usr/local/lsyncd-2.1.5/etc/lsyncd.conf
</code></pre>

<h2>2.4 lsyncd.conf其它模式示例</h2>

<p>以下配置本人都已经过验证可行，必须根据实际需要裁剪配置：</p>

<pre><code>settings {
    logfile ="/usr/local/lsyncd-2.1.5/var/lsyncd.log",
    statusFile ="/usr/local/lsyncd-2.1.5/var/lsyncd.status",
    inotifyMode = "CloseWrite",
    maxProcesses = 8,
    }


-- I. 本地目录同步，direct：cp/rm/mv。 适用：500+万文件，变动不大
sync {
    default.direct,
    source    = "/tmp/src",
    target    = "/tmp/dest",
    delay = 1
    maxProcesses = 1
    }

-- II. 本地目录同步，rsync模式：rsync
sync {
    default.rsync,
    source    = "/tmp/src",
    target    = "/tmp/dest1",
    excludeFrom = "/etc/rsyncd.d/rsync_exclude.lst",
    rsync     = {
        binary = "/usr/bin/rsync",
        archive = true,
        compress = true,
        bwlimit   = 2000
        } 
    }

-- III. 远程目录同步，rsync模式 + rsyncd daemon
sync {
    default.rsync,
    source    = "/tmp/src",
    target    = "syncuser@172.29.88.223::module1",
    delete="running",
    exclude = { ".*", ".tmp" },
    delay = 30,
    init = false,
    rsync     = {
        binary = "/usr/bin/rsync",
        archive = true,
        compress = true,
        verbose   = true,
        password_file = "/etc/rsyncd.d/rsync.pwd",
        _extra    = {"--bwlimit=200"}
        }
    }

-- IV. 远程目录同步，rsync模式 + ssh shell
sync {
    default.rsync,
    source    = "/tmp/src",
    target    = "172.29.88.223:/tmp/dest",
    -- target    = "root@172.29.88.223:/remote/dest",
    -- 上面target，注意如果是普通用户，必须拥有写权限
    maxDelays = 5,
    delay = 30,
    -- init = true,
    rsync     = {
        binary = "/usr/bin/rsync",
        archive = true,
        compress = true,
        bwlimit   = 2000
        -- rsh = "/usr/bin/ssh -p 22 -o StrictHostKeyChecking=no"
        -- 如果要指定其它端口，请用上面的rsh
        }
    }

-- V. 远程目录同步，rsync模式 + rsyncssh，效果与上面相同
sync {
    default.rsyncssh,
    source    = "/tmp/src2",
    host      = "172.29.88.223",
    targetdir = "/remote/dir",
    excludeFrom = "/etc/rsyncd.d/rsync_exclude.lst",
    -- maxDelays = 5,
    delay = 0,
    -- init = false,
    rsync    = {
        binary = "/usr/bin/rsync",
        archive = true,
        compress = true,
        verbose   = true,
        _extra = {"--bwlimit=2000"},
        },
    ssh      = {
        port  =  1234
        }
    }
</code></pre>

<p>上面的内容几乎涵盖了所有同步的模式，其中第<code>III</code>个要求像rsync一样配置rsyncd服务端，见本文开头。第<code>IV</code>、<code>V</code>配置ssh方式同步，达到的效果相同，但实际同步时你会发现每次同步都会提示输入ssh的密码，可以通过以下方法解决：</p>

<p>在远端被同步的服务器上开启ssh无密码登录，请注意用户身份：</p>

<pre><code>user$ ssh-keygen -t rsa
一路回车...
user$ cd ~/.ssh
user$ cat id_rsa.pub &gt;&gt; authorized_keys
</code></pre>

<p>把<code>id_rsa</code>私钥拷贝到执行lsyncd的机器上</p>

<pre><code>user$ chmod 600 ~/.ssh/id_rsa
测试能否无密码登录
user$ ssh user@172.29.88.223
</code></pre>

<h1>3. lsyncd的其它功能</h1>

<p><code>lsyncd</code>的功能不仅仅是同步，官方手册 <a rel="nofollow" href="https://github.com/axkibe/lsyncd/wiki/Lsyncd%202.1.x%20%E2%80%96%20Layer%202%20Config%20%E2%80%96%20Advanced%20onAction">Lsyncd 2.1.x ‖ Layer 2 Config ‖ Advanced onAction</a> 高级功能提到，还可以监控某个目录下的文件，根据触发的事件自己定义要执行的命令，example是监控某个某个目录，只要是有jpg、gif、png格式的文件参数，就把它们转成pdf，然后同步到另一个目录。正好在我运维的一个项目中有这个需求，现在都是在java代码里转换，还容易出现异常，通过lsyncd可以代替这样的功能。但，门槛在于要会一点点lua语言（根据官方example还是可以写出来）。</p>

<p>另外偶然想到个问题，同时设置了<code>maxDelays</code>和<code>delay</code>，当监控目录一直没有文件变化了，也会发生同步操作，虽然没有可rsync的文件。</p>

<p>TO-DO：</p>

<ul>
<li>其它同步工具：<a rel="nofollow" href="http://www.chinaxing.org/articles/linux/2013/04/18/2013-04-18-incrond-and-csync2.html">csync2</a>，clsync，btsync，drdb 。</li>
<li>lsyncd双向同步：<a rel="nofollow" href="https://github.com/axkibe/lsyncd/wiki/Faq">GlusterFS</a>
</li>
</ul>
<p><strong>参考</strong></p>

<ul>
<li>
<a rel="nofollow" href="https://github.com/axkibe/lsyncd/wiki/Manual-to-Lsyncd-2.1.x">Lsyncd21Manual</a> （本文很大一部分翻译自官网手册）</li>
<li><a rel="nofollow" href="http://www.cnblogs.com/ivistn/p/3906897.html">使用lsyncd配置数据库备份多异地同步</a></li>
<li><a rel="nofollow" href="http://ju.outofmemory.cn/entry/87237">如何实时同步大量小文件</a></li>
<li><a rel="nofollow" href="http://weekyuan.blog.51cto.com/2389856/1334324">Lsyncd 测试远程、本地目录自动同步</a></li>
</ul>
<hr>
<p>原文链接地址：<a rel="nofollow" href="http://seanlook.com/2015/05/06/lsyncd-synchronize-realtime/">http://seanlook.com/2015/05/06/lsyncd-synchronize-realtime/</a></p>

<hr>

2015年五月7日下午 4:30:48
请问如何用 node.js来获取到安卓手机指定程序的内存占用？？
<div class="markdown-text"><p>要求仅仅返回这个内存占用的数值，其他的都不要。。可以但是通过ADB命令实现，但是我始终无法单独获得到那个数值。。求大神给给思路。</p>
</div>

2015年五月7日下午 1:57:47
北京皇玩科技有限公司招node.js服务器主程序一枚
<div class="markdown-text"><p>公司名称：皇玩科技有限公司
工作地点：北京（上地地铁附近）
工作环境：良好
招一名有多年游戏开发经验的node.js服务器主程序一名
待遇 15-25K
联系方式：QQ 34753134
本人技术出身，不太擅长写招聘信息，多多见谅！
详情请直接Q我，有兴趣的技术大神们多多联系我~ 谢谢！</p>
</div>

2015年五月7日下午 1:47:14
你们是怎么验证表单的
<div class="markdown-text"><p>寻求验证表单的优雅方法。
这是我目前的方法，以express为例子</p>
<pre class="prettyprint language-javascript"><code>var required = [/**表单需要接受的字段**/];
var optional = [/**可选字段**/];
var body = req.body;
var tbody = {};
//检测必选字段
required.forEach(function (item,index) {
  if(body[item]){
    tbody.item = xss(body[item]);//附带xss处理
  }else{
    //返回错误信息
  }
});
//检测可选字段
optional.forEach(function (item,index) {
  if(body[item]){
    tbody.item = xss(body[item]);
  }
});
//字段去重，当然，这里用的是express就不需要

//然后各种validator验证类型 巴拉巴拉****
</code></pre></div>

2015年五月7日下午 1:18:42
alsotang commented on issue cnodejs/nodeclub#523
<!-- issue_comment -->
<span class="mega-octicon octicon-comment-discussion"></span>

<div class="time">
  <time datetime="2015-05-07T05:18:42Z" is="relative-time">May 7, 2015</time>
</div>

<div class="title">
  <a href="https://github.com/alsotang" data-ga-click="News feed, event click, Event click type:IssueCommentEvent target:actor">alsotang</a> <span>commented</span> on issue <a href="https://github.com/cnodejs/nodeclub/issues/523#issuecomment-99721935" data-ga-click="News feed, event click, Event click type:IssueCommentEvent target:issue-comment" title="proxy/topic加一句代码首页就可以缓存了">cnodejs/nodeclub#523</a>
</div>

<div class="details">
  <a href="https://github.com/alsotang"><img alt="@alsotang" class="gravatar" data-user="1147375" height="30" src="https://avatars0.githubusercontent.com/u/1147375?v=3&amp;s=60" width="30" /></a>
  <div class="message markdown-body">
    <blockquote>
      <p>html 片段缓存中的【片段】是指渲染出来之后的 html。</p>
    </blockquote>
  </div>
</div>

2015年五月7日中午 12:04:18
［北京］ 招前端伙伴－－不讲情怀
<div class="markdown-text"><p>出来混的，总是要还的。很抱歉，一直没给cnode社区贡献过什么内容，未来一定改进。</p>
<p>看到各家招人各种福利和卖萌，都不知道该如何介绍我们了。在这里我无法给大家一个描述的非常理想的工作环境，只能说我们在努力，努力让团队里的每一人都觉得加入这个团队是一件非常值得怀念的一段日子。</p>
<p>技术人员选择一家公司一起成长，我个人认为会考虑几件事：</p>
<ol>
<li>公司靠谱不？要完全靠谱可以选择BAT，不过也保不齐公司战略一推动，前端面临转方向和转岗问题。作为一家创业公司我无法保证公司一定靠谱，因为中国互联网创业失败比例是很高的，基本达到95%以上。把公司的事业做成一件靠谱的事是我们努力的方向。</li>
<li>环境如何？个人技术上的成长是每一个技术人对一个技术团队考量的重要指标。现在公司技术人员15人，其中有5年以上工作经验地6人，10年以上工作经验地2人。分别在这几个领域做出过一点成绩：流媒体，CDN技术，大数据处理。一个在技术管理岗位有过10多年管理经验的老技术人员和一个在写过10多年javascript，并在前端和后端都有点技术能力的技术人。团队深知前端的价值和方向，也懂得如何平衡技术，产品，市场。</li>
<li>薪资福利呢？就不提各种现在标配的招聘福利了，我个人觉得有点虚。15k-40k/月，期望这份薪水还算对得起你的付出。
公司做视频，目前产品线上有tv端，电视盒子，移动端和社区。我们市场目标在海外，努力让世界了解中国。这些都不重要，重要的是你选择了一个有活力和快速增长的团队，还有能给你一个不错的待遇。</li>
</ol>
<p>现觅几位前端工程师一起加入。只有一点要求：熟悉HTML/CSS/Javascript(或精通其中一项)，热爱自己，热爱生活。</p>
<p>我们的项目中小范围使用ES6、CSS3、HTML5、AngularJS、Grunt、Bower。Web Component、Shadow DOM、React Native、Node.js都是我们将要玩的东西。希望你能够善于学习，有梦想，对于技术有一份热爱和执着。个人认为有自己的梦想，并且热爱自己，热爱生活的人在其它方面都不会差。</p>
<p>加分：</p>
<ol>
<li>有美感，有自己的思想。</li>
<li>Github有自己的项目或给大型项目贡献过代码</li>
<li>有过分享</li>
<li>写过自己的所思所想</li>
<li>豆瓣书单</li>
<li>懂交互、设计和细节</li>
<li>能站在不同的角度看待问题</li>
</ol>
<p>联系： [<a href="mailto:mashihua@goline.com">mashihua@goline.com</a>](<a href="mailto:mashihua@gochinatv.com">mailto:mashihua@gochinatv.com</a>?subject=前端入伙 来自cnodejs)</p>
<p>报告管理员，markdown编辑器有点问题。</p>
</div>

2015年五月7日中午 11:39:49
Lua 学习笔记（六） —— 字符串操作
<h1>   1 模式</h1>

<h2>1.1 字符类</h2>

<p>字符类代表一组字符。可以用下列组合来表示一个字符类。</p>

<table>
<thead><tr>
<th>组合</th>
  <th>代表字母</th>
  <th>代表字符类型</th>
</tr></thead>
<tbody>
<tr>
<td>x</td>
  <td>（变量 x）</td>
  <td>
<code>^$()%.[]*+-?</code>以外的任一字符</td>
</tr>
<tr>
<td>.</td>
  <td>（dot）</td>
  <td>任意字符</td>
</tr>
<tr>
<td>%a</td>
  <td>（alphabet）</td>
  <td>字母</td>
</tr>
<tr>
<td>%b</td>
  <td>（bracket）</td>
  <td>对称字符以及字符间的内容</td>
</tr>
<tr>
<td>%c</td>
  <td>（control）</td>
  <td>控制字符（即各类转义符）</td>
</tr>
<tr>
<td>%d</td>
  <td>（digits）</td>
  <td>数字</td>
</tr>
<tr>
<td>%l</td>
  <td>（lowercase）</td>
  <td>小写字母</td>
</tr>
<tr>
<td>%p</td>
  <td>（punctuation）</td>
  <td>标点符号</td>
</tr>
<tr>
<td>%s</td>
  <td>（space）</td>
  <td>空格</td>
</tr>
<tr>
<td>%u</td>
  <td>（uppercase）</td>
  <td>大写字母</td>
</tr>
<tr>
<td>%w</td>
  <td>（word）</td>
  <td>字母和数字</td>
</tr>
<tr>
<td>%x</td>
  <td>（hexadecimal）</td>
  <td>十六进制字符</td>
</tr>
<tr>
<td>%z</td>
  <td>（zero）</td>
  <td>值为 0 的字符，即 '\0'</td>
</tr>
<tr>
<td>%x</td>
  <td>（变量 x）</td>
  <td>字母和数字以外的任一字符</td>
</tr>
</tbody>
</table>
<p>如果组合中的字符写成大写形式（例如将 '%a' 写成 '%A'），相当于对原来所代表的字符类型取<strong>补集</strong>。</p>

<p><strong>例子：</strong></p>

<p>前两行的数字标出每个字符的下标。find函数返回找出第一个符合查找条件的字符的下标。</p>

<pre><code>-----------------00000000001111111112 222222222333333333344444444445555 5
-----------------12345678901234567890 123456789012345678901234567890123 4
x = string.find("Tutu is a young man.\n His student number is 20230001.\0","i")
    --&gt; 6
x = string.find("Tutu is a young man.\n His student number is 20230001.\0",".")
    --&gt; 1
x = string.find("Tutu is a young man.\n His student number is 20230001.\0","%a")    --&gt; 1   
x = string.find("Tutu is a young man.\n His student number is 20230001.\0","%c")    --&gt; 21 
x = string.find("Tutu is a young man.\n His student number is 20230001.\0","%d")    --&gt; 45 
x = string.find("Tutu is a young man.\n His student number is 20230001.\0","%l")    --&gt; 2   
x = string.find("Tutu is a young man.\n His student number is 20230001.\0","%p")    --&gt; 20 
x = string.find("Tutu is a young man.\n His student number is 20230001.\0","%s")    --&gt; 5   
x = string.find("Tutu is a young man.\n His student number is 20230001.\0","%u")    --&gt; 1   
x = string.find("Tutu is a young man.\n His student number is 20230001.\0","%w")    --&gt; 1   
x = string.find("Tutu is a young man.\n His student number is 20230001.\0","%x")    --&gt; 9   
x = string.find("Tutu is a young man.\n His student number is 20230001.\0","%z")    --&gt; 54 
</code></pre>

<p>加 <code>()</code> 表示捕捉，find的第三个参数返回被捕捉到的字符串,在这里即返回找到的那个字符。</p>

<pre><code>x,y,z = string.find("%()~!@#$%^&amp;*():\";\'?&lt;&gt;._[]","(%%)")   --&gt; 1   1   %
x,y,z = string.find("%()~!@#$%^&amp;*():\";\'?&lt;&gt;._[]","(%#)")   --&gt; 7   7   #
x,y,z = string.find("%()~!@#$%^&amp;*():\";\'?&lt;&gt;._[]","(%\")")  --&gt; 16  16  "
</code></pre>

<p>下句中的 <code>+</code> 表示取一个或多个满足条件的连续字符。</p>

<pre><code>                 --1 2 3 4 5 6 7 8
x,y = string.find("\a\b\f\n\r\t\v\0","%c+")     --&gt; 1   7
</code></pre>

<p>上句基本列出了所有控制字符，并不是所有转义符都是控制字符，例如 <code>\\</code> 和 <code>\xff</code> 不属于控制字符。</p>

<p><code>match</code> 函数返回符合匹配条件的字符子串。</p>

<pre><code>x = string.match("0123456789ABCDEFabcdefg","%x+")   --&gt; 0123456789ABCDEFabcdef
</code></pre>

<p>输出的符号即为 <code>%x</code> 所支持的所有字符。</p>

<p><code>%b</code> 的使用方法与前面的组合形式略有不同，其形式为 <code>%bxy</code>，使用示例如下：</p>

<pre><code>---------------------00000000001111111112 22222222233333333334444444444555555 5
---------------------12345678901234567890 12345678901234567890123456789012345 6
x,y,z = string.find("Tutu is a young man.\n His student number is [20230001].\0","(%b[])")  --&gt; 45  54  [20230001]
x,y,z = string.find("Tutu is a young man.\n His student number is _20230001_.\0","(%b__)")  --&gt; 45  54  _20230001_
x,y,z = string.find("Tutu is a young man.\n His student number is _20230001_.\0","(%b21)")  --&gt; 48  53  230001
</code></pre>

<h2>1.2 <code>[]</code> 字符集</h2>

<p>字符集操作是对<strong>字符类</strong>中<strong>组合</strong>的一个扩展。可以通过 <code>[]</code> 制定出用户所需的一套字符选取范围。</p>

<pre><code>---------------------0000000001111111111222222222
---------------------1234567890123456789012345678
x,y,z = string.find("[Email]: tangyikejun@163.com","([123])")           --&gt; 22  22  1
x,y,z = string.find("[Email]: tangyikejun@163.com","([l]])")            --&gt; 6   7   l]
x,y,z = string.find("[Email]: tangyikejun@163.com","([1-3])")           --&gt; 22  22  1
x,y,z = string.find("[Email]: tangyikejun@163.com","([^1-3])")          --&gt; 1   1   [
x,y,z = string.find("[Email]: tangyikejun@163.com","([^%d])")           --&gt; 1   1   [
x,y,z = string.find("[Email]: tangyikejun@163.com","([0-9][%d][%d])")   --&gt; 22  24  163
x,y,z = string.find("[Email]: tangyikejun@163.com","([0-9]+)")          --&gt; 22  24  163
</code></pre>

<p><strong>使用特点：</strong></p>

<ol>
<li>每个字符集仅限定一个字符的范围。</li>
<li>连字符 <code>-</code> 用于限定字符的范围，值域根据字符在ASCII码中对应的值得出，例如 <code>[0-7]</code> 代表字符范围为 0-7。<br><code>x,y,z = string.find("!\"#$%&amp;0123","([$-1]+)")          --&gt; 4   8   $%&amp;01</code>
</li>
<li>添加 <code>^</code> 表示对指定的字符范围取补集。<code>[^%d]</code> 等价于 <code>[%D]</code>。</li>
</ol>
<h2>1.3 模式项</h2>

<table>
<thead><tr>
<th>模式项</th>
  <th>作用</th>
</tr></thead>
<tbody>
<tr>
<td>+</td>
  <td>匹配1个或多个字符，尽可能多地匹配</td>
</tr>
<tr>
<td>-</td>
  <td>匹配0个或多个字符，尽可能少地匹配</td>
</tr>
<tr>
<td>*</td>
  <td>匹配0个或多个字符，尽可能多地匹配</td>
</tr>
<tr>
<td>？</td>
  <td>匹配0个或1个字符，尽可能多地匹配</td>
</tr>
</tbody>
</table>
<p><strong>使用特点：</strong></p>

<ol>
<li>模式项都是针对前一个字符而言的。例如 <code>abc-</code> 作用于字符 <code>c</code>。</li>
</ol>
<pre><code>---------------------0000000001
---------------------1234567890
x,y,z = string.find("aaaabbbccc","(%a+)")       --&gt; 1   10  aaaabbbccc
x,y,z = string.find("bbbccc","(a+)")            --&gt; nil nil nil
x,y,z = string.find("aaaabbbccc","(ab-c)")      --&gt; 4   8   abbbc
-- x,y,z = string.find("aaaaccc","(ab-c)")      --&gt; 4   5   ac
-- x,y,z = string.find("aaaaccc","(ab*c)")      --&gt; 4   5   ac
-- x,y,z = string.find("aaaabccc","(ab?c)")     --&gt; 4   6   abc
-- x,y,z = string.find("aaaabccc","(ba?c)")     --&gt; 5   6   bc
</code></pre>

<pre><code>---------------------000000000111 111111122
---------------------123456789012 345678901
x,y,z = string.find("tangyikejun\0 163.com","(%z%s%w+)")    --&gt; 12  16  
x,y,z = string.find("tangyikejun\0163.com","(%z%d%w+)")     --&gt; nil nil     nil 
</code></pre>

<p><strong>注意：</strong> <code>\0</code> 后面不能跟数字。而且用 find 返回的匹配字符串无法输出 <code>\0</code> 之后的部分。</p>

<h2>1.4 模式</h2>

<p>多个模式项组合形成<strong>模式</strong>。</p>

<ul>
<li>模式的前面添加 <code>^</code> 表示匹配从目标字符串的起始位置开始。</li>
<li>模式的末尾添加 <code>$</code> 表示匹配目标字符串的末尾子串。</li>
<li>其他位置的 <code>^</code> 和 <code>$</code> 作为普通字符处理。</li>
</ul>
<pre><code>---------------------0000000001111111111222222222
---------------------1234567890123456789012345678
x,y,z = string.find("[Email]: tangyikejun@163.com","^(.%a+)")   --&gt;1    6   [Email
x,y,z = string.find("[Email]: tangyikejun@163.com","(%a+)$")    --&gt;26   28  com
</code></pre>

<h2>1.5 <code>()</code>捕捉</h2>

<p>捕捉是指将括号内的组合匹配结果保存起来，每个括号保存一个结果。<br>
保存的数据的顺序按照<strong>左括号的顺序</strong>排列。</p>

<pre><code>x,y,z,h,l = string.find("Tutu is a young man.\n His student number is _20230001_.\0","((%a+%s)(%a+%s)%b__)")    --&gt; 35  54  number is _20230001_    number  is 
</code></pre>

<p>字符串模式匹配可参考<a rel="nofollow" href="http://www.cnblogs.com/whiteyun/archive/2009/09/02/1541043.html">Lua模式匹配</a>。</p>

<h1> 2 库函数</h1>

<ul>
<li>字符串的下标从1开始。正数下标表示正向下标，负数表示反向下标（例如 -1 表示字符串最后一个字符）。</li>
<li>函数均默认支持模式匹配。</li>
<li>返回的匹配字符串无法输出 <code>\0</code> 之后的部分。</li>
</ul>
<h2> string.find(s,pattern[,init[,plain]])</h2>

<p>查找字符串的子串，如果找到，返回子串的起始位置、结束位置；找不到返回 nil。<br>
如果使用捕获（即对模式串用括号包裹起来）,则一并返回匹配得到的字符串。</p>

<h3>定义</h3>

<pre><code>string.find([字符串],[待查找字符串],[查找起始位置]=1,[禁用模式匹配]=false)
</code></pre>

<p>只有显式指定了 init 参数才能控制 plain 参数。</p>

<h3>例子</h3>

<pre><code>x,y,z = string.find("1001 is a Robot", "Robot")
print(x,y,z)                                --&gt; 11 15   nil
x,y,z = string.find("1001 is a Robot","1%d",1,true)
print(x,y,z)                                --&gt; nil nil nil
x,y,z = string.find("1001 is a Robot","(%d+)",1,false)
print(x,y,z)                                --&gt; 1   2   1001
</code></pre>

<h2> string.match(s,pattern[,init])</h2>

<p>与 <code>string.find</code> 类似，返回值不一样。<code>string.match</code> 查找字符串的子串，如果找到，返回子串；找不到返回 nil。</p>

<p>支持模式匹配。</p>

<h3>定义</h3>

<p>略</p>

<h3>例子</h3>

<pre><code>x = string.match("1001 is a Robot","001")
print(x)                --&gt; 001                             
x = string.match("1001 is a Robot","%d%d")
print(x)                --&gt; 10      
</code></pre>

<h2> string.gmatch(s,pattern)</h2>

<p>返回一个迭代函数，该函数每执行一次，就返回下一个捕捉到的匹配（如果没有使用捕捉，就返回整个匹配结果）。</p>

<h3>例子</h3>

<pre><code>for s in string.gmatch("I have a Dream.","%a+") do
    print(s)
end
--&gt; I
--&gt; have
--&gt; a
--&gt; Dream
</code></pre>

<pre><code>t = {}
s = "name=tangyikejun, number=20250001"

-- 将捕获的两个子串分别作为键和值放到表t中
for k, v in string.gmatch(s, "(%w+)=(%w+)") do
    t[k] = v
end

-- 输出表t
for k,v in pairs(t) do
    print(k,v)
end

--&gt; name    tangyikejun
--&gt; number  20250001
</code></pre>

<h2> string.format(formatstring,...)</h2>

<p>返回格式化之后的字符串。</p>

<h3>定义</h3>

<p>略</p>

<h3>例子</h3>

<pre><code>string.format("My name is %s", "tangyikejun")   --&gt; My name is tangyikejun
</code></pre>

<h2> string.len(s)</h2>

<p>返回字符串长度</p>

<h2> string.lower(s)</h2>

<p>返回小写字母的字符串</p>

<h2> string.upper(s)</h2>

<p>返回大写字母的字符串</p>

<h2> string.rep(s,n)</h2>

<p>对字符串进行重复</p>

<h3>定义</h3>

<pre><code>string.rep([字符串],[重复次数])
</code></pre>

<h3>例子</h3>

<pre><code>string.rep("Hello",4)   -- HelloHelloHelloHello
</code></pre>

<h2> string.reverse(s)</h2>

<p>返回反转后的字符串。</p>

<h2> string.sub(s,i[,j])</h2>

<p>返回子字符串。</p>

<h3>定义</h3>

<pre><code>string.sub([字符串],[开始字符下标],[结束字符下标]=-1)
</code></pre>

<h3>例子</h3>

<pre><code>x = string.sub("tangyikejun",7)
print(x)                --&gt; kejun
x = string.sub("tangyikejun",1,-6)
print(x)                --&gt; tangyi
</code></pre>

<h2> string.gsub(s,pattern,repl[,n])</h2>

<p>根据模式匹配对字符串中每一个匹配部分都做替换处理，返回替换后的字符串。</p>

<h3>定义</h3>

<pre><code>string.gsub([字符串],[模式匹配],[替换字符],[最大替换次数] = 无限制)
</code></pre>

<p>repl 参数（<code>[替换字符]</code>）支持 字符串、表、函数。</p>

<p>如果 repl 是字符串，那么该字符串就是用于替换的字符串。同时支持 <code>%n</code> 转义符操作，n 的范围是 0-9。n 范围为 [1,9] 时表示第 n 个捕获的匹配字符串，<code>%0</code> 表示整个匹配的字符串，<code>%%</code> 表示替换为一个 <code>%</code>。</p>

<p>如果 repl 是表，那么将捕获的第一个字符串作为键值（Key）进行查询（没有定义捕捉则以整个匹配的字符串为键值），查到的值作为替换的字符串。</p>

<p>如果 repl 是函数，那么每次匹配成功都会调用该函数，并以按序以所有捕捉作为参数传入函数。没有捕捉则以整个匹配的字符作为参数。</p>

<p>如果从表或函数得到是字符串或者是数字，就将其用于替换；如果得到的是 false 或 nil，那么匹配部分将不会发生变化。</p>

<h3>例子</h3>

<p>repl 为字符串</p>

<pre><code>s = "Never say die."
x = string.gsub(s,"die","never")            --&gt; Never say never.
x = string.gsub(s,"die","'%0'")             --&gt; Never say 'die'.
x = string.gsub(s,"(%a+)%s%a+%s(%a+)","%2") --&gt; die.
</code></pre>

<p>限制最大替换次数</p>

<pre><code>s = "never say never."
x = string.gsub(s,"never","Never",1)    --&gt; Never say never.
</code></pre>

<p>repl 是表</p>

<pre><code>t = {name="Lua",version="5.1"}
x = string.gsub("$name-$version.tar.gz","$(%a+)",t) --&gt; Lua-5.1.tar.gz
</code></pre>

<p>repl是函数</p>

<pre><code>x = string.gsub("4+5 = $return 4+5$","%$(.-)%$",function(s)return loadstring(s)() end)  --&gt; 4+5 = 9
x = string.gsub("23+45=$result", "((%d+)%+(%d+)=)%$%a+", function (s,a,b)
    sum = a+b
    return s..sum
end)    --&gt; 23+45=68
</code></pre>

<p>~~<strong>注意：</strong>似乎只支持匿名函数。~~</p>

<p>从表或函数返回的是 false 或 nil</p>

<pre><code>x = string.gsub("4+5 = $return 4+5$","%$(.-)%$",function(s)return nil end)  --&gt; 4+5 = $return 4+5$
t = {name="Lua",version=false}
x = string.gsub("$name-$version.tar.gz","$(%a+)",t) --&gt; Lua-$version.tar.gz
</code></pre>

<h2> string.byte(s[,i[,j]])</h2>

<p>返回字符的 ASCII 码值。</p>

<h3>定义</h3>

<pre><code>string.byte([字符串],[起始下标]=1,[结束下标]=[起始下标])
</code></pre>

<h3>例子</h3>

<pre><code>x,y,z = string.byte("abc",2)    --&gt; 98  nil nil
x,y,z = string.byte("abc",1,3)  --&gt; 97  98  99
</code></pre>

<h2> string.char(...)</h2>

<p>根据传入的 ASCII 编码值（[0-255]）得到对应的字符，传入多少编码值就返回多长的字符串。</p>

<h3>例子</h3>

<pre><code>x = string.char(98,99,100)  --&gt; bcd
</code></pre>

<p>如果输入字符超限会编译报错。</p>

<h2> string.dump(function)</h2>

<p>返回函数的二进制表示（字符串形式），把这个返回值传给 loadingstring 可以获得函数的一份拷贝（传入的函数必须是没有<strong>上值</strong>的 Lua 函数）。</p>

<h3>例子</h3>

<pre><code>function sum(a,b)
    return a + b
end

s = string.dump(sum)
x = loadstring(s)(4,4) -- 8
</code></pre>

<hr>
<h1>参考链接</h1>

<p><a rel="nofollow" href="http://www.cnblogs.com/whiteyun/archive/2009/09/02/1541043.html">Lua模式匹配</a>（参考了此文中对 <code>%b</code> 的使用）</p>

2015年五月7日上午 11:07:33
Stream 中间件框架
<div class="markdown-text"><p>对 Transform 流的数据进行处理，目前用于抓取数据后的过滤。
利用 ES6 的 Generator Function，类似 koa 的中间件机制。
<a href="https://github.com/tvrcgo/hq">https://github.com/tvrcgo/hq</a></p>
</div>

2015年五月7日上午 10:28:52
【上海五角场】减肥健身App-练练  招募Node.js小伙伴！~团队欢乐，待遇棒棒。被看好的创业公司，欢迎你加入
<div class="markdown-text"><p>岗位名称：Node.js高级开发工程师</p>
<p>工作职责：</p>
<ol>
<li>负责服务器后端开发</li>
<li>负责MongoDB、MySql配置</li>
</ol>
<p>任职要求：</p>
<ol>
<li>2年及以上工作经验，全日制本科学历，计算机及通讯技术相关专业。</li>
<li>精通Node开发</li>
<li>熟悉MongoDB Replication和Sharding</li>
<li>有丰富服务器开发经验</li>
<li>适应性强，能迅速融入团队，抗压性高。</li>
</ol>
<p>优先考虑条件：</p>
<ol>
<li>熟悉设计模式</li>
<li>熟悉敏捷开发</li>
<li>熟悉Restful API设计</li>
<li>熟悉开源项目，并有参与经历</li>
</ol>
<p>关于我们：
我们是一家初创移动互联网公司，目前已有一款名为”练练-定制你的专属减肥健身方案”的APP，Android和iOS版本均已上线，超过60万的用户在跟我们一起，没事练练。
我们希望在健身行业拥有自己的一片天地，改变运动习惯，让全民一起练练。团队虽不大，但配置俱全，帅哥萌妹，程序猿，程序媛，应有尽有。我们有激情，有想法，有节操，能吐槽。
我们离成功其实只差4步，一步A轮，二步B轮，三步C轮，四步IPO……然后就可以分钱了（打我可以，不要打脸）。
小白人是我们的吉祥物，用萌系丰富运动，用萌系改变生活，期待你的加入！</p>
<p>我们可以提供：
一份对得起你水平的薪酬
正规的五险一金
轻松、舒适的工作环境
每人都有肾5、肾6做测试机
有独立的办公区域，坐落于魔都五角场，美食外卖停不下来。
同事精挑细选，没有猪一样的队友，不怕神一样的对手。</p>
<p>感兴趣的小伙伴可以发送简历至<a href="mailto:270558403@qq.com">270558403@qq.com</a>
<img src="//dn-cnode.qbox.me/FiZvhwA7dak9M6DzSkhpE29_X7rl" alt="成就1.4.png">
<img src="//dn-cnode.qbox.me/FsEbvL31qgVbZru01zSfNIy0g9YI" alt="启动页.jpg"> <img src="//dn-cnode.qbox.me/Fj1dZ5Vq3TqGvMO1qnv9HOEThZ5h" alt="计时器.jpg"></p>
</div>

2015年五月7日上午 10:20:12
alsotang commented on issue cnodejs/nodeclub#523
<!-- issue_comment -->
<span class="mega-octicon octicon-comment-discussion"></span>

<div class="time">
  <time datetime="2015-05-07T02:20:12Z" is="relative-time">May 7, 2015</time>
</div>

<div class="title">
  <a href="https://github.com/alsotang" data-ga-click="News feed, event click, Event click type:IssueCommentEvent target:actor">alsotang</a> <span>commented</span> on issue <a href="https://github.com/cnodejs/nodeclub/issues/523#issuecomment-99681639" data-ga-click="News feed, event click, Event click type:IssueCommentEvent target:issue-comment" title="proxy/topic加一句代码首页就可以缓存了">cnodejs/nodeclub#523</a>
</div>

<div class="details">
  <a href="https://github.com/alsotang"><img alt="@alsotang" class="gravatar" data-user="1147375" height="30" src="https://avatars0.githubusercontent.com/u/1147375?v=3&amp;s=60" width="30" /></a>
  <div class="message markdown-body">
    <blockquote>
      <p>暂时还是不要了。现在这方面的性能问题也不大。 按照这篇文章来说，对于这类场景我还是倾向于 html 片段缓存：<a href="https://cnodejs.org/topic/55210d88c4f5240812f55408">https://cnodejs.org/topic/55210d88c4f5240812f55408</a></p>
    </blockquote>
  </div>
</div>

2015年五月7日上午 9:57:22
请问怎么利用v8.log来分析node写的服务的性能呢？
<div class="markdown-text"><p>目前我知道关于v8.log的一切，就是node --prof app.js，然后会生成一个v8.log,但是这文件里一堆东西，看不懂。。。哪里有什么资料可以找，或者工具可以分析吗？谢谢~</p>
</div>

2015年五月7日凌晨 12:38:31
关于 node 爬虫问题
<div class="markdown-text"><p>最近在看&lt;包教不包会&gt;教程，遇到上一些问题不太明白</p>
<ol>
<li>为什么会有时能爬到数据，有时却爬不到数据呢？</li>
<li>async.mapLimit 这个接口有点疑问？这个是每爬完一条 url 就返回的结果数据吗？如果是，那么我怎样才能知道所有数据已爬完毕呢?</li>
</ol>
<p>代码如下：</p>
<pre class="prettyprint language-javascript"><code>var express = require(&#x27;express&#x27;);
var superagent = require(&#x27;superagent&#x27;);
var cheerio = require(&#x27;cheerio&#x27;);
var url = require(&#x27;url&#x27;);
var async = require(&#x27;async&#x27;);

var app = express();

app.get(&#x27;/&#x27;, function(req, res){
  var targetUrl = &#x27;https://cnodejs.org&#x27;;
  superagent.get(targetUrl).end(function(err, html){
    if(err){
      console.error(&#x27;urls: &#x27;, err);
    }

    var $ = cheerio.load(html.text);
    var urls = [];
    // 获取所有链接
    $(&#x27;#topic_list .topic_title&#x27;).each(function(key, value){
      var $obj = $(value);
      var href = $obj.attr(&#x27;href&#x27;);
      var link = url.resolve(targetUrl, href)

      urls.push(link);
    });

    // 定义当前并发数
    var concurrencyCount = 0;
    function fetchUrls(url, callback){
      // 抓取单条主题的内容
      var topic = {};
      superagent.get(url).end(function(err, thtml){
        var $ = cheerio.load(thtml);
        var title = $(&#x27;#content .topic_header .topic_full_title&#x27;).text().trim();
        var content = $(&#x27;#content .topic_content .markdown-text&#x27;).text().trim();
        var link = url;

        topic = {
          &quot;title&quot; : title,
          &quot;content&quot; : content,
          &quot;link&quot; : link
        };
      });

      // 随机间隔时间
      var delay = parseInt((Math.random() * 10000000) % 3000, 10);
      concurrencyCount++;
      console.log(&#x27;当前并发数是&#x27;+ concurrencyCount +&#x27;, 正在抓取的是&#x27;+ url +&#x27;, 耗时&#x27;+ delay + &#x27;毫秒.&#x27;);

      setTimeout(function(){
        concurrencyCount--;
        callback(null, topic);
      }, delay);
    }

    // 控制并发数
    async.mapLimit(urls, 3, function(url, callback){
      fetchUrls(url, callback);
    }, function(err, result){
      if(err){
        console.error(&#x27;final: &#x27;, err);
      }

      console.log(&#x27;final: &#x27;, result);
      res.send(result);
    });
  });

});

app.listen(4000, function(){
  console.log(&#x27;hello cnodejs.&#x27;);
});

</code></pre><p>谢谢你看到这里.</p>
</div>

2015年五月7日凌晨 12:28:07
构造url参数上的gbk编码
<div class="markdown-text"><p>最近有一个需求，需要组装url进行接口调用，但是url上其中一个参数需要通过gbk编码，知道nodejs在utf8的编码比较麻烦，找了iconv-lite模块可以转化参数，但转化出来变成 <img src="//dn-cnode.qbox.me/FtGqRDnzmPjxNCie4s3PRin7B9wX" alt="QQ截图20150507003059.png">  想问问各位有什么方案可以解决。</p>
</div>

2015年五月6日晚上 8:21:08
alsotang commented on issue cnodejs/nodeclub#522
<!-- issue_comment -->
<span class="mega-octicon octicon-comment-discussion"></span>

<div class="time">
  <time datetime="2015-05-06T12:21:08Z" is="relative-time">May 6, 2015</time>
</div>

<div class="title">
  <a href="https://github.com/alsotang" data-ga-click="News feed, event click, Event click type:IssueCommentEvent target:actor">alsotang</a> <span>commented</span> on issue <a href="https://github.com/cnodejs/nodeclub/issues/522#issuecomment-99428536" data-ga-click="News feed, event click, Event click type:IssueCommentEvent target:issue-comment" title="ejs 设置多个layout怎么配置？">cnodejs/nodeclub#522</a>
</div>

<div class="details">
  <a href="https://github.com/alsotang"><img alt="@alsotang" class="gravatar" data-user="1147375" height="30" src="https://avatars0.githubusercontent.com/u/1147375?v=3&amp;s=60" width="30" /></a>
  <div class="message markdown-body">
    <blockquote>
      <p>在 render 的时候应该是可以指定 layout 的吧？特定页面指定一下就好了。 不过还是不太懂你问的是什么。 2015-05-06 16:25 GMT+08:00 stiyes <a href="mailto:notifications@github.com">notifications@github.com</a>: 
我的已经是，模板文件layout.html，再加几个模板…</p>
    </blockquote>
  </div>
</div>

2015年五月6日晚上 7:56:10
alsotang pushed to online at cnodejs/nodeclub
<!-- push -->
<span class="mega-octicon octicon-git-commit"></span>

<div class="time">
  <time datetime="2015-05-06T11:56:10Z" is="relative-time">May 6, 2015</time>
</div>

<div class="title">
  <a href="https://github.com/alsotang" data-ga-click="News feed, event click, Event click type:PushEvent target:actor">alsotang</a> <span>pushed</span> to <a href="/cnodejs/nodeclub/tree/online" data-ga-click="News feed, event click, Event click type:PushEvent target:branch">online</a> at <a href="https://github.com/cnodejs/nodeclub" data-ga-click="News feed, event click, Event click type:PushEvent target:repo">cnodejs/nodeclub</a>
</div>

<div class="details">
  <a href="https://github.com/alsotang"><img alt="@alsotang" class="gravatar" data-user="1147375" height="30" src="https://avatars0.githubusercontent.com/u/1147375?v=3&amp;s=60" width="30" /></a>

    <div class="commits pusher-is-only-committer">
      <ul>
        <li>
          <span title="alsotang">
            <img alt="@alsotang" data-user="1147375" height="16" src="https://avatars1.githubusercontent.com/u/1147375?v=3&amp;s=32" width="16" />
          </span>
          <code><a href="/cnodejs/nodeclub/commit/2de5f109e0258af4ac6fd85031ef7f5835f67f25" data-ga-click="News feed, event click, Event click type:PushEvent target:sha">2de5f10</a></code>
          <div class="message">
            <blockquote>
              coding.net
            </blockquote>
          </div>
        </li>
        <li>
          <span title="alsotang">
            <img alt="@alsotang" data-user="1147375" height="16" src="https://avatars1.githubusercontent.com/u/1147375?v=3&amp;s=32" width="16" />
          </span>
          <code><a href="/cnodejs/nodeclub/commit/adc3770aff07199d71429031e096c1ac449ec88d" data-ga-click="News feed, event click, Event click type:PushEvent target:sha">adc3770</a></code>
          <div class="message">
            <blockquote>
              coding.net
            </blockquote>
          </div>
        </li>
        <li class="more"><a href="https://github.com/cnodejs/nodeclub/compare/93829293a5...2de5f109e0" data-ga-click="News feed, event click, Event click type:PushEvent target:comparison">4 more commits &raquo;</a></li>
      </ul>
    </div>
</div>

2015年五月6日晚上 7:55:36
alsotang pushed to master at cnodejs/nodeclub
<!-- push -->
<span class="mega-octicon octicon-git-commit"></span>

<div class="time">
  <time datetime="2015-05-06T11:55:36Z" is="relative-time">May 6, 2015</time>
</div>

<div class="title">
  <a href="https://github.com/alsotang" data-ga-click="News feed, event click, Event click type:PushEvent target:actor">alsotang</a> <span>pushed</span> to <a href="/cnodejs/nodeclub/tree/master" data-ga-click="News feed, event click, Event click type:PushEvent target:branch">master</a> at <a href="https://github.com/cnodejs/nodeclub" data-ga-click="News feed, event click, Event click type:PushEvent target:repo">cnodejs/nodeclub</a>
</div>

<div class="details">
  <a href="https://github.com/alsotang"><img alt="@alsotang" class="gravatar" data-user="1147375" height="30" src="https://avatars0.githubusercontent.com/u/1147375?v=3&amp;s=60" width="30" /></a>

    <div class="commits pusher-is-only-committer">
      <ul>
        <li>
          <span title="alsotang">
            <img alt="@alsotang" data-user="1147375" height="16" src="https://avatars1.githubusercontent.com/u/1147375?v=3&amp;s=32" width="16" />
          </span>
          <code><a href="/cnodejs/nodeclub/commit/f7b9a10760ff62df16a70e70909f140b3dd4ed51" data-ga-click="News feed, event click, Event click type:PushEvent target:sha">f7b9a10</a></code>
          <div class="message">
            <blockquote>
              update pm2 to 0.12.13
            </blockquote>
          </div>
        </li>
      </ul>
    </div>
</div>

2015年五月6日晚上 7:54:17
alsotang pushed to online at cnodejs/nodeclub
<!-- push -->
<span class="mega-octicon octicon-git-commit"></span>

<div class="time">
  <time datetime="2015-05-06T11:54:17Z" is="relative-time">May 6, 2015</time>
</div>

<div class="title">
  <a href="https://github.com/alsotang" data-ga-click="News feed, event click, Event click type:PushEvent target:actor">alsotang</a> <span>pushed</span> to <a href="/cnodejs/nodeclub/tree/online" data-ga-click="News feed, event click, Event click type:PushEvent target:branch">online</a> at <a href="https://github.com/cnodejs/nodeclub" data-ga-click="News feed, event click, Event click type:PushEvent target:repo">cnodejs/nodeclub</a>
</div>

<div class="details">
  <a href="https://github.com/alsotang"><img alt="@alsotang" class="gravatar" data-user="1147375" height="30" src="https://avatars0.githubusercontent.com/u/1147375?v=3&amp;s=60" width="30" /></a>

    <div class="commits pusher-is-only-committer">
      <ul>
        <li>
          <span title="alsotang">
            <img alt="@alsotang" data-user="1147375" height="16" src="https://avatars1.githubusercontent.com/u/1147375?v=3&amp;s=32" width="16" />
          </span>
          <code><a href="/cnodejs/nodeclub/commit/93829293a5958263b259e512d74e26fd3d3b6140" data-ga-click="News feed, event click, Event click type:PushEvent target:sha">9382929</a></code>
          <div class="message">
            <blockquote>
              coding.net
            </blockquote>
          </div>
        </li>
      </ul>
    </div>
</div>

2015年五月6日下午 5:45:19
koa有什么优势么？昨天压测了下，结果略失望
<div class="markdown-text"><p>node版本为0.11.14，以http和koa分别写简单server服务（输出hello world），高并发高请求下，http的qps要比koa高100左右（例如c300n10000时，http的qps为1623，koa为1527；c500n15000时，http的qps为1288，koa为1152）。且单个请求的平均响应时间，http的要比koa的快。
之前把一个服务重新用koa写了下，压测的时候发现qps反而降低了。。。打击啊:(</p>
</div>

2015年五月6日下午 5:04:23
8 个你可能不知道的 Docker 知识
<blockquote>
  <p>Docker 这个工具已经出现很长一段时间了，但是可能还有很多人对 Docker 的概念不太清楚，因此这次翻译 <a rel="nofollow" href="http://blog.greenpages.com/miscellaneous-it/8-things-you-may-not-know-about-docker/">8 个你可能不知道的 Docker 知识</a> 这篇文章，和大家介绍一下生产环境中的 Docker 用例。</p>
</blockquote>

<p>自从上世纪 90 年代硬件虚拟化被主流的技术广泛普及之后，对数据中心而言，发生的最大的变革莫过于容器和容器管理工具，例如：Docker。在过去的一年内，Docker 技术已经逐渐走向成熟，并且推动了大型初创公司例如 Twitter 和 Airbnb 的发展，甚至在银行、连锁超市、甚至 NASA 的数据中心都赢得了一席之地。当我几年前第一次直到 Docker 的时候，我还对 Docker 的未来持怀疑的态度，我认为他们是把以前的 Linux 容器的概念拿出来包装了一番推向市场。但是使用 Docker 成功进行了几个项目 例如 <a rel="nofollow" href="http://www.spantree.net/">Spantree</a> 之后，我改变了我的看法：Docker 帮助我们节省了大量的时间和经历，并且已经成为我们技术团队中不可或缺的工具。</p>

<p>Github 上面每天都会催生出各式各样的工具、形态各异的语言和千奇百怪的概念。如果你和我一样，没有时间去把他们全部都测试一遍，甚至没有时间去亲自测试 Docker，那么你可以看一下我的这篇文章：我将会用我们在 Docker 中总结的经验来告诉你什么是 Docker、为什么 Docker 会这么火。</p>

<h2>Docker 是容器管理工具</h2>

<p>Docker 是一个轻量级、便携式、与外界隔离的容器，也是一个可以在容器中很方便地构建、传输、运行应用的引擎。和传统的虚拟化技术不同的是，Docker 引擎并不虚拟出一台虚拟机，而是直接使用宿主机的内核和硬件，直接在宿主机上运行容器内应用。也正是得益于此，Docker 容器内运行的应用和宿主机上运行的应用性能差距几乎可以忽略不计。<br>
但是 Docker 本身并不是一个容器系统，而是一个基于原有的容器化工具 LXC 用来创建虚拟环境的工具。类似 LXC 的工具已经在生产环境中使用多年，Docker 则基于此提供了更加友好的镜像管理工具和部署工具。</p>

<h2>Docker 不是虚拟化引擎</h2>

<p>Docker 第一次发布的时候，很多人都拿 Docker 和虚拟机 VMware、KVM 和 VirtualBox 比较。尽管从功能上看，Docker 和虚拟化技术致力于解决的问题都差不多，但是 Docker 却是采取了另一种非常不同的方式。虚拟机是虚拟出一套硬件，虚拟机的系统进行的磁盘操作，其实都是在对虚拟出来的磁盘进行操作。当运行 CPU 密集型的任务时，是虚拟机把虚拟系统里的 CPU 指令“翻译”成宿主机的CPU指令并进行执行。两个磁盘层，两个处理器调度器，两个操作系统消耗的内存，所有虚拟出的这些都会带来相当多的性能损失，一台虚拟机所消耗的硬件资源和对应的硬件相当，一台主机上跑太多的虚拟机之后就会过载。而 Docker 就没有这种顾虑。Docker 运行应用采取的是“容器”的解决方案：使用 namespace 和 CGroup 进行资源限制，和宿主机共享内核，不虚拟磁盘，所有的容器磁盘操作其实都是对 <code>/var/lib/docker/</code> 的操作。简言之，Docker 其实只是在宿主机中运行了一个受到限制的应用程序。</p>

<p>从上面不难看出，容器和虚拟机的概念并不相同，容器也并不能取代虚拟机。在容器力所不能及的地方，虚拟机可以大显身手。例如：宿主机是 Linux，只能通过虚拟机运行 Windows，Docker 便无法做到。再例如，宿主机是 Windows，Windows 并不能直接运行 Docker，Windows上的 Docker 其实是运行在 VirtualBox 虚拟机里的。</p>

<h2>Docker 使用层级的文件系统</h2>

<p>前面提到过，Docker 和现有容器技术 LXC 等相比，优势之一就是 Docker 提供了镜像管理。对于 Docker 而言，镜像是一个静态的、只读的容器文件系统的快照。然而不仅如此，Docker 中所有的磁盘操作都是对特定的Copy-On-Write文件系统进行的。下面通过一个例子解释一下这个问题。<br>
例如我们要建立一个容器运行 JAVA Web 应用，那么我们应该使用一个已经安装了 JAVA 的镜像。在 Dockerfile（一个用于生成镜像的指令文件）中，应该指明“基于 JAVA 镜像”，这样 Docker 就会去 Docker Hub Registry 上下载提前构建好的 JAVA 镜像。然后再 Dockerfile 中指明下载并解压 Apache Tomcat 软件到 <code>/opt/tomcat</code> 文件夹中。这条命令并不会对原有的 JAVA 镜像产生任何影响，而仅仅是在原有镜像上面添加了一个改动层。当一个容器启动时，容器内的所有改动层都会启动，容器会从第一层中运行 <code>/usr/bin/java</code> 命令，并且调用另外一层中的 <code>/opt/tomcat/bin</code> 命令。实际上，Dockerfile 中每一条指令都会产生一个新的改动层，即便只有一个文件被改动。如果用过 Git 就能更清楚地认识这一点，每条指令就像是每次 commit，都会留下记录。但是对于 Docker 来说，这种文件系统提供了更大的灵活性，也可以更方便地管理应用程序。<br>
我们Spantree的团队有一个自己维护的含有 Tomcat 的镜像。发布新版本也非常简单：使用 Dockerfile 将新版本拷贝进镜像从而创建一个新镜像，然后给新镜像贴上版本的标签。不同版本的镜像的不同之处仅仅是一个 90 MB 大小的 WAR 文件，他们所基于的主镜像都是相同的。如果使用虚拟机去维护这些不同的版本的话，还要消耗掉很多不同的磁盘去存储相同的系统，而使用 Docker 就只需要很小的磁盘空间。即便我们同时运行这个镜像的很多实例，我们也只需要一个基础的 JAVA / TOMCAT 镜像。</p>

<h2>Docker 可以节约时间</h2>

<p>很多年前我在为一个连锁餐厅开发软件时，仅仅是为了描述如何搭建环境都需要写一个 12 页的 Word 文档。例如本地 Oracle 数据库，特定版本的 JAVA，以及其他七七八八的系统工具和共享库、软件包。整个搭建过程浪费掉了我们团队每个人几乎一天的时间，如果用金钱衡量的话，花掉了我们上万美金的时间成本。虽然客户已经对这种事情习以为常，甚至认为这是引入新成员、让成员适应环境、让自己的员工适应我们的软件所必须的成本，但是相比较起来，我们宁愿把更多的时间花在为客户构建可以增进业务的功能上面。</p>

<p>如果当时有 Docker，那么构建环境就会像使用自动化搭建工具 Puppet / Chef / Salt / Ansible 一样简单，我们也可以把整个搭建时间周期从一天缩短为几分钟。但是和这些工具不同的地方在于，Docker 可以不仅仅可以搭建整个环境，还可以将整个环境保存成磁盘文件，然后复制到别的地方。需要从源码编译 Node.js 吗？Docker 做得到。Docker 不仅仅可以构建一个 Node.js 环境，还可以将整个环境做成镜像，然后保存到任何地方。当然，由于 Docker 是一个容器，所以不用担心容器内执行的东西会对宿主机产生任何的影响。</p>

<p>现在新加入我们团队的人只需要运行 <code>docker-compose up</code> 命令，便可以喝杯咖啡，然后开始工作了。</p>

<h2>Docker 可以节省开销</h2>

<p>当然，时间就是金钱。除了时间外，Docker 还可以节省在基础设施硬件上的开销。高德纳和麦肯锡的研究表明，数据中心的利用率在 6% - 12% 左右。不仅如此，如果采用虚拟机的话，你还需要被动地监控和设置每台虚拟机的 CPU 硬盘和内存的使用率，因为采用了静态分区(static partitioning)所以资源并不能完全被利用。。而容器可以解决这个问题：容器可以在实例之间进行内存和磁盘共享。你可以在同一台主机上运行多个服务、可以不用去限制容器所消耗的资源、可以去限制资源、可以在不需要的时候停止容器，也不用担心启动已经停止的程序时会带来过多的资源消耗。凌晨三点的时候只有很少的人会去访问你的网站，同时你需要比较多的资源执行夜间的批处理任务，那么可以很简单的便实现资源的交换。</p>

<p>虚拟机所消耗的内存、硬盘、CPU 都是固定的，一般动态调整都需要重启虚拟机。而用 Docker 的话，你可以进行资源限制，得益于 CGroup，可以很方便动态调整资源限制，让然也可以不进行资源限制。Docker 容器内的应用对宿主机而言只是两个隔离的应用程序，并不是两个虚拟机，所以宿主机也可以自行去分配资源。</p>

<h2>Docker 有一个健壮的镜像托管系统</h2>

<p>前面提到过，这个托管系统就叫做 Docker Hub Registry。截止到 2015年4月29日，互联网上大约有 14000 个公共的 Docker，而大部分都被托管在 Docker Hub 上面。和 Github 已经很大程度上成为开源项目的代表一样，Docker 官方的 Docker Hub 则已经是公共 Docker 镜像的代表。这些镜像可以作为你应用和数据服务的基础。<br>
也正是得益于此，你可以随意尝试最新的技术：说不定有些人就把图形化数据库的实例打包成了 Docker 镜像托管在上面。再例如 Gitlab，手工搭建 Gitlab 非常困难，译者不建议普通用户去手工搭建，而如果使用 Docker Gitlab，这个镜像则会五秒内便搭建完成。再例如特定 Ruby 版本的 Rails 应用，再例如 Linux 上的 .NET 应用，这些都可以使用简单的一条 Docker 命令搭建完成。</p>

<blockquote>
  <p>Docker 官方镜像都有 official 标签，安全性可以保证。但是第三方镜像的安全性无法保证，所以请谨慎下载第三方镜像。生产环境下可以只使用第三方提供的 Dockerfile 构建镜像。</p>
</blockquote>

<blockquote>
  <p><a rel="nofollow" href="http://www.oschina.net/p/docker-gitlab">Docker Github 介绍：5秒内搞定一个 Gitlab</a></p>
</blockquote>

<blockquote>
  <p>关于 Linux 上的 .NET 应用和 Rails 应用，Segmenfault 社区将会在以后的文章中做详细介绍。</p>
</blockquote>

<h2>Docker 可以避免产生BUG</h2>

<p>Spantree 一直是“固定基础设置”（immutable infrastructure）的狂热爱好者。换句话说，除非有心脏出血这种漏洞，我们尽量不对系统做升级，也尽量不去改变系统的设置。当添加新服务器的时候，我们也会从头构建服务器的系统，然后直接将镜像导入，将服务器放入负载均衡的集群里，然后对要退休的服务器进行健康检查，检查完毕后移除集群。得益于 Docker 镜像可以很轻松的导入导出，我们可以最大程度地减少因为环境和版本问题导致的不兼容，即便有不兼容了也可以很轻松地回滚。当然，有了 Docker，我们在生产、测试和开发中的运行环境得到统一。以前在协同开发时，会因为每个人开发的电脑配置不同而导致“在我的电脑上是能运行的，你的怎么不行”的情况，而如今 Docker 已经帮我们解决了这个问题。</p>

<h2>Docker目前只能运行在 Linux 上</h2>

<p>前面也提到过，Docker 使用的是经过长时间生产环境检验的技术，虽然这些技术已经都出现很长时间了，但是大部分技术都还是 Linux 独有的，例如 LXC 和 Cgroup。也就是说，截止到现在，Docker 容器内只能在 Linux 上运行 Linux 上的服务和应用。Microsoft 正在和 Docker 紧密合作，并且已经宣布了下一个版本的 Windows Server 将会支持 Docker 容器，并且命名为 Windows Docker，估计采用的技术应该是Hyper-V Container，我们有望在未来的几年内看到这个版本。<br>
除此之外，类似 boot2docker 和 Docker Machine 这种工具已经可以让我们在 Mac 和 Windows 下通过虚拟机运行 Docker 了。</p>

<h2>后记</h2>

<p>悄悄的说一句，前文中提到的 <a rel="nofollow" href="http://segmentfault.com/a/1190000002711327">Docker 安装</a>、<a rel="nofollow" href="http://segmentfault.com/a/1190000002711327">Docker 操作</a>、<a rel="nofollow" href="http://segmentfault.com/a/1190000002711357">Dockerfile</a>、<a rel="nofollow" href="http://segmentfault.com/a/1190000002711379">Docker Hub</a>、搭建 Rails 环境、甚至搭建 .NET 环境，SegmentFault 正在组织编写相关的文档，欢迎关注我们，及时获取更多最新的教程。</p>

2015年五月6日下午 4:27:46
改写了memwatch的代码，支持v0.11之后的nodejs
<div class="markdown-text"><p>具体位置是
<a href="https://github.com/crystaldust/node-memwatch/tree/higher-than-v10">https://github.com/crystaldust/node-memwatch/tree/higher-than-v10</a></p>
<p>npm 安装：
<code>npm install memwatch@git://github.com/crystaldust/node-memwatch.git#higher-than-v10</code></p>
<p>小弟没怎么弄过v8下的编程，所以也是一边找资料一边学习一边修改的。欢迎大家测试拍砖。附上截图：
<img src="//dn-cnode.qbox.me/Fqg4_HFLaRvAvTqyHNzx-oCUYLcz" alt="memwatch.jpg"></p>
<p><img src="//dn-cnode.qbox.me/Fl2m1daEMnrfsMEDnklbgsAVJlhL" alt="memwatch2.jpg"></p>
</div>

2015年五月6日下午 4:00:21
websocket和HTTP使用不同端口可以吗
<div class="markdown-text"><p>比如：HTTP监听端口80，websocket想分离到专门的服务器上监听端口6180
浏览器端会存在安全限制吗？</p>
</div>

2015年五月6日下午 3:53:49
要记录用户点击不同链接的次数，是每次用户点击都去插入数据库还是有什么策略？
<div class="markdown-text"><p>要记录用户点击不同链接的次数，是每次用户点击都去插入数据库还是有什么策略？</p>
</div>

2015年五月6日下午 3:48:33
惊爆！Node.js 和 io.js 准备合并
<div class="markdown-text"><p>因为对Node.js管理方Joyent公司不满，多位核心开发者自创门户建立了分支io.js，其开发非常活跃，甚至刚刚发布了 io.js 2.0.0。
而如今，不到半年时间，两个项目突然就化敌为友了。两个互相竞争的项目如今正在Node.js基金会的名义下准备合并，合并完成之后github.org/iojs项目的所有权将转移到Node.js基金会，iojs.org 和nodejs.org域名的所有权以及相关社交媒体账号也都将转移给Node.js基金会。</p>
<p>原文：<a href="http://www.solidot.org/story?sid=43951">http://www.solidot.org/story?sid=43951</a></p>
</div>

2015年五月6日下午 3:06:36
用async并发执行几个函数，同时写入一个全局的变量，是否保证有序？
<div class="markdown-text"><p>事情是这样的，产品的同事希望在一个用户列表中，按照不同的标准选取几类用户（假设有A, Bl两种用户），然后同时呈现。但是有些用户可能同时满足2个标准，比如某个用户既符合A标准，也符合B标准，这样返回的结果如果不加限定，就会出现同一个用户出现多次的情况。</p>
<p>现在我是这么考虑的，先去找A类的用户，查找结束后，把A类用户的_id传递给第二个函数，第二个函数在查找B类用户时候，把第所有A类用户的_id都剔除掉。程序结构大概是这样：</p>
<pre class="prettyprint"><code>

var exclude = [];

async.series( [
    function( callback ) {
        db.collection(&#x27;users&#x27;).find( { /*category A的条件*/} ).toArray( function( err, users ) {
            users.forEach( function( user ) {
                exclude.push( user._id );
            } );
            callback( null, users );
        } )
    },

    function( callback ) {
        db.collection(&#x27;users&#x27;).find( { /*category B的条件*/ _id : { $not : { $in : exclude } }/*限定不包含category A的用户*/ } ).toArray( function( err, users ) {
            callback( null, users );
        } )
    }

], function( err, result ) {
    var users_A = result[0];
    var users_B = result[1];
    // Handle category A and B...   
} )

</code></pre><p>为了保证不重复，需要A执行完后在执行B。顺序执行，响应时间太长。如果改成并发执行，那么每个函数去查找用户时，都要包含{$not : { $in : exclude } }条件。关键是是否会出现这样一种情况：
第一个函数先执行回调，然后向exclude写入id，还没有写完时，第二个函数执行回调了，但是exclude还是空的，那么exclude的限定在第二个函数里其实就没有作用了。</p>
<p>小弟表达能力较差，说的不清楚的地方，还请大家指出，期待各路高手给点儿意见啊，跪谢先 m( _ _ ) m</p>
</div>

2015年五月6日下午 3:04:45
哪位大神 帮忙指点 uglifyjs 怎么批量压缩
<div class="markdown-text"><p>已安装
1、node.js
2、uglifyjs</p>
</div>

2015年五月6日下午 2:37:25
求bower转spm的回答
<div class="markdown-text"><p>项目最近因为变动，计划从bower转spm。毕竟方便很多。但是项目本身bower 的很多文件在spm上没有。大神们怎么解决的？
直接复制过去，然后依次放到spmmodules的组件对应的版本目录，直接引用还是？对spm机制不太了解。特来求教。
引用的包有点多＝，＝
求解答。</p>
<blockquote>
<pre class="prettyprint"><code>&quot;angular&quot;: &quot;~1.3.11&quot;,
</code></pre></blockquote>
<pre class="prettyprint"><code>&quot;angular-animate&quot;: &quot;~1.3.11&quot;,
&quot;angular-cookies&quot;: &quot;~1.3.11&quot;,
&quot;angular-resource&quot;: &quot;~1.3.11&quot;,
&quot;angular-sanitize&quot;: &quot;~1.3.11&quot;,
&quot;angular-touch&quot;: &quot;~1.3.11&quot;,
&quot;angular-translate&quot;: &quot;~2.5.2&quot;,
&quot;angular-translate-loader-static-files&quot;: &quot;~2.5.2&quot;,
&quot;angular-translate-storage-cookie&quot;: &quot;~2.5.2&quot;,
&quot;angular-translate-storage-local&quot;: &quot;~2.5.2&quot;,
&quot;angular-bootstrap&quot;: &quot;~0.12.0&quot;,
&quot;angular-bootstrap-nav-tree&quot;: &quot;*&quot;,
&quot;angular-ui-router&quot;: &quot;~0.2.11&quot;,
&quot;angular-ui-utils&quot;: &quot;~0.2.1&quot;,
&quot;angular-file-upload&quot;: &quot;~1.1.1&quot;,
&quot;angular-ui-select&quot;: &quot;~0.8.3&quot;,
&quot;angular-ui-calendar&quot;: &quot;latest&quot;,
&quot;angular-ui-grid&quot;: &quot;~3.0.0-rc.16&quot;,
&quot;angular-xeditable&quot;: &quot;~0.1.8&quot;,
&quot;angular-smart-table&quot;: &quot;~1.4.9&quot;,
&quot;angularjs-toaster&quot;: &quot;~0.4.8&quot;,
&quot;ng-grid&quot;: &quot;~2.0.13&quot;,
&quot;ngImgCrop&quot;: &quot;~0.2.0&quot;,
&quot;ngstorage&quot;: &quot;~0.3.0&quot;,
&quot;oclazyload&quot;: &quot;~0.5.1&quot;,
&quot;textAngular&quot;: &quot;~1.2.2&quot;,
&quot;venturocket-angular-slider&quot;: &quot;~0.3.2&quot;,
&quot;videogular&quot;: &quot;~0.7.0&quot;,
&quot;videogular-controls&quot;: &quot;~0.7.0&quot;,
&quot;videogular-buffering&quot;: &quot;~0.7.0&quot;,
&quot;videogular-overlay-play&quot;: &quot;~0.7.0&quot;,
&quot;videogular-poster&quot;: &quot;~0.7.0&quot;,
&quot;videogular-ima-ads&quot;: &quot;~0.7.0&quot;,
&quot;jquery&quot;: &quot;~2.1.3&quot;,
&quot;animate.css&quot;: &quot;~3.2.0&quot;,
&quot;bootstrap&quot;: &quot;~3.3.0&quot;,
&quot;bootstrap-filestyle&quot;: &quot;~1.1.2&quot;,
&quot;bootstrap-slider&quot;: &quot;*&quot;,
&quot;bootstrap-touchspin&quot;: &quot;~3.0.1&quot;,
&quot;bootstrap-wysiwyg&quot;: &quot;*&quot;,
&quot;bower-jvectormap&quot;: &quot;~1.2.2&quot;,
&quot;bootstrap-chosen&quot;: &quot;~1.0.0&quot;,
&quot;chosen&quot;: &quot;https://github.com/harvesthq/chosen/releases/download/v1.3.0/chosen_v1.3.0.zip&quot;,
&quot;datatables&quot;: &quot;~1.10.4&quot;,
&quot;plugins&quot;: &quot;datatables/plugins#~1.0.1&quot;,
&quot;footable&quot;: &quot;~2.0.3&quot;,
&quot;font-awesome&quot;: &quot;~4.2.0&quot;,
&quot;fullcalendar&quot;: &quot;~2.2.6&quot;,
&quot;html5sortable&quot;: &quot;*&quot;,
&quot;moment&quot;: &quot;~2.8.3&quot;,
&quot;nestable&quot;: &quot;*&quot;,
&quot;screenfull&quot;: &quot;~1.2.1&quot;,
&quot;slimscroll&quot;: &quot;~1.3.3&quot;,
&quot;simple-line-icons&quot;: &quot;~0.1.1&quot;,
&quot;jquery_appear&quot;: &quot;~0.3.3&quot;,
&quot;jquery.easy-pie-chart&quot;: &quot;~2.1.6&quot;,
&quot;jquery.sparkline&quot;: &quot;~2.1.2&quot;,
&quot;flot&quot;: &quot;~0.8.3&quot;,
&quot;flot.tooltip&quot;: &quot;~0.8.4&quot;,
&quot;flot.orderbars&quot;: &quot;*&quot;,
&quot;bootstrap-daterangepicker&quot;: &quot;~1.3.17&quot;,
&quot;bootstrap-tagsinput&quot;: &quot;~0.4.2&quot;</code></pre></div>

2015年五月6日下午 1:56:44
在本地页面通过一个按钮调用系统linux命令
<div class="markdown-text"><p>在本地页面通过一个按钮调用系统linux命令，初学node不知道怎么用
一下是一段调用系统命令的node代码，单独用 node test.js 命令测试正常，现在我想加进一个本地的HTML代码中，请问怎么添加？
var exec = require(‘child_process’).exec;</p>
<p>exec(&quot;python test.py&quot;, function(error, stdout, stderr){
if ( !error ) {
console.log(stdout);
} else {
console.log(error);
}
});</p>
</div>

2015年五月6日下午 12:44:09
正则表达式笔记（三）
<h2>String.replace</h2>

<p>细心的读者可能会发现，上篇文章我们遗漏了 <code>String.replace</code> 这个方法。<code>String.replace</code> 在 JS 中有着更加强大的用法和灵活性，所以这里剥离出来单独介绍。</p>

<h3>API</h3>

<pre><code>String.replace(searchValue, replacement)
</code></pre>

<p><code>String.replace</code> 同时支持进行正则表达式或者字符串替换，并返回一个新的字符串。因为我们的主题是正则表达式，所以接下来的内容，会以正则替换的情况为主。</p>

<p>默认情况下，<code>String.replace</code>只进行一次替换。若设置了 <code>g</code> 模式，则所有匹配到的字符串都会替换</p>

<h3>参数说明</h3>

<ul>
<li>String: 需要替换的字符串</li>
<li>searchValue: 字符串或者正则表达式</li>
<li>replacement: 字符串或者函数</li>
</ul>
<h3>用法</h3>

<p><strong>字符串替换</strong></p>

<pre><code>'I am back end developer'.replace('back','front');
//"I am front end developer"
</code></pre>

<p>直接把字符串中的 <code>back</code> 替换成 <code>front</code>。当字符串中有两个 <code>back</code>，情况回事怎样呢？</p>

<pre><code>'I am back end developer, you are back end developer'.replace('back','front');
//"I am front end developer, you are back end developer"
</code></pre>

<p>可以看到，第2个 <code>back</code>，并没有被替换。如果需要把其他 <code>back</code> 也一起替换，这个时候就需要用到正则表达式。</p>

<p><strong>正则表达式替换</strong></p>

<p>设置了 <code>g</code> 模式，全局替换。</p>

<pre><code>'I am back end developer, you are back end developer'.replace(/back/g,'front');
//"I am front end developer, you are front end developer"
</code></pre>

<p>在 <code>replacement</code> 字符串中，还有一些特殊的变量可以使用。</p>

<table>
<thead><tr>
<th>特殊变量</th>
  <th>说明</th>
</tr></thead>
<tbody>
<tr>
<td>$1,$2,$3...$n</td>
  <td>表示对应捕获分组匹配的文本</td>
</tr>
<tr>
<td>$&amp;</td>
  <td>与正则相匹配的字符串</td>
</tr>
<tr>
<td>$$</td>
  <td>'$' 字符</td>
</tr>
<tr>
<td>$`</td>
  <td>匹配字符串左边的字符</td>
</tr>
<tr>
<td>$'</td>
  <td>匹配字符串右边的字符</td>
</tr>
</tbody>
</table>
<p><strong>有趣的字符串替换</strong></p>

<p>使用 <code>$&amp;</code> 操作匹配的字符串。</p>

<pre><code>var str = '有趣的字符串替换';
str.replace(/有趣的字符串/,'($&amp;)');

//"(有趣的字符串)替换"
</code></pre>

<p>使用 <code>$$</code> 声明 <code>$</code> 字符。</p>

<pre><code>var str = '这个商品的价格是12.99';
str.replace(/\d+\.\d{2}/,'$$$&amp;');

//"这个商品的价格是$12.99"
</code></pre>

<p>使用 $` 和 $' 字符替换内容</p>

<pre><code>'abc'.replace(/b/,"$`");//aac
'abc'.replace(/b/,"$'");//acc
</code></pre>

<p>使用分组匹配组合新的字符串</p>

<pre><code>'2015-05-06'.replace(/(\d{4})-(\d{2})-(\d{2})/,"$3/$2/$1")
//"06/05/2015"
</code></pre>

<h3>函数参数</h3>

<p>当<code>replacement</code>是一个函数参数的时候，对字符串操作的灵活性将有一个质的提高。</p>

<p><strong>说明</strong></p>

<pre><code>'Stirng.replace'.replace(/(\w+)(\.)(\w+)/,function(){
    console.log(arguments) // ["Stirng.replace", "Stirng", ".", "replace", 0, "Stirng.replace"]
    return '返回值会替换掉匹配到的字符'
})
</code></pre>

<table>
<thead><tr>
<th>参数</th>
  <th>说明</th>
</tr></thead>
<tbody>
<tr>
<td>match</td>
  <td>匹配到的字符串（此例为 String.replace）</td>
</tr>
<tr>
<td>p1, p2, ...</td>
  <td>正则使用了分组匹配时分组文本，否则无此参数（此例为 "Stirng", ".", "replace"）</td>
</tr>
<tr>
<td>offset</td>
  <td>匹配字符串的对应索引位置 （此例为 0）</td>
</tr>
<tr>
<td>source</td>
  <td>原始字符串（此例为 String.replace）</td>
</tr>
</tbody>
</table>
<p><strong>案例 -- 样式属性的转换</strong></p>

<p>把驼峰字符转换为 <code>-</code> 连接符形式</p>

<pre><code>'borderTop'.replace(/[A-Z]/g,function(m){
    return '-'+ m.toLowerCase()
})

//"border-top"
</code></pre>

<p>把 <code>-</code> 连接符形式转换为驼峰形式</p>

<pre><code>'border-top'.replace(/-\w/g,function(m){
    return m.slice(1).toUpperCase()
})

//"borderTop"
</code></pre>

<h3>最后的牛刀小试</h3>

<p>交给阅读者发挥的内容：</p>

<p>需要将<code>Hello-World</code>使用正则替换成 <code>HWeolrllod</code></p>

2015年五月6日下午 12:34:48
alsotang pushed to online at cnodejs/nodeclub
<!-- push -->
<span class="mega-octicon octicon-git-commit"></span>

<div class="time">
  <time datetime="2015-05-06T04:34:48Z" is="relative-time">May 6, 2015</time>
</div>

<div class="title">
  <a href="https://github.com/alsotang" data-ga-click="News feed, event click, Event click type:PushEvent target:actor">alsotang</a> <span>pushed</span> to <a href="/cnodejs/nodeclub/tree/online" data-ga-click="News feed, event click, Event click type:PushEvent target:branch">online</a> at <a href="https://github.com/cnodejs/nodeclub" data-ga-click="News feed, event click, Event click type:PushEvent target:repo">cnodejs/nodeclub</a>
</div>

<div class="details">
  <a href="https://github.com/alsotang"><img alt="@alsotang" class="gravatar" data-user="1147375" height="30" src="https://avatars0.githubusercontent.com/u/1147375?v=3&amp;s=60" width="30" /></a>

    <div class="commits pusher-is-only-committer">
      <ul>
        <li>
          <span title="alsotang">
            <img alt="@alsotang" data-user="1147375" height="16" src="https://avatars1.githubusercontent.com/u/1147375?v=3&amp;s=32" width="16" />
          </span>
          <code><a href="/cnodejs/nodeclub/commit/5c32926e7e056355b8f64e275ee5c90402f6d6f0" data-ga-click="News feed, event click, Event click type:PushEvent target:sha">5c32926</a></code>
          <div class="message">
            <blockquote>
              coding.net
            </blockquote>
          </div>
        </li>
        <li>
          <span title="alsotang">
            <img alt="@alsotang" data-user="1147375" height="16" src="https://avatars1.githubusercontent.com/u/1147375?v=3&amp;s=32" width="16" />
          </span>
          <code><a href="/cnodejs/nodeclub/commit/432b8a4932f5b43c4dc89e18a448365e00772d61" data-ga-click="News feed, event click, Event click type:PushEvent target:sha">432b8a4</a></code>
          <div class="message">
            <blockquote>
              qiniu
            </blockquote>
          </div>
        </li>
        <li class="more"><a href="https://github.com/cnodejs/nodeclub/compare/a49c47998c...5c32926e7e" data-ga-click="News feed, event click, Event click type:PushEvent target:comparison">3 more commits &raquo;</a></li>
      </ul>
    </div>
</div>

2015年五月6日下午 12:33:48
alsotang pushed to online at cnodejs/nodeclub
<!-- push -->
<span class="mega-octicon octicon-git-commit"></span>

<div class="time">
  <time datetime="2015-05-06T04:33:48Z" is="relative-time">May 6, 2015</time>
</div>

<div class="title">
  <a href="https://github.com/alsotang" data-ga-click="News feed, event click, Event click type:PushEvent target:actor">alsotang</a> <span>pushed</span> to <a href="/cnodejs/nodeclub/tree/online" data-ga-click="News feed, event click, Event click type:PushEvent target:branch">online</a> at <a href="https://github.com/cnodejs/nodeclub" data-ga-click="News feed, event click, Event click type:PushEvent target:repo">cnodejs/nodeclub</a>
</div>

<div class="details">
  <a href="https://github.com/alsotang"><img alt="@alsotang" class="gravatar" data-user="1147375" height="30" src="https://avatars0.githubusercontent.com/u/1147375?v=3&amp;s=60" width="30" /></a>

    <div class="commits pusher-is-only-committer">
      <ul>
        <li>
          <span title="alsotang">
            <img alt="@alsotang" data-user="1147375" height="16" src="https://avatars1.githubusercontent.com/u/1147375?v=3&amp;s=32" width="16" />
          </span>
          <code><a href="/cnodejs/nodeclub/commit/a49c47998c0320496b2d94dcd5196a074632ffcd" data-ga-click="News feed, event click, Event click type:PushEvent target:sha">a49c479</a></code>
          <div class="message">
            <blockquote>
              coding.net
            </blockquote>
          </div>
        </li>
      </ul>
    </div>
</div>

2015年五月6日中午 12:08:31
推荐一款可以在iPhone和iPad上读nodejs官方文档的app
<div class="markdown-text"><h5>专门为nodejs doc开发的，比dash的阅读体验更好，比如代码的高亮，链接的处理等。目前只支持iOS8</h5>
<h5>下载地址</h5>
<p><a href="https://itunes.apple.com/cn/app/nodejs-api/id983630798?mt=8"> https://itunes.apple.com/cn/app/nodejs-api/id983630798?mt=8</a></p>
<p><img src="//dn-cnode.qbox.me/FjCqMwBHB79PK_bX8AFqj4swCQPs" alt="下载.png"></p>
<h5>页面截图</h5>
<p><img src="//dn-cnode.qbox.me/FmwAOi6THu3Vr-fljNJw_cwcWcCl" alt="首页"></p>
<p><img src="//dn-cnode.qbox.me/Fok6aNeGE4P5qK0_uZaygYyBIGWU" alt="api 详情"></p>
<p><img src="//dn-cnode.qbox.me/FsCKI2Bx3m27ElhmlYQ5JL_Ot6yt" alt="分类"></p>
</div>

2015年五月6日中午 11:58:58
[产品更新] SegmentFault 全新文章专栏上线
<p>经过半个多月的努力，全新的 SegmentFault 文章终于和大家见面了。这次的全新改版，我们提出了文章专栏的理念：</p>

<ol>
<li>所有用户都可以拥有自己的专栏</li>
<li>将更加注重和鼓励原创且具有启发性的用户内容</li>
<li>对相关的声望值做出调整<br><br>
</li>
</ol>
<h2>关于原创和启发性</h2>

<blockquote>
  <p><strong>原创的文章是自己学习和探索的结果，独立的思考会给他人更大的启发，会引导他人去发现、实现可能更加有趣的事。</strong></p>
</blockquote>

<p>故此，我们将更加注重和鼓励原创：</p>

<p>新版文章将在<a rel="nofollow" href="http://segmentfault.com/user/settings?tab=blog">专栏设置页</a>增加版权信息注明，原创文章将不再受版权问题的困扰。同时，专栏的首篇文章也将会被官方审阅，这也是对于原创优秀内容的鼓励。</p>

<p><img src="/img/bVlCQq" alt="版权信息设置.jpg"></p>

<h2>私人的，也是所有人的专栏</h2>

<p>新版文章所有用户都将可以开始撰写自己的专栏：已经开通过博客的老用户，博客将自动升级为的专栏；还没有开通博客的用户，现在可以直接<a rel="nofollow" href="http://segmentfault.com/blog/add">开通专栏</a>了。</p>

<p>我们后续会推出官方认证专栏，如果你的文章写得足够好，会出现在网站所有用户的时间线上，这便是私人的、也是所有人的专栏。</p>

<h2>相关声望值调整</h2>

<p>新版文章的声望值权重也会相应作出上调：文章被投推荐票 +10，文章被收藏 +5。另外，如果你的文章被推作官方推荐文章或者精选文章，都会有相应的声望值增加，当然，推荐与加精更多是对你内容价值的认可。</p>

<p><br><br>
其他更多的细节与优化，由你们来发现。</p>

<p>这是一个简易的技术专栏，是学习与分享知识的工具。这将是你的私人文章，请认真地撰写；这也将会是所有人的文章，热心地与大家切磋共享。</p>

<hr>
<blockquote>
  <p>相关的产品建议和反馈提交请到我们的社区建设：<a rel="nofollow" href="http://segmentfault.com/0x">0x.sf.gg</a><br>
  相关的技术 bug 提交请到我们的 GitHub Report：<a rel="nofollow" href="https://github.com/SegmentFault/report">SegmentFault Report</a></p>
</blockquote>

2015年五月6日中午 11:51:44
Cnode社区回复操作是否为bug?
<div class="markdown-text"><p>我在一个话题下添加回复完毕后，想跳回上一页页面，第一次点击浏览器的回退的按钮，却回不到上一页面，第二次点击就可以，是故意这样设计的还是？我是小白，请大神指点</p>
</div>

2015年五月6日中午 11:44:28
寻求一种方式重启node的方式
<div class="markdown-text"><p>虽然说生产环境老是重启不是很安全，但每次更新版本时都需要找PE来重启node，感觉好麻烦，有没有类似LAMP那种方式，比如我修改完php代码上线后能立即运行，nodemon启动方式不算。求大神们指点迷津。</p>
</div>

2015年五月6日中午 11:41:58
alsotang commented on commit cnodejs/nodeclub@0f6cc14f6b
<!-- commit_comment -->
<span class="mega-octicon octicon-comment-discussion"></span>

<div class="time">
  <time datetime="2015-05-06T03:41:58Z" is="relative-time">May 6, 2015</time>
</div>

<div class="title">
  <a href="https://github.com/alsotang" data-ga-click="News feed, event click, Event click type:CommitCommentEvent target:actor">alsotang</a> <span>commented</span> on commit <a href="https://github.com/cnodejs/nodeclub/commit/0f6cc14f6bcbbe6b4de3199c6896efaec637693e#commitcomment-11058600" data-ga-click="News feed, event click, Event click type:CommitCommentEvent target:commit-comment">cnodejs/nodeclub@0f6cc14f6b</a>
</div>

<div class="details">
  <a href="https://github.com/alsotang"><img alt="@alsotang" class="gravatar" data-user="1147375" height="30" src="https://avatars0.githubusercontent.com/u/1147375?v=3&amp;s=60" width="30" /></a>
  <div class="message markdown-body">
    <blockquote>
      <p>是的 2015-05-06 11:37 GMT+08:00 Jackson Tian &lt;notifications@github.com&gt;:
</p>
    </blockquote>
  </div>
</div>

2015年五月6日上午 11:01:32
[北京] NodeJS 前端后端开发攻城狮1名 8K-16K
<div class="markdown-text"><p>【关于我们】
公司成立于14年底，核心团队成员来自IBM，联想，百度，并具有10年以上的丰富经验。现从事校园生活相关的移动互联网项目，因团队高速发展需要，急招有志于用技术改变生活的nodejs 前后端攻城狮1名</p>
<p>【任职要求】
Requirements</p>
<pre class="prettyprint"><code>* Strong Javascript skills
* Knowledge of Node.js packages (Express, Async, Mongoose, Socket.io, Request, etc.)
* Experience with message and job queuing services (RabbitMQ, Redis, etc.)
* Very strong ability to design and develop scalable systems on top of Node.js
* Experience working with MongoDB, Mysql and Redis.
* Disciplined approach to testing and quality assurance, knowledge of Javascript testing tools.
* High understanding of computer science concepts such as: common data structures and algorithms, profiling/optimization
</code></pre><p>Responsibilities</p>
<pre class="prettyprint"><code>* Build and deploy robust, manageable and scalable back ends
* Integrate 3rd party services via RESTful and streaming APIs
* Design and implement RESTful interfaces that exposes our data
* Rapidly fix bugs and solve problems
* Work closely with front-end teams to create optimally integrated solutions
* Plus Point:  have experience ionic framework and wechat JS SDK
</code></pre><p>【关于职位】
NodeJS 前端&amp;后端开发工程师
工作地点：北京.海淀.上地
工作年限：3年以上
最低学历：本科
招聘人数：1
职位月薪：￥8 ,000 - 16,000
英语：读写流利，英语六级</p>
<p>【联系我们】
有意者请将您的简历直接直接发送至<a href="mailto:hr@guagua2shou.com">hr@guagua2shou.com</a>,我们会尽快回复您，谢谢！</p>
</div>

2015年五月6日上午 9:52:37
nodejs对http协议的支持
<div class="markdown-text"><p>http协议的method
安全方法：HEAD, GET, OPTIONS, and TRACE
不安全的方法：POST, PUT and DELETE
测试了一下发现其中的Trace方法返回error；
想问下各位大神。这个trace方法会返回什么。怎么开启看看。</p>
</div>

2015年五月6日上午 9:36:35
在阿里云使用npm安装pm2一直加载
<div class="markdown-text"><p><img src="//dn-cnode.qbox.me/Fj-iY-OzGKTizIW6cs_OSXdSr3J0" alt="untitled1.png"></p>
</div>

2015年五月6日早上 8:37:59
io.js前天发布了2.0.0版本
<div class="markdown-text"><p><a href="https://iojs.org/cn/releases.html">io.js v2.0.0</a>
<a href="https://github.com/iojs/io.js/blob/v2.0.0/CHANGELOG.md">changelog</a>
大版本变化。
更稳定了么？</p>
</div>

2015年五月6日早上 7:10:15
[成都]GamEver招2名手游服务器端Nodejs工程师7~15k
<div class="markdown-text"><p><strong>关于我们（热血，专注，快乐，成长，勇敢，创造力）</strong></p>
<p>我们是一群对游戏非常热爱，专注于制作精品的单纯家伙
多年的打磨学会了在商业和艺术之间寻找平衡
平均从业经验5年以上, 聚焦海外市场
行业顶尖美术和金牌制作人，资深欧美制作经验
产品专注三个核心：Creative, Passionate, Imapctive</p>
<p>公司成立于2014年1月，规模25人，现在已有一款上市产品Age of warriors,(中国区暂时还没上线）<strong>获得了美国区苹果APPSTORE三次全球首页推荐。</strong></p>
<p>我们期待的伙伴:
<strong>3d客户端程序：</strong></p>
<p>至少熟悉一种3d游戏引擎。
熟悉openGL图形管线，能独立学习制作游戏需要的shader效果
有扎实的c++编码功底
爱好技术，踏实好学，对游戏有爱</p>
<p><strong>服务器程序：</strong></p>
<p><strong>踏实靠谱，热爱游戏
不需要您一定要是技术大牛，只要你基础扎实愿意接受新技术，快速学习
1~2年编码经验，熟悉nodejs，mongodb，或者python，ruby，mysql，erlang
团队协作精神，自我管理良好，有工程师文化基因。
善于沟通，有同理心</strong></p>
<p><strong>系统/数值/UI策划:</strong></p>
<p>踏实靠谱，心态开放成熟，渴望做出富有灵魂的作品
有激情,有动力,平时热衷于各种平台的游戏
游戏经验丰富,了解各类游戏的特色与设计思路
熟悉玩家的消费行为以及游戏行为，喜欢和玩家一起交流
良好的语言沟通和书面表达能力(熟悉策划案撰写,意图表达明确,条理清晰)
严密谨慎的逻辑能力，对RPG以及SLG类游戏数值平衡有独特兴趣和偏好
或者擅长UI设计,熟悉至少一种动画关卡编辑器
有较好的英文阅读和书面日常交流能力</p>
<p><strong>游戏文案策划：</strong></p>
<p>沟通能力好，主动性责任心强。
有激情,有动力,平时热衷于各种平台的游戏。
拥有游戏经验丰富,了解各类游戏的特色与设计思路 。
熟悉玩家的群体，喜欢和玩家一起交流。
良好的语言沟通和书面表达能力(能熟练撰写有想象力的文案剧情和幽默的人物对白)。
喜欢看美剧，看小说，熟悉玩家语言。</p>
<p>具有较好的英文阅读写作能力。</p>
<p><strong>游戏UI设计美术：</strong></p>
<p>有丰富的UI设计经验，
热爱游戏，对各种题材的UI又自己独到见解
3年以上工作经验为佳。</p>
<p><strong>FlashUI美术：</strong></p>
<p>熟悉flash，懂基本as2.0
熟悉各种动画制作和特效制作。
有1到2年flash制作经验
如果有个人业余小游戏作品，那是极好的。</p>
<p><strong>我们将提供给您:</strong>
7~15k左右的基本薪资待遇(具体和能力挂钩)
每年最高4次项目奖金，年底双薪
节假日过节奖金，项目完成后的集体旅行
灵活可变的弹性上班时间，宽松自由的团队氛围
一群靠谱的伙伴，快乐生活，做好游戏
低层级公司，没有不做事混日子的伙伴。
每一个产品都会是精品设计，绝对不会开发浪费大家光阴的项目。
好的技术学习讨论氛围
macpro笔记本开发</p>
<p>如果您也对制作游戏充满热忱，渴望能有一群靠谱的伙伴一起快乐工作，一起旅行，一起开创未来！请联系<a href="mailto:xiao.wen@gamever.org">xiao.wen@gamever.org</a>
<img src="//dn-cnode.qbox.me/FmTwEfps_1aOlnLVhAb5PVfaEPq9" alt="screen696x696.jpeg"></p>
</div>

2015年五月6日早上 6:51:43
关于Express中使用req.pipe(busboy)的用途是什么？是多文件上传吗？
<div class="markdown-text"><p>大家好：</p>
<p>我在看源码时，发现req.pipe方法，但在google上没有找到解释其具体是什么含义？（我猜是不是，多文件上传的意思？）
express API上也没有找到。</p>
<p>坛子里的先闻道者，麻烦帮忙下，谢谢。</p>
<p>code:
exports.upload = function (req, res, next) {
req.busboy.on('file’, function (fieldname, file, filename, encoding, mimetype) {
store.upload(file, {filename: filename}, function (err, result) {
if (err) {
return next(err);
}
res.json({
success: true,
url: result.url,
});
});
});</p>
<p>req.pipe(req.busboy);
};</p>
</div>

2015年五月6日凌晨 12:50:57
异步流程控制：7 行代码学会 co 模块
<p>首先请原谅我的标题党(●—●)，tj 大神的 co 模块源码200多行，显然不是我等屌丝能随便几行代码就能重写的。只是当今大家都喜欢《7天学会xx语言》之类的速效仙丹，于是我也弄个类似的名字《7行代码学会co模块》来博眼球。</p>

<p>为了避免被拖出去弹小JJ，还是先放出所谓的 7 行代码给大家压压惊：</p>

<pre><code>function co(gen) {
    var it = gen();
    var ret = it.next();
    ret.value.then(function(res) {
        it.next(res);
    });
} 
</code></pre>

<h2>万恶的回调</h2>

<p>对前端工程师来说，异步回调是再熟悉不过了，浏览器中的各种交互逻辑都是通过事件回调实现的，前端逻辑越来越复杂，导致回调函数越来越多，同时 nodejs 的流行也让 javascript 在后端的复杂场景中得到应用，在 nodejs 代码中更是经常看到层层嵌套。</p>

<p>以下是一个典型的异步场景：先通过异步请求获取页面数据，然后根据页面数据请求用户信息，最后根据用户信息请求用户的产品列表。过多的回调函数嵌套，使得程序难以维护，发展成<a rel="nofollow" href="http://callbackhell.com/">万恶的回调</a>。</p>

<pre><code>javascript</code><code>$.get('/api/data', function(data) {
    console.log(data);
    $.get('/api/user', function(user) {
        console.log(user);
        $.get('/api/products', function(products) {
            console.log(products)
        });
    });
});
</code></pre>

<h2>异步流程控制</h2>

<ul>
<li><p>最原始异步流程的写法，就是类似上面例子里的回调函数嵌套法，用过的人都知道，那叫一个酸爽。</p></li>
<li><p>后来出现了 Promise ，它极大提高了代码的可维护性，消除了万恶的回调嵌套问题，并且现在已经成为 ES6 标准的一部分。</p></li>
</ul>
<pre><code>$.get('/api/data')
.then(function(data) {
    console.log(data);
    return $.get('/api/user');
})
.then(function(user) {
    console.log(user);
    return $.get('/api/products');
})
.then(function(products) {
    console.log(products);
});
</code></pre>

<ul>
<li>之后在 nodejs 圈出现了 co 模块，它基于 ES6 的 generator 和 yield ，让我们能用同步的形式编写异步代码。</li>
</ul>
<pre><code>co(function *() {
    var data = yield $.get('/api/data');
    console.log(data);
    var user = yield $.get('/api/user');
    console.log(user);
    var products = yield $.get('/api/products');
    console.log(products);
});
</code></pre>

<ul>
<li>以上的 Promise 和 generator 最初创造它的本意都不是为了解决异步流程控制。其中 Promise 是一种编程思想，用于“当xx数据准备完毕，then执行xx动作”这样的场景，不只是异步，同步代码也可以用 Promise。而 generator 在 ES6 中是迭代器生成器，被 TJ 创造性的拿来做异步流程控制了。真正的异步解决方案请大家期待 ES7 的 async 吧！本文以下主要介绍 co 模块。</li>
</ul>
<h2>co 模块</h2>

<p>上文已经简单介绍了co 模块是能让我们以同步的形式编写异步代码的 nodejs 模块，主要得益于 ES6 的 generator。nodejs &gt;= 0.11 版本可以加 <code>--harmony</code> 参数来体验 ES6 的 generator 特性，iojs 则已经默认开启了 generator 的支持。</p>

<p>要了解 co ，就不得不先简单了解下 ES6 的 generator 和 iterator。</p>

<h3>Iterator</h3>

<p>Iterator 迭代器是一个对象，知道如何从一个集合一次取出一项，而跟踪它的当前序列所在的位置，它提供了一个next()方法返回序列中的下一个项目。</p>

<pre><code>javascript</code><code>var lang = { name: 'JavaScript', birthYear: 1995 };
var it = Iterator(lang);
var pair = it.next(); 
console.log(pair); // ["name", "JavaScript"]
pair = it.next(); 
console.log(pair); // ["birthYear", 1995]
pair = it.next(); // A StopIteration exception is thrown
</code></pre>

<p>乍一看好像没什么奇特的，不就是一步步的取对象中的 key 和 value 吗，<code>for ... in</code>也能做到，但是把它跟 generator 结合起来就大有用途了。</p>

<h3>Generator</h3>

<p>Generator 生成器允许你通过写一个可以保存自己状态的的简单函数来定义一个迭代算法。<br>
Generator 是一种可以停止并在之后重新进入的函数。生成器的环境（绑定的变量）会在每次执行后被保存，下次进入时可继续使用。generator 字面上是“生成器”的意思，在 ES6 里是迭代器生成器，用于生成一个迭代器对象。</p>

<pre><code>function *gen() {
    yield 'hello';
    yield 'world';
    return true;
}
</code></pre>

<p>以上代码定义了一个简单的 generator，看起来就像一个普通的函数，区别是<code>function</code>关键字后面有个<code>*</code>号，函数体内可以使用<code>yield</code>语句进行流程控制。</p>

<pre><code>javascript</code><code>var iter = gen();
var a = iter.next();
console.log(a); // {value:'hello', done:false}
var b = iter.next();
console.log(b); // {value:'world', done:false}
var c = iter.next();
console.log(c); // {value:true, done:true}
</code></pre>

<p>当执行<code>gen()</code>的时候，并不执行 generator 函数体，而是返回一个迭代器。迭代器具有<code>next()</code>方法，每次调用 next() 方法，函数就执行到<code>yield</code>语句的地方。next() 方法返回一个对象，其中value属性表示 yield 关键词后面表达式的值，done 属性表示是否遍历结束。generator 生成器通过<code>next</code>和<code>yield</code>的配合实现流程控制，上面的代码执行了三次 next() ，generator 函数体才执行完毕。</p>

<h3>co 模块思路</h3>

<p>从上面的例子可以看出，generator 函数体可以停在 yield 语句处，直到下一次执行 next()。co 模块的思路就是利用 generator 的这个特性，将异步操作跟在 yield 后面，当异步操作完成并返回结果后，再触发下一次 next() 。当然，跟在 yield 后面的异步操作需要遵循一定的规范 thunks 和 promises。</p>

<blockquote>
  <h4>yieldables</h4>
  
  <p>The yieldable objects currently supported are:<br>
  - promises<br>
  - thunks (functions)<br>
  - array (parallel execution)<br>
  - objects (parallel execution)<br>
  - generators (delegation)<br>
  - generator functions (delegation)</p>
</blockquote>

<h2>7行代码</h2>

<p>再看看文章开头的7行代码：</p>

<pre><code>javascript</code><code>function co(gen) {
    var it = gen();
    var ret = it.next();
    ret.value.then(function(res) {
        it.next(res);
    });
}
</code></pre>

<p>首先生成一个迭代器，然后执行一遍 next()，得到的 value 是一个 Promise 对象，Promise.then() 里面再执行 next()。当然这只是一个原理性的演示，很多错误处理和循环调用 next() 的逻辑都没有写出来。</p>

<p>下面做个简单对比：<br>
传统方式，<code>sayhello</code>是一个异步函数，执行<code>helloworld</code>会先输出<code>"world"</code>再输出<code>"hello"</code>。</p>

<pre><code>function sayhello() {
    return Promise.resolve('hello').then(function(hello) {
        console.log(hello);
    });
}
function helloworld() {
    sayhello();
    console.log('world');
}
helloworld();
</code></pre>

<p>输出</p>

<pre><code>&gt; "world"
&gt; "hello"
</code></pre>

<p>co 的方式，会先输出<code>"hello"</code>再输出<code>"world"</code>。</p>

<pre><code>javascript</code><code>function co(gen) {
    var it = gen();
    var ret = it.next();
    ret.value.then(function(res) {
        it.next(res);
    });
}
function sayhello() {
    return Promise.resolve('hello').then(function(hello) {
        console.log(hello);
    });
}
co(function *helloworld() {
    yield sayhello();
    console.log('world');
});
</code></pre>

<p>输出</p>

<pre><code>javascript</code><code>&gt; "hello"
&gt; "world"
</code></pre>

<h2>消除回调金字塔</h2>

<p>假设<code>sayhello</code>/<code>sayworld</code>/<code>saybye</code>是三个异步函数，用真正的 co 模块就可以这么写：</p>

<pre><code>var co = require('co');
co(function *() {
    yield sayhello();
    yield sayworld();
    yield saybye();
});
</code></pre>

<p>输出</p>

<pre><code>javascript</code><code>&gt; "hello"
&gt; "world"
&gt; "bye"
</code></pre>

<h2>参考</h2>

<p>《es7-async》 <a rel="nofollow" href="https://github.com/jaydson/es7-async">https://github.com/jaydson/es7-async</a><br>
《Generator 函数的含义与用法》 <a rel="nofollow" href="http://www.ruanyifeng.com/blog/2015/04/generator.html">http://www.ruanyifeng.com/blog/2015/04/generator.html</a><br>
《Iterator》 <a rel="nofollow" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Iterator">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Glob...</a></p>

2015年五月6日凌晨 12:30:43
关于express中app.post的一个问题
<div class="markdown-text"><p>var express = require(‘express’);
var app = express();
app.listen(3000);
var bodyParser = require(‘body-parser’)
var hbs = require(‘hbs’);
var spawn = require(‘child_process’).spawn;</p>
<p>app.set('view engine’, ‘html’);
app.engine('html’, hbs.__express);
app.use(express.static(‘public’));
app.use(bodyParser.urlencoded({ extended: false }));</p>
<p>ls = spawn(‘某程序’);</p>
<p>app.post('/’, function(req, res) {
var info = req.body;//请求前端得到表单的值
ls.stdin.write(“calculate(“+info.xxx+”)&quot;+ “\n”);//子线程调用程序完成一些计算
ls.stdout.on('data’, function(data) {
//做一些数据的处理
res.render('…’,{data:…});//然后反馈呈现到前端页面上
});
});
这样做的话提交一次表单运行正常，第二次就会报错说Can’t set headers after they are sent，
查了之后说是回调有问题，后来把res.render去掉，console一些需要的结果，发现第一次提交表单运算后输出一次，当第二次提交表单的时候输出两次，第三次提交输出三次。。。</p>
<p>下面是把ls.stdout.on拿到post外面，这样做的话提交一次表单运算后输出一次，不会出现上面重复的问题，但是这里就不能用res.render()去把结果呈现在前端上了，因为在post外面，做不了res的反馈。。。
app.post('/’, function(req, res) {
var info = req.body;
ls.stdin.write(&quot;calculate(info.xxx+ “\n”);//子线程调用程序完成一些计算
});
ls.stdout.on('data’, function(data) {
//处理计算得到后的数据。console.log一些需要的结果，方便在终端查看结果
});</p>
<p>请教懂的小伙伴们，怎么做能一举两得呐？我是小白一枚。。。</p>
</div>

2015年五月6日凌晨 12:05:52
小白请教一个简单的session问题
<div class="markdown-text"><p>前端提交数据表单给nodejs，调用一个计算软件计算得到结果后反馈到前端页面上，在localhost:3000上能实现这个过程了，这是单用户情况。
现在要加多用户进去，用session模块，怎么设置能将调试的这台电脑作为服务器，然后让其他电脑访问完成提交数据运行计算软件得到结果的这个功能。</p>
</div>

2015年五月5日晚上 11:46:21
[MySQL]查询学生选课的情况（一）
<p>这是我工作遇到的问题，现在自己设计一个简化的类似场景，现实中这样的数据表设计可能有很多不合理的地方。<br>
首先看表结构：</p>

<pre><code>+--------+--------------+------+-----+---------+-------+
| Field  | Type         | Null | Key | Default | Extra |
+--------+--------------+------+-----+---------+-------+
| id     | varchar(38)  | NO   | PRI | NULL    |       |
| name   | varchar(255) | YES  |     | NULL    |       |
| course | varchar(300) | YES  |     | NULL    |       |
+--------+--------------+------+-----+---------+-------+
</code></pre>

<p>这里只是记录学生的ID，名字，还有选课的科目，科目有很多，在没有关联表的情况下，这么多科目只保存在一个字段中，用逗号隔开。<br>
再看一些数据：</p>

<pre><code>+--------------------------------------+--------+--------------------------------+
| id                                   | name   | course                         |
+--------------------------------------+--------+--------------------------------+
| 32268995-f33d-11e4-a31d-089e0140e076 | 张三   | Math,English,Chinese           |
| 3d670ef2-f33d-11e4-a31d-089e0140e076 | 李四   | Math,English,Chinese,Algorithm |
| 475d51a6-f33d-11e4-a31d-089e0140e076 | 李五   | Math,English,Algorithm         |
| 547fdea0-f33d-11e4-a31d-089e0140e076 | 王小明 | Math,English,Japanese          |
| 656a247a-f33d-11e4-a31d-089e0140e076 | 曹达华 | Chesses                        |
+--------------------------------------+--------+--------------------------------+
</code></pre>

<p><strong>那么如何查找到选择了<code>Math</code>课程的学生？</strong></p>

<p>想想使用关联表的时候，<code>张三</code>, <code>李四</code>, <code>李五</code>, <code>王小明</code>这四个人都一条选择了<code>Math</code>这门课的记录，还有其他不是<code>Math</code>的记录。此时要查找选择了<code>Math</code>课程的学生，一般使用<code>IN</code>语句就可以了：</p>

<pre><code>select * from student_course where course IN ('Math');
</code></pre>

<p>如果要查找选择了<code>Math</code>或<code>Algorithm</code>课程的学生呢：</p>

<pre><code>select * from student_course where course IN ('Math', 'Algorithm');
</code></pre>

<p>如此，回到原来的问题，如果我设计一个类似<code>IN</code>一样的函数，那么就可以解决这个问题了。<br>
这个流程我们可以想象出来，是这样子的：<br>
我们取<code>张三</code>的课程信息<code>Math,English,Chinese</code>，首先切割成<code>Math</code>, <code>English</code>,<code>Chinese</code>三个字段，然后分别与与查找条件做比较，类似<code>'Math'.indexOf('Math');</code>,<code>'Math'.indexOf('English');</code>...<br>
只要找到一个就认为符合查找条件。<br>
同样的，如果要查找选择了<code>Math</code>或<code>Algorithm</code>课程的学生，比较过程就变成了：<br><code>'Math,Algorithm'.indexOf('Math');</code>,<code>'Math,Algorithm'.indexOf('English');</code>...</p>

<h3>切割函数 getSplitTotalLength, getSplitString</h3>

<pre><code>CREATE DEFINER = `root`@`%` FUNCTION `getSplitTotalLength`(`f_string` varchar(500),`f_delimiter` varchar(5))
 RETURNS int(11)
BEGIN
    # 计算传入字符串能切分成多少段 
   return 1+(length(f_string) - length(replace(f_string,f_delimiter,''))); 

    RETURN 0;
END;
</code></pre>

<pre><code>CREATE DEFINER = `root`@`%` FUNCTION `getSplitString`(`f_string` varchar(500),`f_delimiter` varchar(5),`f_order` int)
 RETURNS varchar(500)
BEGIN
    #拆分传入的字符串，分隔符，顺序，返回拆分所得的新字符串
    declare result varchar(500) default '';
    set result = reverse(substring_index(reverse(substring_index(f_string,f_delimiter,f_order)),f_delimiter,1));
    RETURN result;
END;
</code></pre>

<h3>类似IN的那个函数 isInSearch</h3>

<pre><code>CREATE DEFINER=`root`@`%` FUNCTION `isInSearch`(f_course VARCHAR(300), f_string VARCHAR(300)) RETURNS INT
BEGIN

    DECLARE len INT DEFAULT 0;
    DECLARE idx INT DEFAULT 0;
    DECLARE item_code VARCHAR(300) DEFAULT '';
    DECLARE item_index INT DEFAULT 0;
    IF f_course IS NULL THEN
        RETURN 0;
    END IF;
    SELECT getSplitTotalLength(f_course, ',') INTO len;
    label: LOOP
        SET idx = idx + 1;
        IF idx &gt; len THEN
            LEAVE label;
        END IF;
        SELECT getSplitString(f_course , ',', idx) INTO item_code;
        # f_string.indexOf(item_code) &gt; -1 ?
        SELECT LOCATE(item_code, f_string) INTO item_index;
        IF item_index &gt; 0 THEN
            RETURN 1; # got one
        END IF;
    END LOOP label;
    RETURN 0;
    END;
</code></pre>

<p>这里说下<code>locate</code>函数，<code>locate(item_code, f_string)</code>，如果<code>item_code</code>是<code>f_string</code>的子串，返回的结果大于<code>0</code>，是<code>item_code</code>在<code>f_string</code>的起始下标（从1开始算起），这个一般的<code>indexOf</code>函数有些不同。</p>

<pre><code>mysql&gt; select locate('Math','Math,Algorithm');
+---------------------------------+
| locate('Math','Math,Algorithm') |
+---------------------------------+
|                               1 |
+---------------------------------+
mysql&gt; select locate('Math','Chinese,Math,Algorithm');
+-----------------------------------------+
| locate('Math','Chinese,Math,Algorithm') |
+-----------------------------------------+
|                                       9 |
+-----------------------------------------+
mysql&gt; select locate('Math','Chinese,Algorithm');
+------------------------------------+
| locate('Math','Chinese,Algorithm') |
+------------------------------------+
|                                  0 |
+------------------------------------+
</code></pre>

<p>可以看到<code>isInSearch</code>函数返回的是<code>INT</code>类似，因为<code>MySQL</code>的<code>IN</code>也是这样的机制。</p>

<pre><code>mysql&gt; select 'Math' in ('Math','Algorightm');
+---------------------------------+
| 'Math' in ('Math','Algorightm') |
+---------------------------------+
|                               1 |
+---------------------------------+
mysql&gt; select 'Math' in ('Chinese','Algorightm');
+------------------------------------+
| 'Math' in ('Chinese','Algorightm') |
+------------------------------------+
|                                  0 |
+------------------------------------+
</code></pre>

<p>如果存在返回1，不存在返回0。</p>

<h3>在SELECT语句中使用自定义的函数</h3>

<pre><code>mysql&gt; select * from student_course where isInSearch(course, 'Math');
+--------------------------------------+--------+--------------------------------+
| id                                   | name   | course                         |
+--------------------------------------+--------+--------------------------------+
| 32268995-f33d-11e4-a31d-089e0140e076 | 张三   | Math,English,Chinese           |
| 3d670ef2-f33d-11e4-a31d-089e0140e076 | 李四   | Math,English,Chinese,Algorithm |
| 475d51a6-f33d-11e4-a31d-089e0140e076 | 李五   | Math,English,Algorithm         |
| 547fdea0-f33d-11e4-a31d-089e0140e076 | 王小明 | Math,English,Japanese          |
+--------------------------------------+--------+--------------------------------+

mysql&gt; select * from student_course where isInSearch(course, 'Chinese,Japanese');
+--------------------------------------+--------+--------------------------------+
| id                                   | name   | course                         |
+--------------------------------------+--------+--------------------------------+
| 32268995-f33d-11e4-a31d-089e0140e076 | 张三   | Math,English,Chinese           |
| 3d670ef2-f33d-11e4-a31d-089e0140e076 | 李四   | Math,English,Chinese,Algorithm |
| 547fdea0-f33d-11e4-a31d-089e0140e076 | 王小明 | Math,English,Japanese          |
+--------------------------------------+--------+--------------------------------+
</code></pre>

2015年五月5日晚上 11:05:02
PHP 到 Node.js的路该如何走？
<div class="markdown-text"><p>无js基础，php出身，该通过什么方式能够快速掌握Node.js?</p>
</div>

2015年五月5日晚上 10:00:43
求大神给建立个符合要求mongodb集合
<div class="markdown-text"><p>nodejs新手，想做个社交聊天的玩具（就是图个新鲜）现在遇见难题了，跪求大神帮助
我数据库用的是mongodb,建立了个用户表
var users=new Schema(
{
email:String,//邮箱
password:String,//密码
username:String,//用户昵称
avatar:String,//头像
sex:String,//性别
auth:String,//验证码
condition:Boolean,//账号是否激活
address:String,//地址
marry:String,//婚姻状况
proclammation:String,//个性宣言
friends:[{fid:Object,//朋友id
remarks:String,//备注
group:String,//分组
allow:Boolean}]
});
我现在遇见的问题是如何通过fid获取朋友的信息，
我刚开始是这样做的
if(docs.friends.length&gt;0){
docs.friends.forEach(function(b){
users.findById(b.fid,function(err,frids){
if(err){
console.log(“加载朋友时候失败了”);
}
var arr={
&quot;userId&quot;:frids._id,
&quot;username&quot;:frids.username,
&quot;avatar&quot;:frids.avatar,
&quot;remarks&quot;: b.remarks,
&quot;group&quot;: b.group
}
frs.push(arr);</p>
<pre class="prettyprint"><code>                    });
                    });
                     res.render(&#x27;coze&#x27;,{frs:frs});
</code></pre><p>但是我对回调函数，异步又不熟悉，设计上有问题，所以最后得不到frs 里的数据,
然后我尝试这用Population，发现friends 里关联的就是users ,而friends 就在users 中，怎么办
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
我的目的其实很简单，就是实现类似QQ那样加载好友信息，同时加载备注的功能，大神给个解决方案吧
参考资料也可以的</p>
</div>

2015年五月5日晚上 8:33:45
alsotang commented on pull request cnodejs/nodeclub#521
<!-- issue_comment -->
<span class="mega-octicon octicon-comment-discussion"></span>

<div class="time">
  <time datetime="2015-05-05T12:33:45Z" is="relative-time">May 5, 2015</time>
</div>

<div class="title">
  <a href="https://github.com/alsotang" data-ga-click="News feed, event click, Event click type:IssueCommentEvent target:actor">alsotang</a> <span>commented</span> on pull request <a href="https://github.com/cnodejs/nodeclub/pull/521#issuecomment-99066593" data-ga-click="News feed, event click, Event click type:IssueCommentEvent target:issue-comment" title="security fix:wooyun-2010-0112230">cnodejs/nodeclub#521</a>
</div>

<div class="details">
  <a href="https://github.com/alsotang"><img alt="@alsotang" class="gravatar" data-user="1147375" height="30" src="https://avatars0.githubusercontent.com/u/1147375?v=3&amp;s=60" width="30" /></a>
  <div class="message markdown-body">
    <blockquote>
      <p>域名还不在我手上，想去乌云认领都难。</p>
    </blockquote>
  </div>
</div>

2015年五月5日晚上 8:29:50
alsotang pushed to master at cnodejs/nodeclub
<!-- push -->
<span class="mega-octicon octicon-git-commit"></span>

<div class="time">
  <time datetime="2015-05-05T12:29:50Z" is="relative-time">May 5, 2015</time>
</div>

<div class="title">
  <a href="https://github.com/alsotang" data-ga-click="News feed, event click, Event click type:PushEvent target:actor">alsotang</a> <span>pushed</span> to <a href="/cnodejs/nodeclub/tree/master" data-ga-click="News feed, event click, Event click type:PushEvent target:branch">master</a> at <a href="https://github.com/cnodejs/nodeclub" data-ga-click="News feed, event click, Event click type:PushEvent target:repo">cnodejs/nodeclub</a>
</div>

<div class="details">
  <a href="https://github.com/alsotang"><img alt="@alsotang" class="gravatar" data-user="1147375" height="30" src="https://avatars0.githubusercontent.com/u/1147375?v=3&amp;s=60" width="30" /></a>

    <div class="commits pusher-is-only-committer">
      <ul>
        <li>
          <span title="alsotang">
            <img alt="@alsotang" data-user="1147375" height="16" src="https://avatars1.githubusercontent.com/u/1147375?v=3&amp;s=32" width="16" />
          </span>
          <code><a href="/cnodejs/nodeclub/commit/5e6cdd627a520bd6aaaf7e1c17f2aae776fe880f" data-ga-click="News feed, event click, Event click type:PushEvent target:sha">5e6cdd6</a></code>
          <div class="message">
            <blockquote>
              fix travis
            </blockquote>
          </div>
        </li>
      </ul>
    </div>
</div>

2015年五月5日晚上 8:27:08
alsotang commented on pull request cnodejs/nodeclub#521
<!-- issue_comment -->
<span class="mega-octicon octicon-comment-discussion"></span>

<div class="time">
  <time datetime="2015-05-05T12:27:08Z" is="relative-time">May 5, 2015</time>
</div>

<div class="title">
  <a href="https://github.com/alsotang" data-ga-click="News feed, event click, Event click type:IssueCommentEvent target:actor">alsotang</a> <span>commented</span> on pull request <a href="https://github.com/cnodejs/nodeclub/pull/521#issuecomment-99065677" data-ga-click="News feed, event click, Event click type:IssueCommentEvent target:issue-comment" title="security fix:wooyun-2010-0112230">cnodejs/nodeclub#521</a>
</div>

<div class="details">
  <a href="https://github.com/alsotang"><img alt="@alsotang" class="gravatar" data-user="1147375" height="30" src="https://avatars0.githubusercontent.com/u/1147375?v=3&amp;s=60" width="30" /></a>
  <div class="message markdown-body">
    <blockquote>
      <p>呃。不好意思刚看到。。。已经修复了。 <a href="https://github.com/cnodejs/nodeclub/commit/0f6cc14f6bcbbe6b4de3199c6896efaec637693e" class="commit-link"><tt>0f6cc14</tt></a></p>
    </blockquote>
  </div>
</div>

2015年五月5日晚上 8:27:08
alsotang closed pull request cnodejs/nodeclub#521
<!-- pull_request -->
<span class="mega-octicon octicon-git-pull-request"></span>

<div class="time">
  <time datetime="2015-05-05T12:27:08Z" is="relative-time">May 5, 2015</time>
</div>

<div class="title">
  <a href="https://github.com/alsotang" data-ga-click="News feed, event click, Event click type:PullRequestEvent target:actor">alsotang</a> <span>closed</span> pull request <a href="https://github.com/cnodejs/nodeclub/pull/521" data-ga-click="News feed, event click, Event click type:PullRequestEvent target:pull">cnodejs/nodeclub#521</a>
</div>

<div class="details">
  <a href="https://github.com/alsotang"><img alt="@alsotang" class="gravatar" data-user="1147375" height="30" src="https://avatars0.githubusercontent.com/u/1147375?v=3&amp;s=60" width="30" /></a>
  <div class="message">
    <blockquote>security fix:wooyun-2010-0112230</blockquote>
  </div>
</div>

2015年五月5日晚上 8:22:08
How to structure models in NodeJS
<div class="markdown-text"><p>我想请问下，在nodeJS 中Model 的结构是咋样的？
我之前是做Java/C# 程序的， 在以往我的model 全部都是单独作为一个文件来存放（POJO），然后会有一个专门的数据访问类，或则一个Repository，例如：</p>
<p>– 纯model 文件
publi class User{
poublic int Id {get; set}
public string FirstName { get; set; }
public string LastName { get; set; }
…
}
– 数据访问类
public class UserRep{
public IEnumerable&lt;User&gt; All();
public User Get();
…
}</p>
<p>但是，我看网上有好些教程，大都是把 Model 的字段和方法放在同一个文件里头：
var User = function(id, firstname, lastname) {
this.Id=id;
…
}
// 先是一些静态方法
User.findById = function() {  }
// 然后还有些 实例方法
User.prototype.save = function() {}</p>
<p>这样做我感觉怪怪的， 数据， 和数据访问层不应该分开吗？还有几个疑问（我不用Mongodb, 我用的是传统的RDBS）：</p>
<ol>
<li>如何做 data validation；</li>
<li>单元测试如何集成；</li>
<li>如果使用ORM 该怎么样用；</li>
</ol>
</div>

2015年五月5日晚上 7:46:08
iojs v2.0 开启 use strong 之后。。。
<div class="markdown-text"><p>就可以和var说再见了~~一遍es6、7写下来，如果再使用<a href="http://flowtype.org/">flow</a>，那感觉基本就不是js了⊙﹏⊙b。
<a href="https://github.com/yosuke-furukawa/iojs-new-features">iojs-new-features</a></p>
</div>

2015年五月5日晚上 7:44:21
alsotang pushed to online at cnodejs/nodeclub
<!-- push -->
<span class="mega-octicon octicon-git-commit"></span>

<div class="time">
  <time datetime="2015-05-05T11:44:21Z" is="relative-time">May 5, 2015</time>
</div>

<div class="title">
  <a href="https://github.com/alsotang" data-ga-click="News feed, event click, Event click type:PushEvent target:actor">alsotang</a> <span>pushed</span> to <a href="/cnodejs/nodeclub/tree/online" data-ga-click="News feed, event click, Event click type:PushEvent target:branch">online</a> at <a href="https://github.com/cnodejs/nodeclub" data-ga-click="News feed, event click, Event click type:PushEvent target:repo">cnodejs/nodeclub</a>
</div>

<div class="details">
  <a href="https://github.com/alsotang"><img alt="@alsotang" class="gravatar" data-user="1147375" height="30" src="https://avatars0.githubusercontent.com/u/1147375?v=3&amp;s=60" width="30" /></a>

    <div class="commits pusher-is-only-committer">
      <ul>
        <li>
          <span title="alsotang">
            <img alt="@alsotang" data-user="1147375" height="16" src="https://avatars1.githubusercontent.com/u/1147375?v=3&amp;s=32" width="16" />
          </span>
          <code><a href="/cnodejs/nodeclub/commit/a0b8cb11028c5aba609f9ed45951fe81e0fdbd2f" data-ga-click="News feed, event click, Event click type:PushEvent target:sha">a0b8cb1</a></code>
          <div class="message">
            <blockquote>
              coding.net
            </blockquote>
          </div>
        </li>
        <li>
          <span title="alsotang">
            <img alt="@alsotang" data-user="1147375" height="16" src="https://avatars1.githubusercontent.com/u/1147375?v=3&amp;s=32" width="16" />
          </span>
          <code><a href="/cnodejs/nodeclub/commit/35a096f81c5abc93bdae538fc7fcd96c61ebfa19" data-ga-click="News feed, event click, Event click type:PushEvent target:sha">35a096f</a></code>
          <div class="message">
            <blockquote>
              qiniu
            </blockquote>
          </div>
        </li>
        <li class="more"><a href="https://github.com/cnodejs/nodeclub/compare/ae8b959909...a0b8cb1102" data-ga-click="News feed, event click, Event click type:PushEvent target:comparison">5 more commits &raquo;</a></li>
      </ul>
    </div>
</div>

2015年五月5日晚上 7:43:50
alsotang pushed to master at cnodejs/nodeclub
<!-- push -->
<span class="mega-octicon octicon-git-commit"></span>

<div class="time">
  <time datetime="2015-05-05T11:43:50Z" is="relative-time">May 5, 2015</time>
</div>

<div class="title">
  <a href="https://github.com/alsotang" data-ga-click="News feed, event click, Event click type:PushEvent target:actor">alsotang</a> <span>pushed</span> to <a href="/cnodejs/nodeclub/tree/master" data-ga-click="News feed, event click, Event click type:PushEvent target:branch">master</a> at <a href="https://github.com/cnodejs/nodeclub" data-ga-click="News feed, event click, Event click type:PushEvent target:repo">cnodejs/nodeclub</a>
</div>

<div class="details">
  <a href="https://github.com/alsotang"><img alt="@alsotang" class="gravatar" data-user="1147375" height="30" src="https://avatars0.githubusercontent.com/u/1147375?v=3&amp;s=60" width="30" /></a>

    <div class="commits pusher-is-only-committer">
      <ul>
        <li>
          <span title="alsotang">
            <img alt="@alsotang" data-user="1147375" height="16" src="https://avatars1.githubusercontent.com/u/1147375?v=3&amp;s=32" width="16" />
          </span>
          <code><a href="/cnodejs/nodeclub/commit/0f6cc14f6bcbbe6b4de3199c6896efaec637693e" data-ga-click="News feed, event click, Event click type:PushEvent target:sha">0f6cc14</a></code>
          <div class="message">
            <blockquote>
              mongodb 注入漏洞
            </blockquote>
          </div>
        </li>
      </ul>
    </div>
</div>

2015年五月5日晚上 7:32:41
正则表达式笔记（二）
<h2>JS 中的正则表达式</h2>

<h3>概述</h3>

<p>在 JS 中，正则表达式是个 <code>RegExp</code> 对象，具有 <code>exec</code>，<code>test</code> 方法。而在 <code>String</code> 对象中，也存在 <code>match</code>，<code>replace</code>，<code>search</code>，<code>split</code> 操作正则表达式的方法。</p>

<h3>声明</h3>

<p>JS 中的正则表达式有两种声明方式（对象字面量 / 构造函数），都会生产一个 <code>RegExp</code> 对象的实例。</p>

<pre><code>/pattern/flags
new RegExp(pattern[, flags])
</code></pre>

<h3>RegExp 对象</h3>

<p><strong>实例</strong></p>

<pre><code>var pattern = /quick\s(brown).+?(jumps)/ig;
var pattern = new RegExp("quick\\s(brown).+?(jumps)","ig");
</code></pre>

<p>实例之后的 <code>pattern</code> 对象就具有以下属性:</p>

<ul>
<li>
<code>lastIndex</code>：下次开始匹配的字符串位置，若是无设置全局模式，会始终为 0</li>
<li>
<code>ignoreCase</code>：是否设置忽略大小写模式</li>
<li>
<code>global</code>：是否设置了全局匹配模式</li>
<li>
<code>multiline</code>：是否设置了多行模式</li>
<li>
<code>source</code>：正则表达式的文本内容</li>
</ul>
<p>注意使用构造函数声明正则表达式的时候，需合理使用转义符。</p>

<p><strong>方法</strong></p>

<p><code>RegExp.exec</code> 检索字符串中指定的值。返回一个结果数组。该方法总是返回单词匹配的结果。</p>

<p>在正则表达式设置了 <code>g</code> 模式的情况下，会同时更新 <code>RegExp</code> 对象的 <code>lastIndex</code> 属性。</p>

<pre><code>var result = re.exec('The Quick Brown Fox Jumps Over The Lazy Dog');
// console.log(result)
// ["Quick Brown Fox Jumps", "Brown", "Jumps"]

var pattern = /ab*/g;
var str = 'abbcdefabh';
var matchArray;
while ((matchArray = pattern.exec(str)) !== null) {
  var msg = 'Found ' + matchArray[0] + '. ';
  msg += 'Next match starts at ' + pattern.lastIndex;
  //console.log(msg);
  // Found abb. Next match starts at 3
  // Found ab. Next match starts at 9
}
</code></pre>

<p>使用循环的时候，不要把正则表达式的操作放置在循环体中（这样每次都会重新生成 <code>RegExp</code> 对象），同时必须设置全局模式，可能会造成死循环。</p>

<p><code>RegExp.test</code> 执行检索字符串中指定值的操作。返回 <code>true</code> 或 <code>false</code>。</p>

<pre><code>var pattern = /^\d{4}-\d{2}-\d{2}$/;
var result = re.test('2010-12-20');

console.log(result)
// true
</code></pre>

<p>在正则表达式设置了 <code>g</code> 模式的情况下，跟 <code>RegExp.exec</code> 一样，会同时更新 <code>RegExp</code> 对象的 <code>lastIndex</code> 属性。</p>

<pre><code>var pattern = /^\d{4}-\d{2}-\d{2}$/g;
pattern.test('2010-12-20'); // true
pattern.test('2010-12-20'); // false
</code></pre>

<p><code>RegExp.test</code> 在匹配成功之后，各个捕获分组的文本会保存下来，用 <code>RegExp.$1</code>，<code>RegExp.$2</code>··· 就可以获得，不过，保存整个表达式匹配文本的 <code>RegExp.$0</code> 并不存在。</p>

<h3>String 对象</h3>

<p><strong>方法</strong></p>

<p><code>String.match</code> 返回一个结果数组或<code>null</code>。</p>

<p>在正则表达式设置了 <code>g</code> 模式的情况下，<code>match</code> 默认返回所有可能的匹配结果。</p>

<pre><code>var str = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
var re = /[A-E]/gi;
var matches = str.match(re);

console.log(matches);
// ['A', 'B', 'C', 'D', 'E', 'a', 'b', 'c', 'd', 'e']
</code></pre>

<p>如果正则表达式没有设置 <code>g</code> 模式，那么 <code>match</code> 方法返回的结果与 <code>RegExp.exec()</code> 一致。</p>

<pre><code>var str = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
var re = /[A-E]/i;
var matches_1 = str.match(re);
var matches_2 = re.exec(str)

console.log(matches_1, matches_2)

//[ 'A',
  index: 0,
  input: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz' ]
</code></pre>

<p>该返回结果包含匹配的字符串，还有一个额外的 <code>index</code> 属性，表示匹配字符串的位置，<code>input</code> 属性即是所传入的字符串。</p>

<p><code>String.search</code> 返回第一次匹配的位置或 <code>-1</code></p>

<p>该方法用来寻找某个正则表达式在字符串中第一次匹配成功的位置，失败的时候返回 <code>-1</code>。</p>

<p>这个方法只能找到“第一次”，即使设置了 <code>g</code> 模式，结果也不会有任何变化，所以如果需要使用一个正则表达式多次验证字符串，调用该方法判断结果是否为 0，是更好的办法。</p>

<pre><code>"1234".search(/^\d+$/g) == 0 // true
"5678".search(/^\d+$/g) == 0 // true

var pattern = /^\d+$/g;
pattern.test("1234"); // true
pattern.test("5678"); // false
</code></pre>

<p><code>String.split</code> 使用一个正则表达式来切割字符串。返回数组</p>

<p>正则表达式是否设置了<code>g</code>模式对结果没有影响。</p>

<pre><code>var matchArray = "a b c".split(/\s+/);

console.log(matchArray);
// ["a", "b", "c"]
</code></pre>

<p>也可以设置第二个参数 <code>limit</code>，指定返回数组的数目。在 JS 中，该参数取值的结果如下</p>

<table>
<thead><tr>
<th>取值</th>
  <th>结果</th>
</tr></thead>
<tbody>
<tr>
<td>limit &lt; 0 || limit &gt; n</td>
  <td>等同于未指定</td>
</tr>
<tr>
<td>0&lt;=limit&lt;=n</td>
  <td>返回一个包含 n 元素的数组</td>
</tr>
</tbody>
</table>
<pre><code>var matchArray = "a b c".split(/\s+/,2);

console.log(matchArray);
// ["a", "b"]
</code></pre>

2015年五月5日晚上 7:24:48
alsotang pushed to online at cnodejs/nodeclub
<!-- push -->
<span class="mega-octicon octicon-git-commit"></span>

<div class="time">
  <time datetime="2015-05-05T11:24:48Z" is="relative-time">May 5, 2015</time>
</div>

<div class="title">
  <a href="https://github.com/alsotang" data-ga-click="News feed, event click, Event click type:PushEvent target:actor">alsotang</a> <span>pushed</span> to <a href="/cnodejs/nodeclub/tree/online" data-ga-click="News feed, event click, Event click type:PushEvent target:branch">online</a> at <a href="https://github.com/cnodejs/nodeclub" data-ga-click="News feed, event click, Event click type:PushEvent target:repo">cnodejs/nodeclub</a>
</div>

<div class="details">
  <a href="https://github.com/alsotang"><img alt="@alsotang" class="gravatar" data-user="1147375" height="30" src="https://avatars0.githubusercontent.com/u/1147375?v=3&amp;s=60" width="30" /></a>

    <div class="commits pusher-is-only-committer">
      <ul>
        <li>
          <span title="alsotang">
            <img alt="@alsotang" data-user="1147375" height="16" src="https://avatars1.githubusercontent.com/u/1147375?v=3&amp;s=32" width="16" />
          </span>
          <code><a href="/cnodejs/nodeclub/commit/ae8b95990929cd3e0df54492817f00442e4b3014" data-ga-click="News feed, event click, Event click type:PushEvent target:sha">ae8b959</a></code>
          <div class="message">
            <blockquote>
              coding.net
            </blockquote>
          </div>
        </li>
      </ul>
    </div>
</div>

2015年五月5日晚上 6:39:24
node js callback 的一些问题
<div class="markdown-text"><p>小弟最近在练习node js
但总是遇到一个问题不知道该怎么解决
是关于callback的问题
举个例子来说 mysql 模塊中對mysql下query</p>
<p>var rs;
connection.query('SELECT 1 + 1 AS solution’, function(err, rows, fields) {
if (err) throw err;
rs = rows;
console.log('The solution is: ', rows[0].solution);
});</p>
<p>根据官方文件 返回的结果 会传给rows
但我在外面宣告一个变数去里面把rows传给他
但之后console看却是undefine 不确定是不是callback函数的范围问题</p>
<p>如果我想要对结果作处理一定要在callback里面做吗?
得到的结果可以传出来吗?这个地方我一直有问题观念不是很懂
所以来这边请教一下各位</p>
</div>

2015年五月5日晚上 6:16:05
关于MongoDB 和 缓存
<div class="markdown-text"><p>MongoDB 号称查询已经非常快，而且热数据是在内存上的，那还有必要专门优化吗？</p>
</div>

2015年五月5日晚上 6:07:28
求解答socket.io client代码处理方案
<div class="markdown-text"><p>socket.io在客户端需要写相应的代码去请求server端的事件。那这样就相当于把client 的js代码暴露在浏览器，这样不就很危险，相当于用户可以通过编写js去请求我的server服务，想问问各位有什么好的处理方案。例如js客户端代码加密（初步方案而已）。</p>
</div>

2015年五月5日下午 4:49:16
在用npm start 启动项目的时候，会出现如图情况。
<div class="markdown-text"><p><img src="//dn-cnode.qbox.me/Ftkk5GXKhuZDHUQgfArd3MWs4viU" alt="cnodejs.png"></p>
<p>启动就是用express生成的项目，在线等。</p>
<p>对了，补充一下。是window7系统</p>
</div>

2015年五月5日下午 2:57:14
alsotang pushed to online at cnodejs/nodeclub
<!-- push -->
<span class="mega-octicon octicon-git-commit"></span>

<div class="time">
  <time datetime="2015-05-05T06:57:14Z" is="relative-time">May 5, 2015</time>
</div>

<div class="title">
  <a href="https://github.com/alsotang" data-ga-click="News feed, event click, Event click type:PushEvent target:actor">alsotang</a> <span>pushed</span> to <a href="/cnodejs/nodeclub/tree/online" data-ga-click="News feed, event click, Event click type:PushEvent target:branch">online</a> at <a href="https://github.com/cnodejs/nodeclub" data-ga-click="News feed, event click, Event click type:PushEvent target:repo">cnodejs/nodeclub</a>
</div>

<div class="details">
  <a href="https://github.com/alsotang"><img alt="@alsotang" class="gravatar" data-user="1147375" height="30" src="https://avatars0.githubusercontent.com/u/1147375?v=3&amp;s=60" width="30" /></a>

    <div class="commits pusher-is-only-committer">
      <ul>
        <li>
          <span title="alsotang">
            <img alt="@alsotang" data-user="1147375" height="16" src="https://avatars1.githubusercontent.com/u/1147375?v=3&amp;s=32" width="16" />
          </span>
          <code><a href="/cnodejs/nodeclub/commit/3642ce41a7834a834f933870f6e8edad8e9498ad" data-ga-click="News feed, event click, Event click type:PushEvent target:sha">3642ce4</a></code>
          <div class="message">
            <blockquote>
              qiniu
            </blockquote>
          </div>
        </li>
      </ul>
    </div>
</div>

2015年五月5日下午 2:13:42
来帮我做个小调研《Node使用情况小调查》
<div class="markdown-text"><p>问卷地址在这里：<a href="http://survey.taobao.com/survey/AgT436qK">http://survey.taobao.com/survey/AgT436qK</a></p>
<p>不用登陆。只有5个小题。么么哒。</p>
<p>调研已经结束，谢谢各位。</p>
</div>

2015年五月5日下午 2:06:55
糗百的数据迁移实践
<p>糗事百科（以下简称“糗百”）被誉为移动互联网时代的新娱乐手段，其上海量真实用户的糗事深受喜爱，每天有1亿次动态请求，峰值请求数为每秒30000次。面对如此高的并发访问量，糗百原来自建的平台越来越难以支撑，开始出现服务器过载、跨机房同步延时大、图片中心磁盘I/O成为瓶颈等问题。</p>

<p>为了解决这些刚性的服务压力，优化用户的服务体验，并考虑到七牛对静态资源存储的强大技术实力和优秀的解决方案，糗百决定将图片存储迁移到七牛平台上，并开始使用七牛提供的CDN服务。本文将结合糗百的数据迁移实践，来详细讲述如何在不中断服务的情况下，将海量数据平滑迁移到七牛平台的全过程。</p>

<p><strong>qrsync+镜像存储打造平滑迁移方案</strong></p>

<p>传统的数据迁移方案是：关掉网站原来的数据上传通道，所有数据变成只读，然后将所有数据上传到新的存储节点，再将上传入口改为新的存储节点，之后开放网站的上传功能。这样带来的问题是，数据迁移过程中，用户长时间不能进行上传操作，用户体验非常差。如何解决这个问题呢？</p>

<p>针对糗百这么大体量的应用，七牛提供的数据迁移方案——上传工具qrsync+镜像存储，很好地绕开了传统迁移方案所带来的问题。糗百先通过七牛的数据上传工具qrsync将大量冷数据传到七牛平台上，并将数据访问地址切换成七牛的域名。由于用户生成的大量热数据还在糗百自己的平台上，为了不出现数据丢失的情况，保证用户访问的流畅性，糗百选用了七牛的镜像存储服务。</p>

<p>七牛的镜像存储为整个数据迁移过程提供良好的过渡支持作用。当用户访问的数据不在七牛平台上时，镜像存储服务将回糗百源站抓取数据，并保存在七牛平台上。故此，镜像存储对每个资源只需回源一次，后续访问的时候就不再回源了。<br><img src="/img/bVlCpw" alt="图片描述"></p>

<p>随后，为了进一步缓解糗百源站的I/O压力，糗百对旧有系统做了一次版本升级，将新系统的图片存储直接放在七牛平台上。新版本的用户可以顺畅地将数据上传到七牛平台上，并实现访问，而旧系统的App版本还会有一部分用户在使用。这时，就要在一段时间内保证两套系统可用。但旧系统的App用户所产生的数据还是会被上传到糗百的自建平台中，在用户第一次访问这些数据时，镜像存储服务对糗百源站做回源，很好地确保了这部分数据的可用性。由于目前App客户端的版本更新速度比较快，因此在所有用户都更新成新版系统，源站的回源流量逐渐趋于0时，就可以将镜像功能删除了。</p>

<p>就这样，在用户毫无感知的情况下，糗百轻松实现了对图片存储的迁移，平稳地解决了图片中心磁盘I/O的瓶颈问题。</p>

<p><strong>镜像存储的使用方法</strong></p>

<p>假设源站所有的图片，放在一个叫img.example.com的子域里。那么平滑迁移的方式是：</p>

<p>1、在七牛上建立一个镜像bucket，设定源站为img.example.com。假设镜像bucket是example-img，到空间设置的域名设置中即可找到形式为7xiuqc.com1.z0.glb.clouddn.com的七牛域名；<br>
2、将所有对外使用的图片的域名改为7xiuqc.com1.z0.glb. clouddn.com；<br>
3、如果网站数据是UGC（用户产生内容）的，调整上传流程，传到七牛的镜像 bucket，这样源站就变成只读；<br>
4、使用qrsync同步工具将历史数据全部同步到七牛的镜像bucket。</p>

<p>如此就完成了整个迁移过程。此时img.example.com这个源站就可以废弃不用了。</p>

<p><strong>结语</strong></p>

<p>相信数据资源高速增长这样的“甜蜜负担”，是很多企业都会遇到的。而如何借助云服务来合理扩容，如何在不中断服务的前提下，平滑地实现数据迁移，将成为决定企业未来命运的关键一环。七牛云存储不仅能为企业用户稳定高效的底层存储平台，镜像存储等优质的服务更能在数据迁移过程中提供强大的助力。此外，完成数据迁移之后，七牛提供的丰富的图片、音视频处理功能也为包括糗百在内的诸多企业带来了很大的惊喜。后续我们将专门撰文分享这部分内容。</p>

2015年五月5日中午 11:55:15
CentOS 6.x 升级 Git
<h2>准备</h2>

<h3>说明</h3>

<p>公司服务器为centos，安装git后的默认版本是1.7.1，在执行git clone命令时报错如下：</p>

<pre><code>    fatal: HTTP request failed
</code></pre>

<p>经过一番搜索终于找到可行的办法，即为升级git版本，升级时间比较长，需要比较好的网络支持.</p>

<h3>git版本检测</h3>

<p>CentOS下使用<code>git --version</code> 检测git的版本</p>

<pre><code># git --version
git version 1.7.1
</code></pre>

<h3>系统检测</h3>

<pre><code># cat /etc/redhat-release
CentOS release 6.5 (Final)
# uname -a
Linux rmhost 2.6.32-431.el6.x86_64 #1 SMP Fri Nov 22 03:15:09 UTC 2013 x86_64 x86_64 x86_64 GNU/Linux
</code></pre>

<p>通过以上信息可知系统版本为 CentOS 6.5 64位</p>

<h2>升级</h2>

<h3>1.导入证书</h3>

<pre><code># rpm --import http://apt.sw.be/RPM-GPG-KEY.dag.txt
</code></pre>

<h3>2.安装RPMForge源</h3>

<p>在<a rel="nofollow" href="http://pkgs.repoforge.org/rpmforge-release/">这里</a>查找对应的版本,比如我这里根据系统版本选择了<code>rpmforge-release-0.5.3-1.el6.rf.x86_64.rpm</code>,右键拷贝地址, 粘贴到命令<code>rpm -i</code>命令后面执行</p>

<pre><code># rpm -i http://pkgs.repoforge.org/rpmforge-release/rpmforge-release-0.5.3-1.el6.rf.x86_64.rpm

package rpmforge-release-0.5.3-1.el6.rf.x86_64 is already installed
</code></pre>

<blockquote>
  <p>符合系统版本的文件可能有多个,选一个较新的即可.</p>
</blockquote>

<h3>3.更新rpmforge-extra源</h3>

<pre><code># yum --enablerepo=rpmforge-extras update
</code></pre>

<p>途中会有选项<code>Is this ok [y/N]:</code>询问是否下载, 如果选了y会更新所有的软件到匹配的最新版本,包括git,如果选N也可以手动安装git到最新版</p>

<blockquote>
  <p>这里建议选择N,选y需要较长时间(我当前网速下测试为一小时左右),一些软件升级后可能需要重新配置才能起作用, 比如MySQL从5.1升级到了5.5, 由于未配置直接导致我在线的两个项目无法运行, 只能手忙脚乱的赶紧修改配置,如果你不幸出了同样的问题, 可以到文章末尾找到解决办法</p>
</blockquote>

<h3>4.查找符合系统的git版本</h3>

<h5>通过下面的命令查找(推荐)</h5>

<pre><code>    # yum --enablerepo=rpmforge-extras provides git
    git-1.7.12.4-1.el6.rfx.x86_64 : Git core and tools
    Repo        : installed
    匹配来自于:
    Other       : 提供依赖满足：git
</code></pre>

<h5>或者在软件库中查找</h5>

<p>在<a rel="nofollow" href="http://pkgs.repoforge.org/git/">这里</a>找到系统能支持的git最新版本</p>

<h3>5.安装git</h3>

<pre><code># yum --enablerepo=rpmforge-extras install perl-Git-1.7.12.4-1.el6.rfx.x86_64.rpm 
# git --version
git version 1.7.12.4
</code></pre>

<h3>MySQL升级后不能启动的解决办法</h3>

<p>系统使用rpm源升级了所有软件, MySQL从5.1升级到了5.5, 启动的时候抛出异常:</p>

<pre><code>MySQL Daemon failed to start.
正在启动 mysqld：                                   [失败]
</code></pre>

<h4>原因：</h4>

<p>MySQL升级之后，由于配置文件/etc/my.cnf还是原来5.1的，对5.5已经不适用了，所以出错</p>

<h4>解决办法：</h4>

<p>用MySQL-5.5的配置文件替换原来的/etc/my.cnf,具体操作</p>

<pre><code>cp /usr/share/mysql/my-medium.cnf /etc/my.cnf
</code></pre>

<blockquote>
  <p>注意：MySQL配置模板文件共有5个：my-huge.cnf、my-innodb-heavy-4G.cnf、my-large.cnf、mymedium.cnf、my-small.cnf，根据自己的服务器硬件配置选择相应的模板文件即可</p>
</blockquote>

<h2>参考</h2>

<p>CentOS升级git：</p>

<ul>
<li><a rel="nofollow" href="http://blog.csdn.net/ljianhui/article/details/23888269">CentOS升级Git</a></li>
<li><a rel="nofollow" href="http://www.educity.cn/linux/1572933.html">CentOS升级Git</a></li>
</ul>
<p>MySQL无法启动：</p>

<ul>
<li><a rel="nofollow" href="http://www.111cn.net/sys/linux/45604.htm">linux中mysql升级后不能启动的解决方法</a></li>
</ul>

2015年五月5日中午 11:39:23
有人用过apache的ab test测试post请求么？post请求的文件正确格式是啥？
<div class="markdown-text"><p>求问，网上搜了很多都只介绍了ab test的基本用法，测post请求的还真难搜到，我想知道如果我post一个复杂的json数据（比如对象包含对象，包含数组这种结构的），post请求的file文件正确格式是啥？有什么工具或方法可以帮我把json数据转换成正确的post格式么？谢谢！</p>
</div>

2015年五月5日中午 11:37:38
【北京】Melotic招聘 Nodejs/ops工程师(15k- 30k)
<div class="markdown-text"><p>【关于我们】
Melotic成立于2014年年初，以香港为基地的数字资产交换和流通平台，在大陆、台湾、美国分别设有分公司，平台应用了革命性的金融技术，将迅速在全球多个国家开展业务。
团队已是获美国LIGHT SPEED VENTURE风投支持，CEO是斯坦福大学毕业并在美国硅谷创业多年的JACK WANG,
中英文双语工作环境，工作地点为团结湖地铁站附近的三里屯创业空间科技寺。
【关于职位】
Nodejs/ops工程师，后端工程师，国际平台，只要你有能力，一切都不是问题
工作地点：北京市
工作年限：3年以上
最低学历：本科
招聘人数：1
职位月薪：￥15,000 - 30,000
【职责&amp;要求】
岗位职责
Responsibilities</p>
<ul>
<li>Build and deploy robust, manageable and scalable back ends</li>
<li>Integrate 3rd party services via RESTful and streaming APIs</li>
<li>Design and implement RESTful interfaces that exposes our data</li>
<li>Rapidly fix bugs and solve problems</li>
<li>Work closely with front-end teams to create optimally integrated solutions</li>
</ul>
<p>任职要求
Requirements</p>
<ul>
<li>Strong Javascript skills</li>
<li>Knowledge of Node.js packages (Express, Async, Mongoose, Socket.io, Request, etc.)</li>
<li>Experience with message and job queuing services (RabbitMQ, Redis, etc.)</li>
<li>Very strong ability to design and develop scalable systems on top of Node.js</li>
<li>Experience working with MongoDB, Mysql and Redis.</li>
<li>Disciplined approach to testing and quality assurance, knowledge of Javascript testing tools.</li>
<li>High understanding of computer science concepts such as: common data structures and algorithms, profiling/optimization</li>
</ul>
<p>Desired</p>
<ul>
<li>Devops experience</li>
<li>Github profile or link to open source work</li>
<li>Comfortable working with version control using Git</li>
<li>Adequate communication skills in English</li>
</ul>
<p>【联系我们】
如果您对工作职位感兴趣，请将您的简历或情况发送到邮箱<a href="mailto:sindy@melotic.com">sindy@melotic.com</a>联系我们，我们会尽快回复~</p>
</div>

2015年五月5日中午 11:36:05
CentOS 7 安装 Gitlab
<h2>安装基本系统与依赖包</h2>

<h3>安装 Gitlab 依赖的工具</h3>

<pre><code>bash</code><code>yum -y update
yum -y groupinstall 'Development Tools'
yum -y install readline readline-devel ncurses-devel gdbm-devel glibc-devel tcl-devel openssl-devel curl-devel expat-devel db4-devel byacc sqlite-devel libyaml libyaml-devel libffi libffi-devel libxml2 libxml2-devel libxslt libxslt-devel libicu libicu-devel system-config-firewall-tui git redis ruby sudo wget crontabs logwatch logrotate perl-Time-HiRes
</code></pre>

<h3>安装 Redis</h3>

<p>访问 <a rel="nofollow" href="http://www.redis.io/download"></a><a rel="nofollow" href="http://www.redis.io/download">http://www.redis.io/download</a>，下载 <strong>Redis</strong> 源代码。</p>

<pre><code>bash</code><code>wget http://download.redis.io/releases/redis-3.0.0.tar.gz
tar zxvf redis-3.0.0.tar.gz
cd redis-3.0.0
make
</code></pre>

<blockquote>
  <p>若在编译过程中出错，则可以执行下面的命令：</p>

<pre><code>bash</code><code>sudo make test
</code></pre>
</blockquote>

<h4>安装：</h4>

<pre><code>bash</code><code>sudo make install
sudo ./utils/install_server.sh
</code></pre>

<h4>配置</h4>

<p>创建 <code>/etc/init.d/redis</code> 并使用下面的代码作为启动脚本。</p>

<p>添加如下内容：</p>

<pre><code>bash</code><code>###########################
PATH=/usr/local/bin:/sbin:/usr/bin:/bin

REDISPORT=6379
EXEC=/usr/local/bin/redis-server
REDIS_CLI=/usr/local/bin/redis-cli

PIDFILE=/var/run/redis.pid
CONF="/etc/redis/6379.conf"

case "$1" in
    start)
        if [ -f $PIDFILE ]
        then
                echo "$PIDFILE exists, process is already running or crashed"
        else
                echo "Starting Redis server..."
                $EXEC $CONF
        fi
        if [ "$?"="0" ]
        then
              echo "Redis is running..."
        fi
        ;;
    stop)
        if [ ! -f $PIDFILE ]
        then
                echo "$PIDFILE does not exist, process is not running"
        else
                PID=$(cat $PIDFILE)
                echo "Stopping ..."
                $REDIS_CLI -p $REDISPORT SHUTDOWN
                while [ -x ${PIDFILE} ]
               do
                    echo "Waiting for Redis to shutdown ..."
                    sleep 1
                done
                echo "Redis stopped"
        fi
        ;;
   restart|force-reload)
        ${0} stop
        ${0} start
        ;;
  *)
    echo "Usage: /etc/init.d/redis {start|stop|restart|force-reload}" &gt;&amp;2
        exit 1
esac
##############################
</code></pre>

<p>保存后，添加可执行权限：</p>

<pre><code>sudo chmod +x /etc/init.d/redis
</code></pre>

<p>确保 <code>redis</code> 能随系统启动：</p>

<pre><code>vi /etc/rc.d/rc.local
</code></pre>

<p>在文件末尾添加下面这行：</p>

<pre><code>service redis start
</code></pre>

<p>然后使用上面同样的命令启动 <code>redis</code> 服务：</p>

<pre><code>service redis start
</code></pre>

<h3>安装邮件服务器</h3>

<pre><code>yum -y install postfix
</code></pre>

<h3>安装Git</h3>

<p>先删除系统中原有的老版本 <code>git</code>：</p>

<pre><code>bash</code><code>yum -y remove git
yum install zlib-devel perl-CPAN gettext curl-devel expat-devel gettext-devel openssl-devel
</code></pre>

<p>从官方网站下载源代码进行：</p>

<pre><code>bash</code><code>curl --progress https://www.kernel.org/pub/software/scm/git/git-2.4.0.tar.gz | tar xz
cd git-2.4.0/
./configure
make
make prefix=/usr/local install
</code></pre>

<p>然后使用下面这个命令检测安装是否有效：</p>

<pre><code>which git
</code></pre>

<h2>安装 ruby</h2>

<p>如果 ruby 的版本低于 <code>2.0</code> 的话，则需要重新安装 <code>ruby</code>。</p>

<pre><code>bash</code><code>cd ~
curl --progress ftp://ftp.ruby-lang.org/pub/ruby/2.2/ruby-2.2.2.tar.gz | tar xz
cd ruby-2.2.2
./configure --disable-install-rdoc
make
make prefix=/usr/local install
</code></pre>

<h2>为 Gitlab 添加系统用户</h2>

<pre><code>adduser --system --shell /bin/bash --comment 'GitLab' --create-home --home-dir /home/git/ git
</code></pre>

<p>为了包含/usr/local/bin到git用户的$PATH，一个方法是编辑超级用户文件。以管理员身份运行：</p>

<pre><code>visudo
</code></pre>

<p>然后搜索：</p>

<pre><code>Defaults    secure_path = /sbin:/bin:/usr/sbin:/usr/bin
</code></pre>

<p>将其改成：</p>

<pre><code>Defaults    secure_path = /sbin:/bin:/usr/sbin:/usr/bin:/usr/local/bin
</code></pre>

<h2>安装数据库</h2>

<p>MySQL 已经不再包含在 CentOS 7 的源中，而改用了 MariaDB，先搜索 <code>MariaDB</code> 现有的包：</p>

<pre><code>rpm -qa | grep mariadb
</code></pre>

<p>然后全部删除：</p>

<pre><code>rpm -e --nodeps mariadb-*
</code></pre>

<p>然后创建 <code>/etc/yum.repos.d/MariaDB.repo</code>：</p>

<pre><code>vi /etc/yum.repos.d/MariaDB.repo
</code></pre>

<p>将以下内容添加至该文件中：</p>

<pre><code># MariaDB 10.0 CentOS repository list - created 2015-05-04 19:16 UTC
# http://mariadb.org/mariadb/repositories/
[mariadb]
name = MariaDB
baseurl = http://yum.mariadb.org/10.0/centos7-amd64
gpgkey=https://yum.mariadb.org/RPM-GPG-KEY-MariaDB
gpgcheck=1
</code></pre>

<p>然后运行下面命令安装 <code>MariaDB 10.0</code>：</p>

<pre><code>sudo yum install MariaDB-server MariaDB-client
</code></pre>

<p>然后启动 MariaDB 服务：</p>

<pre><code>service mysql start
</code></pre>

<p>接着运行 <code>mysql_secure_installation</code>：</p>

<pre><code>mysql_secure_installation
</code></pre>

<p>登录 MariaDB 并创建相应的数据库用户与数据库：</p>

<pre><code>mysql -uroot -p
CREATE USER 'git'@'localhost' IDENTIFIED BY '$password';
SET storage_engine=INNODB;
CREATE DATABASE IF NOT EXISTS `gitlabhq_production` DEFAULT CHARACTER SET `utf8` COLLATE `utf8_unicode_ci`;
GRANT SELECT, LOCK TABLES, INSERT, UPDATE, DELETE, CREATE, DROP, INDEX, ALTER ON `gitlabhq_production`.* TO 'git'@'localhost';
\q
</code></pre>

<p>尝试使用新用户连接数据库：</p>

<pre><code>sudo -u git -H mysql -u git -p -D gitlabhq_production
\q
</code></pre>

<h2>安装 Gitlab</h2>

<h3>克隆源</h3>

<pre><code>sudo -u -git cd /home/git
sudo -u git -H git clone https://gitlab.com/gitlab-org/gitlab-ce.git -b 7-10-stable gitlab
</code></pre>

<h3>配置</h3>

<pre><code>cd /home/git/gitlab

# Copy the example GitLab config
# 复制GitLab的示例配置文件
sudo -u git -H cp config/gitlab.yml.example config/gitlab.yml

# Make sure to change "localhost" to the fully-qualified domain name of your host serving GitLab where necessary
# 确保修改“localhost”为你的GitLab主机的FQDN
#
# If you want to use https make sure that you set `https` to `true`. See #using-https for all necessary details.
# 如果你想要使用https确保你设置了`https`为`true`。具体必要的细节参见#using-https
#
# If you installed Git from source, change the git bin_path to /usr/local/bin/git
# 如果你从源代码安装了Git，修改git的bin_path为/usr/local/bin/git
sudo -u git -H editor config/gitlab.yml

# Make sure GitLab can write to the log/ and tmp/ directories
# 确保GitLab可以写入log/和temp/目录
chown -R git {log,tmp}
chmod -R u+rwX  {log,tmp}

# Create directory for satellites
# 为卫星(?)创建目录
sudo -u git -H mkdir /home/git/gitlab-satellites
chmod u+rwx,g+rx,o-rwx /home/git/gitlab-satellites

# Make sure GitLab can write to the tmp/pids/ and tmp/sockets/ directories
# 确保GitLab可以写入tmp/pids/和temp/sockets/目录
chmod -R u+rwX  tmp/{pids,sockets}

# Make sure GitLab can write to the public/uploads/ directory
# 确保GitLab可以写入public/uploads/目录
chmod -R u+rwX  public/uploads

# Copy the example Unicorn config
# 复制Unicorn的示例配置文件
sudo -u git -H cp config/unicorn.rb.example config/unicorn.rb

# Enable cluster mode if you expect to have a high load instance
# Ex. change amount of workers to 3 for 2GB RAM server
# 启用集群模式如果你期望拥有一个高负载实例
# 附：修改worker的数量到3用于2GB内存的服务器
sudo -u git -H editor config/unicorn.rb

# Copy the example Rack attack config
# 复制Rack attack的示例配置文件
sudo -u git -H cp config/initializers/rack_attack.rb.example config/initializers/rack_attack.rb

# Configure Git global settings for git user, useful when editing via web
# Edit user.email according to what is set in config/gitlab.yml
# 为git用户配置Git全局设定，当通过web修改时有用
# 修改user.email根据config/gitlab.yml中的设定
sudo -u git -H git config --global user.name "GitLab"
sudo -u git -H git config --global user.email "gitlab@localhost"
sudo -u git -H git config --global core.autocrlf input
</code></pre>

<h2>数据库配置</h2>

<pre><code># MySQL only:
# 仅限MySQL：
sudo -u git cp config/database.yml.mysql config/database.yml

# MySQL and remote PostgreSQL only:
# Update username/password in config/database.yml.
# You only need to adapt the production settings (first part).
# If you followed the database guide then please do as follows:
# Change 'secure password' with the value you have given to $password
# You can keep the double quotes around the password
# 仅限MySQL和远程PostgreSQL：
# 在config/database.yml中更新用户名/密码；
# 你只需要适配生产设定（第一部分）；
# 如果你跟从数据库向导，请按以下操作：
# 修改'secure password'使用你刚才设定的$password；
# 你可以保留密码两端的双引号。
sudo -u git -H editor config/database.yml

# PostgreSQL and MySQL:
# Make config/database.yml readable to git only
# PostgreSQL和MySQL：
# 设置config/database.yml仅对git可读。
sudo -u git -H chmod o-rwx config/database.yml
</code></pre>

<h3>安装 Gems</h3>

<pre><code>cd /home/git/gitlab

# For users from China mainland only
# 仅限中国大陆用户
nano /home/git/gitlab/Gemfile
source "http://ruby.taobao.org" // 原始 source "https://rubygems.org/"

# For MySQL (note, the option says "without ... postgres")
sudo -u git -H bundle install --deployment --without development test postgres aws
</code></pre>

<h2>Install GitLab shell</h2>

<h3>安装GitLab Shell</h3>

<p>GitLab Shell是一个专门为GitLab开发的SSH访问和源管理软件。</p>

<pre><code># Go to the Gitlab installation folder:
# 转到GitLab安装目录：
cd /home/git/gitlab

# For users from China mainland only
# 仅限中国大陆用户
nano /home/git/gitlab/Gemfile
source "http://ruby.taobao.org" // 原始 source "https://rubygems.org/"

# Run the installation task for gitlab-shell (replace `REDIS_URL` if needed):
# 运行gitlab-shell的安装任务（替换`REDIS_URL`如果有需要的话）：
sudo -u git -H bundle exec rake gitlab:shell:install[v1.9.6] REDIS_URL=redis://localhost:6379 RAILS_ENV=production

# By default, the gitlab-shell config is generated from your main gitlab config.
# 默认的，gitlab-shell的配置文件是由你的gitlab主配置文件生成的。
#
# Note: When using GitLab with HTTPS please change the following:
# - Provide paths to the certificates under `ca_file` and `ca_path options.
# - The `gitlab_url` option must point to the https endpoint of GitLab.
# - In case you are using self signed certificate set `self_signed_cert` to `true`.
# See #using-https for all necessary details.
# 提示：当通过HTTPS使用GitLab时，请做出如下更改：
# - 提供证书的路径在`ca_file`和`ca_path`选项；
# - `gitlab_url`选项必须指向GitLab的https端点；
# - 如果你使用自签名的证书，设置`self-signed_cert`为`true`。
# 所有必需的具体细节参见#using-https
#
# You can review (and modify) it as follows:
# 你可以检查（并修改该）通过以下方法：
sudo -u git -H editor /home/git/gitlab-shell/config.yml

# Ensure the correct SELinux contexts are set
# Read http://wiki.centos.org/HowTos/Network/SecuringSSH
# 确保正确的SELinux上下文被设置
# 阅读http://wiki.centos.org/HowTos/Network/SecuringSSH
restorecon -Rv /home/git/.ssh
</code></pre>

<h3>初始化数据库和激活高级功能</h3>

<pre><code>sudo -u git -H bundle exec rake gitlab:setup RAILS_ENV=production
# Type 'yes' to create the database tables.
# When done you see 'Administrator account created:'
</code></pre>

<p>提示：你可以设置管理员密码通过在环境变量GITLAB_ROOT_PASSWORD中提供，例如：</p>

<pre><code>sudo -u git -H bundle exec rake gitlab:setup RAILS_ENV=production GITLAB_ROOT_PASSWORD=newpassword
</code></pre>

<h3>安装初始化脚本</h3>

<p>下载初始化脚本（将放在/etc/init.d/gitlab）：</p>

<pre><code>sudo cp lib/support/init.d/gitlab /etc/init.d/gitlab
chmod +x /etc/init.d/gitlab
chkconfig --add gitlab
</code></pre>

<p>设置GitLab开机启动：</p>

<pre><code>chkconfig gitlab on
</code></pre>

<p>设置日志翻转</p>

<pre><code>cp lib/support/logrotate/gitlab /etc/logrotate.d/gitlab
</code></pre>

<h3>检查应用状态</h3>

<pre><code>sudo -u git -H bundle exec rake gitlab:env:info RAILS_ENV=production
</code></pre>

<h3>编译静态文件</h3>

<pre><code>sudo -u git -H bundle exec rake assets:precompile RAILS_ENV=production
</code></pre>

<h3>启动实例</h3>

<pre><code>/etc/init.d/gitlab start
</code></pre>

2015年五月5日上午 11:16:04
布隆过滤器 -- 空间效率很高的数据结构
<h2>哈希 hash</h2>

<h3>原理</h3>

<p>Hash （哈希，或者散列）函数在计算机领域，尤其是数据快速查找领域，加密领域用的极广。</p>

<p><strong>其作用是将一个大的数据集映射到一个小的数据集上面（这些小的数据集叫做哈希值，或者散列值）</strong>。</p>

<p>一个应用是Hash table（散列表，也叫哈希表），是根据哈希值 (Key value) 而直接进行访问的数据结构。也就是说，它通过把哈希值映射到表中一个位置来访问记录，以加快查找的速度。下面是一个典型的 hash 函数 / 表示意图：</p>

<p><img src="/img/bVlCe5" alt="图片描述"></p>

<p>哈希函数有以下两个特点：</p>

<ul>
<li>如果两个散列值是不相同的（根据同一函数），那么这两个散列值的原始输入也是不相同的。</li>
<li>散列函数的输入和输出不是唯一对应关系的，如果两个散列值相同，两个输入值很可能是相同的。但也可能不同，这种情况称为 “散列碰撞”（或者 “散列冲突”）。</li>
</ul>
<p>缺点： 引用吴军博士的《数学之美》中所言，哈希表的空间效率还是不够高。如果用哈希表存储一亿个垃圾邮件地址，每个email地址 对应 8bytes, 而哈希表的存储效率一般只有50%，因此一个email地址需要占用16bytes. 因此一亿个email地址占用1.6GB，如果存储几十亿个email address则需要上百GB的内存。除非是超级计算机，一般的服务器是无法存储的。</p>

<p>所以要引入下面的 Bloom Filter。</p>

<h2>布隆过滤器 Bloom Filter</h2>

<h3>原理</h3>

<p>如果想判断一个元素是不是在一个集合里，一般想到的是将集合中所有元素保存起来，然后通过比较确定。链表、树、散列表（又叫哈希表，Hash table）等等数据结构都是这种思路。但是随着集合中元素的增加，我们需要的存储空间越来越大。同时检索速度也越来越慢。</p>

<p>Bloom Filter 是一种空间效率很高的随机数据结构，Bloom filter 可以看做是对 bit-map 的扩展, 它的原理是：</p>

<p>当一个元素被加入集合时，通过 <code>K</code> 个 <code>Hash 函数</code>将这个元素映射成一个<code>位阵列（Bit array）中的 K 个点</code>，把它们置为 <code>1</code>。检索时，我们只要看看这些点是不是都是 1 就（大约）知道集合中有没有它了：</p>

<ul>
<li>如果这些点有任何一个 0，则被检索元素<strong>一定不在</strong>；</li>
<li>如果都是 1，则被检索元素<strong>很可能</strong>在。</li>
</ul>
<h3>优点</h3>

<blockquote>
  <p>It tells us that the element either definitely is not in the set or may be in the set.</p>
</blockquote>

<p>它的优点是<code>空间效率</code>和<code>查询时间</code>都远远超过一般的算法，布隆过滤器存储空间和插入 / 查询时间都是常数<code>O(k)</code>。另外, 散列函数相互之间没有关系，方便由硬件并行实现。布隆过滤器不需要存储元素本身，在某些对保密要求非常严格的场合有优势。</p>

<h3>缺点</h3>

<p>但是布隆过滤器的缺点和优点一样明显。误算率是其中之一。随着存入的元素数量增加，<code>误算率</code>随之增加。但是如果元素数量太少，则使用散列表足矣。</p>

<p>(误判补救方法是：再建立一个小的白名单，存储那些可能被误判的信息。)</p>

<p>另外，一般情况下不能从布隆过滤器中<code>删除</code>元素. 我们很容易想到把位数组变成整数数组，每插入一个元素相应的计数器加 1, 这样删除元素时将计数器减掉就可以了。然而要保证安全地删除元素并非如此简单。首先我们必须保证删除的元素的确在布隆过滤器里面. 这一点单凭这个过滤器是无法保证的。另外计数器回绕也会造成问题。</p>

<h3>Example</h3>

<p>可以快速且空间效率高的判断一个元素是否属于一个集合；用来实现数据字典，或者集合求交集。</p>

<p>如： Google chrome 浏览器使用bloom filter识别恶意链接（能够用较少的存储空间表示较大的数据集合，简单的想就是把每一个URL都可以映射成为一个bit）<br>
得多，并且误判率在万分之一以下。<br>
又如： 检测垃圾邮件</p>

<pre><code>假定我们存储一亿个电子邮件地址，我们先建立一个十六亿二进制（比特），即两亿字节的向量，然后将这十六亿个二进制全部设置为零。对于每一个电子邮件地址 X，我们用八个不同的随机数产生器（F1,F2, ...,F8） 产生八个信息指纹（f1, f2, ..., f8）。再用一个随机数产生器 G 把这八个信息指纹映射到 1 到十六亿中的八个自然数 g1, g2, ...,g8。现在我们把这八个位置的二进制全部设置为一。当我们对这一亿个 email 地址都进行这样的处理后。一个针对这些 email 地址的布隆过滤器就建成了。
</code></pre>

<p>再如此题：</p>

<pre><code>A,B 两个文件，各存放 50 亿条 URL，每条 URL 占用 64 字节，内存限制是 4G，让你找出 A,B 文件共同的 URL。如果是三个乃至 n 个文件呢？

分析 ：如果允许有一定的错误率，可以使用 Bloom filter，4G 内存大概可以表示 340 亿 bit。将其中一个文件中的 url 使用 Bloom filter 映射为这 340 亿 bit，然后挨个读取另外一个文件的 url，检查是否与 Bloom filter，如果是，那么该 url 应该是共同的 url（注意会有一定的错误率）。”
</code></pre>

<p><a rel="nofollow" href="http://citeseer.ist.psu.edu/viewdoc/download;jsessionid=6CA79DD1A90B3EFD3D62ACE5523B99E7?doi=10.1.1.127.9672&amp;rep=rep1&amp;type=pdf">Network applications of Bloom Filter: a survey</a></p>

2015年五月5日上午 11:05:30
node.js通过get访问该网址，返回302？
<div class="markdown-text"><p>网址：<a href="http://search.jd.com/Search?keyword=%E7%AC%94%E8%AE%B0%E6%9C%AC&amp;enc=utf-8">http://search.jd.com/Search?keyword=%E7%AC%94%E8%AE%B0%E6%9C%AC&amp;enc=utf-8</a>
该网址是京东搜索笔记本的url；</p>
</div>

2015年五月5日上午 10:52:28
alsotang starred coocood/freecache
<!-- watch -->
<div class="simple">
  <span class="octicon octicon-star"></span>

  <div class="title">
    <a href="https://github.com/alsotang" data-ga-click="News feed, event click, Event click type:WatchEvent target:actor">alsotang</a> <span>starred</span> <a href="https://github.com/coocood/freecache" data-ga-click="News feed, event click, Event click type:WatchEvent target:repo">coocood/freecache</a>
  </div>

  <div class="time">
    <time datetime="2015-05-05T02:52:28Z" is="relative-time">May 5, 2015</time>
  </div>
</div>

2015年五月5日早上 7:55:36
命令行模式下的思维导图：mindmap
<div class="markdown-text"><h3>安装：</h3>
<p>npm install mindmap</p>
<h3>截图：</h3>
<p><img src="http://i.imgur.com/gEZsVCW.png" alt="screenshot"></p>
<h3>用法：</h3>
<pre class="prettyprint"><code>  load [mindmap name] or l [mindmap name]
    Load or create a mindmap.
  add [id] [text] or a [id] [text]
    Add a child.
  insert [id] [text] or i [id] [text]
    Insert a node.
        insert -1 Animal
        insert 10 White house
  edit [id] [text] or e [id] [text]
    Edit a node.
  delete [id] or del [id] or d [id]
    Delete a node.
  help or h
    Help information.
  exit
    Exit program.
</code></pre></div>

2015年五月4日晚上 11:57:41
请教这段代码cluster worker和net模块一起使用为何会出现阻塞？
<div class="markdown-text"><p>很神奇的是，在master里直接调用socketHandler的话ab测试下不会阻塞</p>
<p>在worker里调用，ab测试并发数为1的时候不会阻塞</p>
<p>但像下面这样写，ab测试</p>
<pre class="prettyprint"><code>ab -n 10 -c 2 http://localhost:10086
</code></pre><p>请求直接就阻塞了。。。</p>
<pre class="prettyprint"><code>var net = require(&#x27;net&#x27;);
var http = require(&#x27;http&#x27;);
var cluster = require(&#x27;cluster&#x27;);

var recevice_socket_count = 0;
var recevice_http_count = 0;

var httpServer = http.createServer(function(req,res){
    console.log(&#x27;recevice_http_count&#x27;,++recevice_http_count);
    res.write(&#x27;wow&#x27;);
    res.end();
});

function socketHandler(socket){
  console.log(&#x27;recevice_socket_count&#x27;,++recevice_socket_count);
  socket.readable = socket.writeable = true;
  httpServer.emit(&#x27;connection&#x27;,socket);
  socket.emit(&#x27;connect&#x27;);
}


if(cluster.isMaster){
  var worker = cluster.fork();
  net.createServer(function(socket){
    worker.send(&quot;socket&quot;, socket);
    //socketHandler(socket);
  }).listen(10086, function() {
    console.log(&#x27;netServer bound&#x27;);
  });
}else{

  cluster.worker.on(&quot;message&quot;, function(data, socket) {
        socketHandler(socket);
  });
}

</code></pre></div>

2015年五月4日晚上 10:43:37
做了个模板引擎 nging
<div class="markdown-text"><h3>安装：</h3>
<p>npm install nging</p>
<h3>用法：</h3>
<pre class="prettyprint language-js"><code>var app = require(&quot;express&quot;)();
var nging = require(&quot;nging&quot;);
 
function Comment() {
    this.jml = function() {
        return [&quot;div&quot;,{className:&quot;comment&quot;},
                    [&quot;h2&quot;,{className:&quot;commentAuthor&quot;, style:this.props.style},
                        this.props.author
                    ]
               ].concat(this.props.nodes);
    };
}
 
function CommentList() {
    this.jml = function() {
        var commentNodes = this.props.data.map(function (comment) {
          return [Comment, {author:comment.author}, comment.text];
        });
 
        return [&quot;div&quot;, {className:&quot;commentList&quot;}].concat(commentNodes);
    };
}
 
var comments = [
  {&quot;author&quot;: &quot;Pete Hunt&quot;, &quot;text&quot;: &quot;This is one comment&quot;},
  {&quot;author&quot;: &quot;Jordan Walke&quot;, &quot;text&quot;: &quot;This is *another* comment&quot;}
];
 
var jml1 = [&quot;div&quot;,{class:&quot;yes&quot;},[&quot;p&quot;,{style:&quot;color:red&quot;},&quot;Hello!!!&quot;,[&quot;img&quot;,{src:&quot;http://i.imgur.com/gEZsVCW.png&quot;,width:500}]]];
var jml2 = [&quot;html&quot;,[&quot;body&quot;,[&quot;div&quot;,&quot;dfe&quot;],[&quot;span&quot;,&quot;ddd&quot;]]];
 
var jml3 = [Comment, {author:&quot;John&quot;, style:&quot;color:red&quot;}, &quot;Hello!&quot;];
 
var jml4 = [&quot;html&quot;,jml3,jml3,jml3,jml3,jml3,jml3,jml3];
 
var jml5 =[&quot;form&quot;,{className:&quot;commentForm&quot;, onSubmit:&quot;this.handleSubmit&quot;},
            [&quot;input&quot;, {type:&quot;text&quot;, placeholder:&quot;Your name&quot;, ref:&quot;author&quot;}],
            [&quot;input&quot;, {type:&quot;text&quot;, placeholder:&quot;Say something...&quot;, ref:&quot;text&quot;}],
            [&quot;input&quot;, {type:&quot;submit&quot;, value:&quot;Post&quot;}]
        ];
 
var jml6 =[CommentList, {data:comments}];
 
var jml7 = [&quot;html&quot;, jml1,jml2,jml3,jml4,jml5];
 
app.get(&quot;/&quot;, function(req, res) {
    res.send(nging.render(jml7));
});
 
app.listen(8080);

</code></pre></div>

2015年五月4日晚上 10:27:23
请问有什么分析日志的好的方法或者工具么？
<div class="markdown-text"><p>比如在我的node服务里，我把每一个请求完成的响应时间都写在了本地的log文件里，我想统计所有请求的平均响应时间，是不是只能靠编写复杂的shell脚本来实现？另外关于日志文件，有什么好的管理方法么？比如定期清理过时的日志文件应该怎么做呢？</p>
</div>

2015年五月4日晚上 9:53:45
[译] Python 学习 —— __init__() 方法 2
<h3><strong>通过工厂函数对 <code>__init__()</code> 加以利用</strong></h3>

<p>我们可以通过工厂函数来构建一副完整的扑克牌。这会比枚举所有52张扑克牌要好得多，在Python中，我们有如下两种常见的工厂方法：</p>

<ul>
<li><p>定义一个函数，该函数会创建所需类的对象。</p></li>
<li><p>定义一个类，该类有创建对象的方法。这是一个完整的工厂设计模式，正如设计模式书所描述的那样。在诸如Java这样的语言中，工厂类层次结构是必须的，因为该语言不支持独立的函数。</p></li>
</ul>
<p>在Python中，类并不是<em>必须</em>的。只是当有相关的工厂非常复杂的时候才会显现出优势。Python的优势就是当一个简单的函数可以做的更好的时候我们决不强迫使用类层次结构。</p>

<blockquote>
  <p>虽然这是一本关于面向对象编程的书，但函数真是一个好东西。这在Python中是常见的也是最地道的。</p>
</blockquote>

<p>如果需要的话，我们总是可以将一个函数重写为适当的可调用对象。我们可以将一个可调用对象重构到我们的工厂类层次结构中。我们将在第五章《使用可调用对象和上下文》中学习可调用对象。</p>

<p>一般，类定义的优点是通过继承实现代码重用。工厂类的函数就是包装一些目标类层次结构和复杂对象的构造。如果我们有一个工厂类，当扩展目标类层次结构的时候，我们可以添加子类到工厂类中。这给我们提供了多态性工厂类；不同的工厂类定义具有相同的方法签名，可以交替使用。</p>

<p>这类水平的多态性对于静态编译语言如Java或C++非常有用。编译器可以解决类和方法生成代码的细节。</p>

<p>如果选择的工厂定义不能重用任何代码，则在Python中类层次结构不会有任何帮助。我们可以简单的使用具有相同签名的函数。</p>

<p>以下是我们各种<code>Card</code>子类的工厂函数：</p>

<pre><code>python</code><code>def card(rank, suit):
    if rank == 1:
        return AceCard('A', suit)
    elif 2 &lt;= rank &lt; 11: 
        return NumberCard(str(rank), suit)

    elif 11 &lt;= rank &lt; 14:
        name = {11: 'J', 12: 'Q', 13: 'K' }[rank]
        return FaceCard(name, suit)
    else:
        raise Exception("Rank out of range")
</code></pre>

<p>这个函数通过数值类型的<code>rank</code>和<code>suit</code>对象构建<code>Card</code>类。我们现在可以非常简单的构建牌了。我们已经封装构造问题到一个单一的工厂函数中，允许应用程序在不知道精确的类层次结构和多态设计是如何工作的情况下进行构建。</p>

<p>下面是一个如何通过这个工厂函数构建一副牌的示例：</p>

<pre><code>python</code><code>deck = [card(rank, suit) for rank in range(1,14) for suit in (Club, Diamond, Heart, Spade)]
</code></pre>

<p>它枚举了所有的牌值和花色来创建完整的52张牌。</p>

<h4><strong>1. 错误的工厂设计和模糊的else子句</strong></h4>

<p>注意<code>card()</code>函数里面的<code>if</code>语句结构。我们没有使用“包罗万象”的<code>else</code>子句来做任何处理；我们只是抛出异常。使用“包罗万象”的<code>else</code>子句会引出一个小小的辩论。</p>

<p>一方面，从属于<code>else</code>子句的条件不能不言而喻，因为它可能隐藏着微妙的设计错误。另一方面，一些<code>else</code>子句确实是显而易见的。</p>

<p>重要的是要避免含糊的<code>else</code>子句。</p>

<p>考虑下面工厂函数定义的变体：</p>

<pre><code>python</code><code>def card2(rank, suit):
    if rank == 1: 
        return AceCard('A', suit)
    elif 2 &lt;= rank &lt; 11: 
        return NumberCard(str(rank), suit)
    else:
        name = {11: 'J', 12: 'Q', 13: 'K'}[rank]
        return FaceCard(name, suit)
</code></pre>

<p>以下是当我们尝试创建整副牌将会发生的事情：</p>

<pre><code>python</code><code>deck2 = [card2(rank, suit) for rank in range(13) for suit in (Club, Diamond, Heart, Spade)]
</code></pre>

<p>它起作用了吗？如果<code>if</code>条件更复杂了呢？</p>

<p>一些程序员扫视的时候可以理解这个<code>if</code>语句。其他人将难以确定是否所有情况都正确执行了。</p>

<p>对于高级Python编程，我们不应该把它留给读者去演绎条件是否适用于<code>else</code>子句。对于菜鸟条件应该是显而易见的，至少也应该是显示的。</p>

<p><strong>何时使用“包罗万象”的else</strong></p>

<p>尽量的少使用。使用它只有当条件是显而易见的时候。当有疑问时，显式的并抛出异常。</p>

<p>避免含糊的<code>else</code>子句。</p>

<h4><strong>2. 简单一致的使用elif序列</strong></h4>

<p>我们的工厂函数<code>card()</code>是两种常见工厂设计模式的混合物:</p>

<ul>
<li><p><code>if-elif</code>序列</p></li>
<li><p>映射</p></li>
</ul>
<p>为了简单起见，最好是专注于这些技术的一个而不是两个。</p>

<p>我们总是可以用映射来代替<code>elif</code>条件。（是的，总是。但相反是不正确的；改变<code>elif</code>条件为映射将是具有挑战性的。）</p>

<p>以下是没有映射的<code>Card</code>工厂：</p>

<pre><code>python</code><code>def card3(rank, suit):
    if rank == 1: 
        return AceCard('A', suit)
    elif 2 &lt;= rank &lt; 11: 
        return NumberCard(str(rank), suit)
    elif rank == 11:
        return FaceCard('J', suit)
    elif rank == 12:
        return FaceCard('Q', suit)
    elif rank == 13:
        return FaceCard('K', suit)
    else:
        raise Exception("Rank out of range")
</code></pre>

<p>我们重写了<code>card()</code>工厂函数。映射已经转化为额外的<code>elif</code>子句。这个函数有个优点就是它比之前的版本更加一致。</p>

<h4><strong>3. 简单的使用映射和类对象</strong></h4>

<p>在一些示例中，我们可以使用映射来代替一连串的<code>elif</code>条件。很可能发现条件太复杂，这个时候或许只有使用一连串的<code>elif</code>条件来表达才是明智的选择。对于简单示例，无论如何，映射可以做的更好且可读性更强。</p>

<p>因为<code>class</code>是最好的对象，我们可以很容易的映射<code>rank</code>参数到已经构造好的类中。</p>

<p>以下是仅使用映射的<code>Card</code>工厂：</p>

<pre><code>python</code><code> def card4(rank, suit):
    class_= {1: AceCard, 11: FaceCard, 12: FaceCard, 13: FaceCard}.get(rank, NumberCard)
    return class_(rank, suit)
</code></pre>

<p>我们已经映射<code>rank</code>对象到类中。然后，我们传递<code>rank</code>值和<code>suit</code>值到类来创建最终的<code>Card</code>实例。</p>

<p>最好我们使用<code>defaultdict</code>类。无论如何，对于微不足道的静态映射不会比这更简单了。看起来像下面代码片段那样：</p>

<pre><code>python</code><code>defaultdict(lambda: NumberCard, {1: AceCard, 11: FaceCard, 12: FaceCard, 12: FaceCard})
</code></pre>

<p>注意：<code>defaultdict</code>类<em>默认</em>必须是零参数的函数。我们已经使用了<code>lambda</code>创建必要的函数来封装常量。这个函数，无论如何，都有一些缺陷。对于我们之前版本中缺少<code>1</code>到<code>A</code>和<code>13</code>到<code>K</code>的转换。当我们试图增加这些特性时，一定会出现问题的。</p>

<p>我们需要修改映射来提供可以和字符串版本的<code>rank</code>对象一样的<code>Card</code>子类。对于这两部分的映射我们还可以做什么？有四种常见解决方案：</p>

<ul>
<li>可以做两个并行的映射。我们不建议这样，但是会强调展示不可取的地方。</li>
<li>可以映射个二元组。这个同样也会有一些缺点。</li>
<li>可以映射到<code>partial()</code>函数。<code>partial()</code>函数是<code>functools</code>模块的一个特性。</li>
<li>可以考虑修改我们的类定义，这种映射更容易。可以在下一节将<code>__init__()</code>置入子类定义中看到。</li>
</ul>
<p>我们来看看每一个具体的例子。</p>

<h5><strong>3.1. 两个并行映射</strong></h5>

<p>以下是两个并行映射解决方案的关键代码：</p>

<pre><code>python</code><code>class_= {1: AceCard, 11: FaceCard, 12: FaceCard, 13: FaceCard}.get(rank, NumberCard)
rank_str= {1:'A', 11:'J', 12:'Q', 13:'K'}.get(rank, str(rank))
return class_(rank_str, suit)
</code></pre>

<p>这并不可取的。它涉及到重复映射键<code>1</code>、<code>11</code>、<code>12</code>和<code>13</code>序列。重复是糟糕的，因为在软件更新后并行结构依然保持这种方式。</p>

<p><strong>不要使用并行结构</strong></p>

<p>并行结构必须使用元组或一些其他合适的集合来替代。</p>

<h5><strong>3.2. 映射到元组的值</strong></h5>

<p>以下是二元组映射的关键代码：</p>

<pre><code>python</code><code>class_, rank_str= {
    1: (AceCard,'A'),
    11: (FaceCard,'J'),
    12: (FaceCard,'Q'),
    13: (FaceCard,'K'),
}.get(rank, (NumberCard, str(rank)))
return class_(rank_str, suit)
</code></pre>

<p>这是相当不错的。不需要过多的代码来分类打牌中的特殊情况。当我们需要改变<code>Card</code>类层次结构来添加额外的<code>Card</code>子类时，我们将看到它如何被修改或被扩展。</p>

<p>将<code>rank</code>值映射到一个类对象的确让人感觉奇怪，且只有类初始化所需两个参数中的其中之一。将牌值映射到一个简单的类或没有提供一些混乱参数(但不是所有)的函数对象似乎会更合理。</p>

<h5><strong>3.3. partial函数解决方案</strong></h5>

<p>相比映射到二元组函数和参数之一，我们可以创建一个<code>partial()</code>函数。这是一个已经提供一些(但不是所有)参数的函数。我们将从<code>functools</code>库中使用<code>partial()</code>函数来创建一个带有<code>rank</code>参数的partial类。</p>

<p>以下是一个映射<code>rank</code>到<code>partial()</code>函数，可用于对象创建：</p>

<pre><code>python</code><code>from functools import partial
part_class= {
   1: partial(AceCard, 'A'),
   11: partial(FaceCard, 'J'),
   12: partial(FaceCard, 'Q'),
   13: partial(FaceCard, 'K'),
}.get(rank, partial(NumberCard, str(rank)))
return part_class(suit)
</code></pre>

<p>映射将<code>rank</code>对象与<code>partial()</code>函数联系在一起，并分配给<code>part_class</code>。这个<code>partial</code>()函数可以被应用到<code>suit</code>对象来创建最终的对象。<code>partial()</code>函数是一种常见的函数式编程技术。它在我们有一个函数来替代对象方法这一特定的情况下使用。</p>

<p>不过总体而言，<code>partial()</code>函数对于大多数面向对象编程并没有什么帮助。相比创建<code>partial()</code>函数，我们可以简单地更新类的方法来接受不同组合的参数。<code>partial()</code>函数类似于给对象构造创建一个连贯的接口。</p>

<h5><strong>3.4. 连贯的工厂类接口</strong></h5>

<p>在某些情况下，我们设计的类为方法的使用定义了顺序，衡量方法的顺序很像<code>partial()</code>函数。</p>

<p>在一个对象表示法中我们可能会有<code>x.a() .b()</code>。我们可以把它当成<code>x(a, b)</code>。<code>x.a()</code>函数是等待<code>b()</code>的一类<code>partial()</code>函数。我们可以认为它就像<code>x(a)(b)</code>那样。</p>

<p>这里的想法是，Python给我们提供两种选择来管理状态。我们既可以更新对象又可以创建有状态性的（在某种程度上）<code>partial()</code>函数。由于这种等价，我们可以重写<code>partial()</code>函数到一个连贯的工厂对象中。我们使得<code>rank</code>对象的设置为一个连贯的方法来返回<code>self</code>。设置<code>suit</code>对象将真实的创建<code>Card</code>实例。</p>

<p>以下是一个连贯的<code>Card</code>工厂类，有两个方法函数，必须在特定顺序中使用：</p>

<pre><code>python</code><code>class CardFactory:
    def rank(self, rank):
        self.class_, self.rank_str= {
                1: (AceCard, 'A'),
                11: (FaceCard,'J'),
                12: (FaceCard,'Q'),
                13: (FaceCard,'K'),
        }.get(rank, (NumberCard, str(rank)))
        return self
    def suit(self, suit):
        return self.class_(self.rank_str, suit)
</code></pre>

<p><code>rank()</code>方法更新构造函数的状态，<code>suit()</code>方法真实的创建了最终的<code>Card</code>对象。</p>

<p>这个工厂类可以像下面这样使用：</p>

<pre><code>python</code><code>card8 = CardFactory()
deck8 = [card8.rank(r+1).suit(s) for r in range(13) for s in (Club, Diamond, Heart, Spade)]
</code></pre>

<p>首先，我们创建一个工厂实例，然后我们使用那个实例创建<code>Card</code>实例。这并没有实质性改变<code>__init__()</code>本身在<code>Card</code>类层次结构中如何运作的。然而，它确实改变了我们客户端应用程序创建对象的方式。</p>

2015年五月4日晚上 9:39:35
关于 this 的四类用法
<h2>this</h2>

<p>在函数执行时，this 总是指向调用该函数的对象。要判断 this 的指向，其实就是判断 this 所在的函数属于谁。</p>

<p>在《javaScript语言精粹》这本书中，把 this 出现的场景分为四类，简单的说就是：</p>

<ul>
<li>有对象就指向调用对象</li>
<li>没调用对象就指向全局对象</li>
<li>用new构造就指向新对象</li>
<li>通过 apply 或 call 或 bind 来改变 this 的所指。</li>
</ul>
<h3>1) 函数有所属对象时：指向所属对象</h3>

<p>函数有所属对象时，通常通过 <code>.</code> 表达式调用，这时 <code>this</code> 自然指向所属对象。比如下面的例子：</p>

<pre><code>js</code><code>var myObject = {value: 100};
myObject.getValue = function () {
  console.log(this.value);  // 输出 100

  // 输出 { value: 100, getValue: [Function] }，
  // 其实就是 myObject 对象本身
  console.log(this);

  return this.value;
};

console.log(myObject.getValue()); // =&gt; 100
</code></pre>

<p><code>getValue()</code> 属于对象 <code>myObject</code>，并由 <code>myOjbect</code> 进行 <code>.</code> 调用，因此 <code>this</code> 指向对象 <code>myObject</code>。</p>

<h3>2) 函数没有所属对象：指向全局对象</h3>

<pre><code>js</code><code>var myObject = {value: 100};
myObject.getValue = function () {
  var foo = function () {
    console.log(this.value) // =&gt; undefined
    console.log(this);// 输出全局对象 global
  };

  foo();

  return this.value;
};

console.log(myObject.getValue()); // =&gt; 100
</code></pre>

<p>在上述代码块中，<code>foo</code> 函数虽然定义在 <code>getValue</code> 的函数体内，但实际上它既不属于 <code>getValue</code> 也不属于 <code>myObject</code>。<code>foo</code> 并没有被绑定在任何对象上，所以当调用时，它的 <code>this</code> 指针指向了全局对象 <code>global</code>。</p>

<p>据说这是个设计错误。</p>

<h3>3) 构造器中的 this：指向新对象</h3>

<p>js 中，我们通过 <code>new</code> 关键词来调用构造函数，此时 this 会绑定在该新对象上。</p>

<pre><code>js</code><code><br>var SomeClass = function(){
  this.value = 100;
}

var myCreate = new SomeClass();

console.log(myCreate.value); // 输出100
</code></pre>

<p>顺便说一句，在 js 中，构造函数、普通函数、对象方法、闭包，这四者没有明确界线。界线都在人的心中。</p>

<h3>4) apply 和 call 调用以及 bind 绑定：指向绑定的对象</h3>

<p>apply() 方法接受两个参数第一个是函数运行的作用域，另外一个是一个参数数组(arguments)。</p>

<p>call() 方法第一个参数的意义与 apply() 方法相同，只是其他的参数需要一个个列举出来。</p>

<p>简单来说，call 的方式更接近我们平时调用函数，而 apply 需要我们传递 Array 形式的数组给它。它们是可以互相转换的。</p>

<pre><code>js</code><code>var myObject = {value: 100};

var foo = function(){
  console.log(this);
};

foo(); // 全局变量 global
foo.apply(myObject); // { value: 100 }
foo.call(myObject); // { value: 100 }

var newFoo = foo.bind(myObject);
newFoo(); // { value: 100 }
</code></pre>

2015年五月4日晚上 9:09:16
alsotang commented on commit cnodejs/nodeclub@67c098202b
<!-- commit_comment -->
<span class="mega-octicon octicon-comment-discussion"></span>

<div class="time">
  <time datetime="2015-05-04T13:09:16Z" is="relative-time">May 4, 2015</time>
</div>

<div class="title">
  <a href="https://github.com/alsotang" data-ga-click="News feed, event click, Event click type:CommitCommentEvent target:actor">alsotang</a> <span>commented</span> on commit <a href="https://github.com/cnodejs/nodeclub/commit/67c098202b0de23d790ecd4486307dbe62be916b#commitcomment-11024911" data-ga-click="News feed, event click, Event click type:CommitCommentEvent target:commit-comment">cnodejs/nodeclub@67c098202b</a>
</div>

<div class="details">
  <a href="https://github.com/alsotang"><img alt="@alsotang" class="gravatar" data-user="1147375" height="30" src="https://avatars0.githubusercontent.com/u/1147375?v=3&amp;s=60" width="30" /></a>
  <div class="message markdown-body">
    <blockquote>
      <p>无论mongodb还是redis都有自动过期的策略，session 不会一直存 在 2015年5月4日 下午8:11，yanjixiong &lt;notifications@github.com&gt;写道：
</p>
    </blockquote>
  </div>
</div>

2015年五月4日晚上 7:04:20
哪位大大能帮我看下，为啥BAE里我用mongoose close了db，然后重新open就 报错了
<div class="markdown-text"><p>报错为：  name: 'MongoError’,
message: ‘only GSSAPI, PLAIN, MONGODB-X509, SCRAM-SHA-1 or MONGODB-CR is supported by authMechanism’</p>
<p>代码:var mongoose = require(‘mongoose’);
var format = require(‘util’).format;</p>
<p>if(process.env.BAE_ENV_APPID){<br>
var host =&quot;mongo.duapp.com&quot;;
var port =&quot;8908&quot;;
var username =&quot;bfc5c2ab184a479292b3fd20b012a683&quot;;
var password =&quot;d1b72bc45df94eb4b05a4ffc9f0416af&quot;;
var dbName =&quot;aJZfHIoouaDARdxxYghA&quot;;
var constr =&quot;mongodb://&quot;+ username +&quot;:&quot;+ password +&quot;@&quot;+ host +&quot;:&quot;+ port +&quot;/&quot;+ dbName;
}else{
var constr = “<a href>mongodb://localhost/ticket</a>”
var username =null;
var password =null;</p>
<pre class="prettyprint"><code>}
</code></pre><p>//constr = &quot;<a href>mongodb://localhost/ticket</a>&quot;;</p>
<p>var options = {
db: { native_parser: true },
server: {
poolSize:4,
socketOptions: {
keepAlive: 1
}
},
user: username,
pass: password
};
db = mongoose.createConnection();
var userSchema = new mongoose.Schema({
name:String,
password:String},{
collection : ‘users’
});</p>
<p>db.open(constr,options);
var userModel = db.model('users’,userSchema);</p>
<p>function User(user){
this.name = user.name;
this.password = user.password;
}
setInterval(function(){console.log(‘closing db now’);db.close();}, 1000<em>60</em>1);
setInterval(function(){console.log(‘opening db now’);db.open(constr,options,function(err) {
if(err){console.log(err);}
});}, 1010<em>60</em>1);</p>
<p>db.on('open’,function(){
console.log('connection success open’+’mongooseConnection.readyState :’+db.readyState );</p>
<pre class="prettyprint"><code>    //setTimeout(function(){console.log(&#x27;closing db now&#x27;);mongoose.disconnect();}, 1000*60*4);
});
</code></pre><p>db.on('close’,function(err){
console.log(‘closed’);</p>
<p>});</p>
</div>

2015年五月4日晚上 6:30:53
alsotang commented on commit cnodejs/nodeclub@67c098202b
<!-- commit_comment -->
<span class="mega-octicon octicon-comment-discussion"></span>

<div class="time">
  <time datetime="2015-05-04T10:30:53Z" is="relative-time">May 4, 2015</time>
</div>

<div class="title">
  <a href="https://github.com/alsotang" data-ga-click="News feed, event click, Event click type:CommitCommentEvent target:actor">alsotang</a> <span>commented</span> on commit <a href="https://github.com/cnodejs/nodeclub/commit/67c098202b0de23d790ecd4486307dbe62be916b#commitcomment-11023204" data-ga-click="News feed, event click, Event click type:CommitCommentEvent target:commit-comment">cnodejs/nodeclub@67c098202b</a>
</div>

<div class="details">
  <a href="https://github.com/alsotang"><img alt="@alsotang" class="gravatar" data-user="1147375" height="30" src="https://avatars0.githubusercontent.com/u/1147375?v=3&amp;s=60" width="30" /></a>
  <div class="message markdown-body">
    <blockquote>
      <p>yanjixiong，看这里 <a href="https://github.com/cnodejs/nodeclub/issues/421">https://github.com/cnodejs/nodeclub/issues/421</a> redis 快 2015-05-04 13:02 GMT+08:00 yanjixiong &lt;notifications@github.com&gt;:
</p>
    </blockquote>
  </div>
</div>

2015年五月4日下午 4:23:13
如何查看cluster开启多多少个之进程？
<div class="markdown-text"><p>//fork：复制一个工作进程后触发该事件。
cluster.on(‘fork’, function (worker) {
console.log( '[master] fork: worker’ + worker.id +&quot; start&quot;);
console.log( cluster.workers.length );
});
为何每次都是undefine？应该如何查看cluster开启了多少个子进程？</p>
</div>

2015年五月4日下午 4:10:51
npm 卸载的包还可以恢复吗？
<div class="markdown-text"><p>安装了一个全局包，然后直接在源码上修改了些东西，结果手贱不小心卸载（npm uninstall）了，请问还有什么方法可以恢复这个包吗？</p>
</div>

2015年五月4日下午 4:07:07
Mongoose 使用 Population 填充'关联表'数据
<p><a rel="nofollow" href="http://mongoosejs.com/index.html">Mongoose</a> 是 <a rel="nofollow" href="http://www.mongodb.org/">MongoDB</a> 的 <strong>ODM(Object Document Mapper)</strong>。</p>

<blockquote>
  <ul>
<li>什么是<strong>ODM</strong>? 其实和<strong>ORM(Object Relational Mapper)</strong>是同类型的工具。都是将数据库的数据转化为代码对象的库，使用转化后的对象可以直接对数据库的数据进行<strong><em>CRUD(增删改查)</em></strong>。</li>
  <li>
<code>MongoDB</code> 是文档型数据库(Document Database)，不是关系型数据库(Relational Database)。而<code>Mongoose</code>可以将 <strong>MongonDB</strong> 数据库存储的文档(documents)转化为 javascript 对象，然后可以直接进行数据的增删改查。</li>
  </ul>
</blockquote>



<p>因为<code>MongoDB</code>是文档型数据库，所以它没有关系型数据库[<code>joins</code>](<a rel="nofollow" href="http://zh.wikipedia.org/wiki/%E8%BF%9E%E6%8E%A5_(SQL)">http://zh.wikipedia.org/wiki/%E8%BF%9E%E6%8E%A5_(SQL)</a>(数据库的两张表通过"外键"，建立连接关系。) 特性。也就是在建立数据的关联时会比较麻烦。为了解决这个问题，<code>Mongoose</code>封装了一个<a rel="nofollow" href="http://mongoosejs.com/docs/populate.html"><code>Population</code></a>功能。使用<code>Population</code>可以实现在一个 <strong>document</strong> 中填充其他 <strong>collection(s)</strong> 的 <strong>document(s)</strong>。</p>

<p>在定义<code>Schema</code>的时候，如果设置某个 field 关联另一个<code>Schema</code>，那么在获取 document 的时候就可以使用 Population 功能通过关联<code>Schema</code>的 field 找到关联的另一个 document，并且用被关联 document 的内容替换掉原来关联字段(field)的内容。</p>

<h2>接下来分享下:<code>Query#populate</code> <code>Model#populate</code> <code>Document#populate</code>的用法</h2>

<p><strong><em>先建立三个<code>Schema</code>和<code>Model</code>:</em></strong></p>

<pre><code>javascript</code><code>var mongoose = require('mongoose');
var Schema   = mongoose.Schema;

var UserSchema = new Schema({
    name  : { type: String, unique: true },
    posts : [{ type: Schema.Types.ObjectId, ref: 'Post' }]
});
var User = mongoose.model('User', UserSchema);

var PostSchema = new Schema({
    poster   : { type: Schema.Types.ObjectId, ref: 'User' },
    comments : [{ type: Schema.Types.ObjectId, ref: 'Comment' }],
    title    : String,
    content  : String
});
var Post = mongoose.model('Post', PostSchema);

var CommentSchema = new Schema({
    post      : { type: Schema.Types.ObjectId, ref: "Post" },
    commenter : { type: Schema.Types.ObjectId, ref: 'User' },
    content   : String
});
var Comment = mongoose.model('Comment', CommentSchema);

</code></pre>

<ul>
<li>在上述的例子中，创建了三个 Models:<code>User</code>，<code>Post</code>，<code>Comment</code>。</li>
<li>
<code>User</code> 的属性 <strong><em>posts</em></strong>，对应是一个 <strong><em>ObjectId</em></strong> 的数组。<code>ref</code>表示关联<code>Post</code>(注意: 被关联的<strong><em>model</em></strong>的 type 必须是 <code>ObjectId, Number, String, 和 Buffer</code> 才有效)。</li>
<li>
<code>Post</code>的属性 <strong><em>poster</em></strong> 和 <strong><em>comments</em></strong> 分别关联<code>User</code>和<code>Comment</code>。</li>
<li>
<code>Comment</code>的属性 <strong><em>post</em></strong> 和 <strong><em>commenter</em></strong> 分别关联<code>Post</code>和<code>User</code>。</li>
<li>三个 Models 的关系:一个 user--<strong>has many</strong>--&gt;post。一个 post--<strong>has one</strong>--&gt;user，<strong>has many</strong>--&gt;comment。一个 comment--<strong>has one</strong>--&gt;post 和 user。</li>
</ul>
<p><strong><em>创建一些数据到数据库:</em></strong></p>

<pre><code>javascript</code><code>// 连接数据库
mongoose.connect('mongodb://localhost/population-test', function (err){
    if (err) throw err;
    createData();
});

function createData() {

    var userIds    = [new ObjectId, new ObjectId, new ObjectId];
    var postIds    = [new ObjectId, new ObjectId, new ObjectId];
    var commentIds = [new ObjectId, new ObjectId, new ObjectId];

    var users    = [];
    var posts    = [];
    var comments = [];

    users.push({
        _id   : userIds[0],
        name  : 'aikin',
        posts : [postIds[0]]
    });
    users.push({
        _id   : userIds[1],
        name  : 'luna',
        posts : [postIds[1]]
    });
    users.push({
        _id   : userIds[2],
        name  : 'luajin',
        posts : [postIds[2]]
    });

    posts.push({
        _id      : postIds[0],
        title    : 'post-by-aikin',
        poster   : userIds[0],
        comments : [commentIds[0]]
    });
    posts.push({
        _id      : postIds[1],
        title    : 'post-by-luna',
        poster   : userIds[1],
        comments : [commentIds[1]]
    });
    posts.push({
        _id      : postIds[2],
        title    : 'post-by-luajin',
        poster   : userIds[2],
        comments : [commentIds[2]]
    });

    comments.push({
        _id       : commentIds[0],
        content   : 'comment-by-luna',
        commenter : userIds[1],
        post      : postIds[0]
    });
    comments.push({
        _id       : commentIds[1],
        content   : 'comment-by-luajin',
        commenter : userIds[2],
        post      : postIds[1]
    });
    comments.push({
        _id       : commentIds[2],
        content   : 'comment-by-aikin',
        commenter : userIds[1],
        post      : postIds[2]
    });

    User.create(users, function(err, docs) {
        Post.create(posts, function(err, docs) {
            Comment.create(comments, function(err, docs) {
            });
        });
    });
}
</code></pre>

<p><strong><em>数据的准备就绪后，接下来就是探索<code>populate</code>方法:</em></strong></p>

<h2><a rel="nofollow" href="http://mongoosejs.com/docs/api.html#query_Query-populate">1. Query#populate</a></h2>

<p>什么Query? Query(查询)，可以快速和简单的从<strong>MongooDB</strong>查找出相应的 document(s)。 Mongoose 封装了很多查询的方法，使得对数据库的操作变得简单啦。这里分享一下<code>populate</code>方法用法。</p>

<blockquote>
  <p><strong><em>语法：</em></strong><br><strong><code>Query.populate(path, [select], [model], [match], [options])</code></strong></p>
</blockquote>

<blockquote>
  <p><strong><em>参数：</em></strong></p>
</blockquote>

<blockquote>
  <p><strong><code>path</code></strong><br>
  　　类型：<code>String</code>或<code>Object</code>。<br>
  　　<code>String</code>类型的时， 指定要填充的关联字段，要填充多个关联字段可以以空格分隔。<br>
  　　<code>Object</code>类型的时，就是把 <strong>populate</strong> 的参数封装到一个对象里。当然也可以是个数组。下面的例子中将会实现。</p>
</blockquote>

<blockquote>
  <p><strong><code>select</code></strong><br>
  　　类型：<code>Object</code>或<code>String</code>，可选，指定填充 document 中的哪些字段。<br>
  　　<code>Object</code>类型的时，格式如:<code>{name: 1, _id: 0}</code>,为<strong>0</strong>表示不填充，为<strong>1</strong>时表示填充。<br>
  　　<code>String</code>类型的时，格式如:<code>"name -_id"</code>，用空格分隔字段，在字段名前加上<code>-</code>表示不填充。详细语法介绍 <a rel="nofollow" href="http://mongoosejs.com/docs/api.html#query_Query-select">query-select</a></p>
</blockquote>

<blockquote>
  <p><strong><code>model</code></strong><br>
  　　类型：<code>Model</code>，可选，指定关联字段的 model，如果没有指定就会使用<code>Schema</code>的<code>ref</code>。</p>
</blockquote>

<blockquote>
  <p><strong><code>match</code></strong><br>
  　　类型：<code>Object</code>，可选，指定附加的查询条件。</p>
</blockquote>

<blockquote>
  <p><strong><code>options</code></strong><br>
  　　类型：<code>Object</code>，可选，指定附加的其他查询选项，如排序以及条数限制等等。</p>
</blockquote>

<ul>
<li><strong>填充<code>User</code>的<code>posts</code>字段:</strong></li>
</ul>
<pre><code>javascript</code><code>//填充所有 users 的 posts
User.find()
    .populate('posts', 'title', null, {sort: { title: -1 }})
    .exec(function(err, docs) {
        console.log(docs[0].posts[0].title); // post-by-aikin
    });

//填充 user 'luajin'的 posts
User.findOne({name: 'luajin'})
    .populate({path: 'posts', select: { title: 1 }, options: {sort: { title: -1 }}})
    .exec(function(err, doc) {
        console.log(doc.posts[0].title);  // post-by-luajin
    });

//这里的 populate 方法传入的参数形式不同，其实实现的功能是一样的，只是表示形式不一样。

</code></pre>

<ul>
<li><strong>填充<code>Post</code>的<code>poster</code>和<code>comments</code>字段:</strong></li>
</ul>
<pre><code>javascript</code><code>Post.findOne({title: 'post-by-aikin'})
    .populate('poster comments', '-_id')
    .exec(function(err, doc) {
        console.log(doc.poster.name);           // aikin
        console.log(doc.poster._id);            // undefined

        console.log(doc.comments[0].content);  // comment-by-luna
        console.log(doc.comments[0]._id);      // undefined
    });

Post.findOne({title: 'post-by-aikin'})
    .populate({path: 'poster comments', select: '-_id'})
    .exec(function(err, doc) {
        console.log(doc.poster.name);           // aikin
        console.log(doc.poster._id);            // undefined

        console.log(doc.comments[0].content);  // comment-by-luna
        console.log(doc.comments[0]._id);      // undefined
    });

//上两种填充的方式实现的功能是一样的。就是给 populate 方法的参数不同。
//这里要注意，当两个关联的字段同时在一个 path 里面时， select 必须是 document(s)
//具有的相同字段。


//如果想要给单个关联的字段指定 select，可以传入数组的参数。如下：

Post.findOne({title: 'post-by-aikin'})
    .populate(['poster', 'comments'])
    .exec(function(err, doc) {
        console.log(doc.poster.name);          // aikin
        console.log(doc.comments[0].content);  // comment-by-luna
    });

Post.findOne({title: 'post-by-aikin'})
    .populate([
        {path:'poster',   select: '-_id'},
        {path:'comments', select: '-content'}
    ])
    .exec(function(err, doc) {
        console.log(doc.poster.name);          // aikin
        console.log(doc.poster._id);           // undefined

        console.log(doc.comments[0]._id);      // 会打印出对应的 comment id
        console.log(doc.comments[0].content);  // undefined
    });
</code></pre>

<h2><a rel="nofollow" href="http://mongoosejs.com/docs/api.html#model_Model.populate">2. Model#populate</a></h2>

<p>Model(模型)，是根据定义的 Schema 编译成的抽象的构造函数。models 的实例 documents，可以在数据库中被保存和检索。数据库所有 document 的创建和检索，都通过 models 处理。</p>

<blockquote>
  <p><strong><em>语法：</em></strong><br><strong><code>Model.populate(docs, options, [cb(err,doc)])</code></strong></p>
</blockquote>

<blockquote>
  <p><strong><em>参数：</em></strong></p>
</blockquote>

<blockquote>
  <p><strong><code>docs</code></strong><br>
  　　类型：<code>Document</code>或<code>Array</code>。单个需要被填充的 doucment 或者 document 的数组。</p>
</blockquote>

<blockquote>
  <p><strong><code>options</code></strong><br>
  　　类型：<code>Object</code>。以键值对的形式表示。<br>
  　　keys：<code>path</code> <code>select</code> <code>match</code> <code>model</code> <code>options</code>，这些键对应值的类型和功能，与上述<code>Query#populate</code>方法的参数相同。</p>
</blockquote>

<blockquote>
  <p><strong><code>[cb(err,doc)]</code></strong><br>
  　　类型：<code>Function</code>，回调函数，接收两个参数，错误<code>err</code>和填充完的<code>doc(s)</code>。</p>
</blockquote>

<ul>
<li><strong>填充<code>Post</code>的<code>poster</code>和<code>comments</code>字段以及<code>comments</code>的<code>commenter</code>字段:</strong></li>
</ul>
<pre><code>javacript</code><code>Post.find({title: 'post-by-aikin'})
    .populate('poster comments')
    .exec(function(err, docs) {

        var opts = [{
            path   : 'comments.commenter',
            select : 'name',
            model  : 'User'
        }];

        Post.populate(docs, opts, function(err, populatedDocs) {
            console.log(populatedDocs[0].poster.name);                  // aikin
            console.log(populatedDocs[0].comments[0].commenter.name);  // luna
        });
    });
</code></pre>

<h2><a rel="nofollow" href="http://mongoosejs.com/docs/api.html#document_Document-populate">3. Document#populate</a></h2>

<p>Document，每个 document 都是其 Model 的一个实例，一对一的映射着 MongoDB 的 document。</p>

<blockquote>
  <p><strong><em>语法：</em></strong><br><strong><code>Document.populate([path], [callback])</code></strong></p>
</blockquote>

<blockquote>
  <p><strong><em>参数：</em></strong></p>
</blockquote>

<blockquote>
  <p><strong><code>path</code></strong><br>
  　　类型：<code>String</code>或<code>Object。与上述</code>Query#populate`方法的 <strong>path</strong> 参数相同。</p>
</blockquote>

<blockquote>
  <p><strong><code>callback</code></strong><br>
  　　类型：<code>Function</code>。回调函数，接收两个参数，错误<code>err</code>和填充完的<code>doc(s)</code>。</p>
</blockquote>

<ul>
<li><strong>填充<code>User</code>的<code>posts</code>字段:</strong></li>
</ul>
<pre><code>javascript</code><code>User.findOne({name: 'aikin'})
    .exec(function(err, doc) {

        var opts = [{
            path   : 'posts',
            select : 'title'
        }];

        doc.populate(opts, function(err, populatedDoc) {
            console.log(populatedDoc.posts[0].title);  // post-by-aikin
        });
    });
</code></pre>

<p><strong><em>博文涉及的完整例子在 <a rel="nofollow" href="https://gist.github.com/aikin/534fae3c95039b7dee09">gist</a> 上。(ps: gist 被已墙了。)</em></strong></p>

<h2>参考</h2>

<ul>
<li><a rel="nofollow" href="http://mongoosejs.com/docs/populate.html">mongoose-api-docs</a></li>
<li><a rel="nofollow" href="http://www.ruanyifeng.com/blog/2014/07/database_implementation.html">数据库的最简单实现</a></li>
<li><a rel="nofollow" href="http://my.oschina.net/calvinchen/blog/137932">Mongoose 使用之 Population</a></li>
</ul>
<blockquote>
  <p><a rel="nofollow" href="http://ulaijn.com/2014/11/02/mongoose-population/#more">原文链接</a></p>
</blockquote>

2015年五月4日下午 4:01:58
Node crypto.final() 似乎导致与 PHP mcrypt_encrypt 两方加密结果不同？
<div class="markdown-text"><p>加密演算法我使用的是 Triple DES，而以下会出现的 key，IV 我已经先行替换了。</p>
<hr>
<p>首先我使用的是 Node.js crypto 做加密。</p>
<pre class="prettyprint"><code>var secretKey  = new Buffer(&#x27;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&#x27;, &#x27;hex&#x27;), // 48 chars
    iv         = new Buffer(&#x27;bbbbbbbbbbbbbbbb&#x27;, &#x27;hex&#x27;); // 16 chars
var str        = &#x27;This string will be encrypted.&#x27;;
var cipher     = crypto.createCipheriv(&#x27;des-ede3-cbc&#x27;, secretKey, iv),
    cryptedStr = cipher.update(str, &#x27;utf8&#x27;, &#x27;base64&#x27;) + cipher.final(&#x27;base64&#x27;);
</code></pre><p>再來是协作方的系统，使用的是 PHP 的 mcrypt。</p>
<pre class="prettyprint"><code>$key    = pack(&#x27;H*&#x27;, &quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;); 
$iv     = pack(&#x27;H*&#x27;, &quot;bbbbbbbbbbbbbbbb&quot;); 
$string = &#x27;This string will be encrypted.&#x27;;
$text   = mcrypt_encrypt(MCRYPT_3DES, $key, $string, MCRYPT_MODE_CBC, $iv);
$text_base64 = base64_encode($text);
</code></pre><hr>
<p>我遇到的问题是，明明使用相同的 Key / IV、演算法以及编码方式，但结果就是会有一部分不同。</p>
<p>而观察之下，不同处却是 <code>cipher.final()</code> 所导致？</p>
<pre class="prettyprint"><code>// Node.js output.
UKBI17EIHKNM2EU48ygsjil5r58Eo1csByAIFp9GhUw=
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    Same part

// PHP output.
UKBI17EIHKNM2EU48ygsjil5r58Eo1csAY4C0JZoyco=
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    Same part
</code></pre><hr>
<p>还请教各位大侠、前辈，究竟是为什么呢？</p>
</div>

2015年五月4日下午 3:19:38
文件归档工具——category
<div class="markdown-text"><p>我有个习惯就是定期将手机里的照片拷贝到电脑上，整理归档，然后上传到网盘。</p>
<p>整理之前是这样的：</p>
<pre class="prettyprint"><code>Camera/
├── IMG_20150425_133502.jpg
├── IMG_20150426_134524.jpg
├── IMG_20150427_123602.jpg
└── IMG_20150427_221603.jpg
...
</code></pre><p>整理之后是这样的：</p>
<pre class="prettyprint"><code>Camera/
├── 2015-04-25/
│   └── IMG_20150425_133502.jpg
├── 2015-04-26/
│   └── IMG_20150426_134524.jpg
└── 2015-04-27/
    ├── IMG_20150427_123602.jpg
    └── IMG_20150427_221603.jpg
</code></pre><p>话说以前每次都是手动整理的没用过啥软件 orz… ，由于很长时间没整理手机相册积攒了很多照片，于是昨天自己写了个归档的命令行工具。。。</p>
<p>传送门：<a href="https://github.com/nswbmw/node-category">https://github.com/nswbmw/node-category</a></p>
</div>

2015年五月4日下午 2:50:28
使用Python解析nginx日志文件
<p>项目的一个需求是解析nginx的日志文件。<br>
简单的整理如下：</p>

<hr>
<h2>日志规则描述</h2>

<p>首先要明确自己的Nginx的日志格式，这里采用默认Nginx日志格式：</p>

<pre><code> log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                   '$status $body_bytes_sent "$http_referer" '
                   '"$http_user_agent" "$http_x_forwarded_for"';
</code></pre>

<p>其中一条真实记录样例如下：</p>

<pre><code>172.22.8.207 - - [16/Dec/2014:17:57:35 +0800] "GET /report?DOmjjuS6keWJp+WculSQAgdUkAIPODExMzAwMDJDN0FC HTTP/1.1" 200 0 "-" "XXXXXXX/1.0.16; iPhone/iOS 8.1.2; ; 8DA77E2F91D0"
</code></pre>

<p>其中，客户端型号信息用<code>XXXXXXX</code>代替。</p>

<p>项目中已经按照业务规则对Nginx日志文件进行了处理命名规则如下：</p>

<pre><code>ID-ID-YYMMDD-hhmmss
</code></pre>

<p>并且所有的日志文件存放在统一路径下。</p>

<h2>解决思路</h2>

<hr>
<h3>获取所有日志文件<code>path</code>
</h3>

<p>这里使用Python的<code>glob</code>模块来获取日志文件path</p>

<pre><code>import glob


def readfile(path):
    return glob.glob(path + '*-*-*-*')
</code></pre>

<h3>获取日志文件中每一行的内容</h3>

<p>使用Python的<code>linecache</code>模块来获取文件行的内容</p>

<pre><code>import linecache


def readline(path):
    return linecache.getlines(path)
</code></pre>

<p>注意：linecache模块使用了缓存，所以存在以下问题：</p>

<ol>
<li><p>在使用linecache模块读取文件内容以后，如果文件发生了变化，那么需要使用<code>linecache.updatecache(filename)</code>来更新缓存，以获取最新变化。</p></li>
<li><p>linecache模块使用缓存，所以会耗费内存，耗费量与要解析的文件相关。最好在使用完毕后执行<code>linecache.clearcache()</code>清空一下缓存。</p></li>
</ol>
<p>当然，作为优化，这里可以利用<code>生成器</code>来进行优化。暂且按下不表。</p>

<h3>处理日志条目</h3>

<p>一条日志信息就是一个特定格式的字符串，因此使用<code>正则表达式</code>来解析，这里使用Python的<code>re</code>模块。<br>
下面，一条一条建立规则：</p>

<h4>规则</h4>

<pre><code>    ip = r"?P&lt;ip&gt;[\d.]*"
    date = r"?P&lt;date&gt;\d+"
    month = r"?P&lt;month&gt;\w+"
    year = r"?P&lt;year&gt;\d+"
    log_time = r"?P&lt;time&gt;\S+"
    method = r"?P&lt;method&gt;\S+"
    request = r"?P&lt;request&gt;\S+"
    status = r"?P&lt;status&gt;\d+"
    bodyBytesSent = r"?P&lt;bodyBytesSent&gt;\d+"
    refer = r"""?P&lt;refer&gt;
             [^\"]*
             """
    userAgent=r"""?P&lt;userAgent&gt;
                .*
               """
</code></pre>

<h3>解析</h3>

<pre><code>p = re.compile(r"(%s)\ -\ -\ \[(%s)/(%s)/(%s)\:(%s)\ [\S]+\]\ \"(%s)?[\s]?(%s)?.*?\"\ (%s)\ (%s)\ \"(%s)\"\ \"(%s).*?\"" %( ip, date, month, year, log_time, method, request, status, bodyBytesSent, refer, userAgent ), re.VERBOSE)
m = re.findall(p, logline)
</code></pre>

<p>这样，就可以得到日志条目中各个要素的原始数据。</p>

<hr>
<h3>格式及内容转化</h3>

<p>得到日志原始数据之后，需要根据业务要求，对原始数据进行格式及内容转化。<br>
这里需要处理的内容包括：时间，request，userAgent</p>

<h4>时间格式转化</h4>

<p>在日志信息原始数据中存在<code>Dec</code>这样的信息，利用Python的<code>time</code>模块可以方便的进行解析</p>

<pre><code>import time


def parsetime(date, month, year, log_time):
    time_str = '%s%s%s %s' %(year, month, date, log_time)
    return time.strptime(time_str, '%Y%b%d %H:%M:%S')
</code></pre>

<h4>解析request</h4>

<p>在日志信息原始数据中得到的<code>request</code>的内容格式为：</p>

<pre><code>/report?XXXXXX
</code></pre>

<p>这里只需要根据协议取出<code>XXXXXX</code>即可。<br>
这里仍然采用Python的<code>re</code>模块</p>

<pre><code>import re


def parserequest(rqst):
    param = r"?P&lt;param&gt;.*"
    p = re.compile(r"/report\?(%s)" %param, re.VERBOSE)
    return re.findall(p, rqst)
</code></pre>

<p>接下来需要根据业务协议解析参数内容。这里需要先利用<code>base64</code>模块解码，然后再利用<code>struct</code>模块解构内容：</p>

<pre><code>import struct
import base64


def parseparam(param):
    decodeinfo = base64.b64decode(param)
    s = struct.Struct('!x' + bytes(len(decodeinfo) - (1 + 4 + 4 + 12)) + 'xii12x')
    return s.unpack(decodeinfo)
</code></pre>

<h4>解析userAgent</h4>

<p>在日志信息原始数据中userAgent数据的格式为：</p>

<pre><code>XXX; XXX; XXX; XXX
</code></pre>

<p>根据业务要求，只需要取出最后一项即可。<br>
这里采用<code>re</code>模块来解析。</p>

<pre><code>import re


def parseuseragent(useragent):
    agent = r"?P&lt;agent&gt;.*"
    p = re.compile(r".*;.*;.*;(%s)" %agent, re.VERBOSE)
    return re.findall(p, useragent)
</code></pre>

<hr>
<p>至此，nginx日志文件解析基本完成。<br>
剩下的工作就是根据业务需要，对获得的基本信息进行处理。<br>
（完）</p>

2015年五月4日下午 12:36:05
客户-服务器程序设计方法
<h1>客户-服务器程序设计方法</h1>

<p>《unix网络编程》第一卷中将客户服务器程序设计方法讲得透彻，这篇文章将其中编码的细节略去，通过伪代码的形式展现，主要介绍各种方法的思想；</p>

<p>示例是一个经典的TCP回射程序：<br>
客户端发起连接请求，连接后发送一串数据；收到服务端的数据后输出到终端；<br>
服务端收到客户端的数据后原样回写给客户端；</p>

<p>客户端伪代码：</p>

<pre><code>sockfd = socket(AF_INET,SOCK_STREAM,0);
//与服务端建立连接
connect(sockfd);
//连接建立后从终端读入数据并发送到服务端；
//从服务端收到数据后回写到终端
while(fgets(sendline,MAXLINE,fileHandler)!= NULL){
    writen(sockfd,sendline,strlen(sendline));
    if(readline(sockfd,recvline,MAXLINE) == 0){
        cout &lt;&lt; "recive over!";
    }
    fputs(recvline,stdout);
}
</code></pre>

<p>下面介绍服务端程序处理多个客户请求的开发范式；</p>

<h2>多进程处理</h2>

<p>对于多个客户请求，服务器端采用fork的方式创建新进程来处理；</p>

<p>处理流程：<br>
1. 主进程绑定ip端口后，使用accept()等待新客户的请求；<br>
2. 每一个新的用户请求到来，都创建一个新的子进程来处理具体的客户请求；<br>
3. 子进程处理完用户请求，结束本进程；</p>

<p>服务端伪代码：</p>

<pre><code>listenFd = socket(AF_INET,SOCK_STREAM,0);
bind(listenFd,addR);
listen(listenFD);
while(true){
    //服务器端在这里阻塞等待新客户连接
    connfd = accept(listenfd); 
    if( fork() ==0){//子进程
        close(listenfd);
        while(n=read(connfd,buf,MAXLINE)&gt;0){
            writen(connfd,buf);
        }
    }
    close(connfd);
}
</code></pre>

<p>这种方法开发简单，但对操作系统而言，进程是一种昂贵的资源，对于每个新客户请求都使用一个进程处理，开销较大；<br>
对于客户请求数不多的应用适用这种方法；</p>

<h2>预先分配进程池，accept无上锁保护</h2>

<p>上一种方法中，每来一个客户都创建一个进程处理请求，完毕后再释放；<br>
不间断的创建和结束进程浪费系统资源；<br>
使用进程池预先分配进程，通过进程复用，减少进程重复创建带来的系统消耗和时间等待；</p>

<p>优点：消除新客户请求到达来创建进程的开销；<br>
缺点：需要预先估算客户请求的多少（确定进程池的大小）</p>

<p>源自Berkeley内核的系统，有以下特性：<br>
派生的所有子进程各自调用accep()监听同一个套接字，在没有用户请求时都进入睡眠；<br>
当有新客户请求到来时，所有的客户都被唤醒；内核从中选择一个进程处理请求，剩余的进程再次转入睡眠（回到进程池）；</p>

<p>利用这个特性可以由操作系统来控制进程的分配；<br>
内核调度算法会把各个连接请求均匀的分散到各个进程中；</p>

<p>处理流程：<br>
1. 主进程预先分配进程池，所有子进程阻塞在accept()调用上；<br>
2. 新用户请求到来，操作系统唤醒所有的阻塞在accpet上的进程，从其中选择一个建立连接；<br>
3. 被选中的子进程处理用户请求，其它子进程回到睡眠；<br>
4. 子进程处理完毕，再次阻塞在accept上；</p>

<p>服务端伪代码：</p>

<pre><code>listenFd = socket(AF_INET,SOCK_STREAM,0);
bind(listenFd,addR);
listen(listenFD);
for(int i = 0;i&lt; children;i++){
    if(fork() == 0){//子进程
        while(true){
            //所有子进程监听同一个套接字，等待用户请求
            int connfd = accept(listenfd);
            close(listenfd);
            //连接建立后处理用户请求，完毕后关闭连接
            while(n=read(connfd,buf,MAXLINE)&gt;0){
                writen(connfd,buf);
            }
            close(connfd);
        }
    }
}
</code></pre>

<p><strong>如何从进程池中取出进程？</strong><br>
所有的进程都通过accept()阻塞等待，等连接请求到来后，由内核从所有等待的进程中选择一个进程处理；</p>

<p><strong>处理完的进程，如何放回到池子中？</strong><br>
子进程处理完客户请求后，通过无限循环，再次阻塞在accpet()上等待新的连接请求；</p>

<p><strong>注意：</strong> 多个进程accept()阻塞会产生“惊群问题”：尽管只有一个进程将获得连接，但是所有的进程都被唤醒；这种每次有一个连接准备好却唤醒太多进程的做法会导致性能受损；</p>

<h2>预先分配进程池，accept上锁（文件锁、线程锁）</h2>

<p>上述不上锁的实现存在移植性的问题（只能在源自Berkeley的内核系统上）和惊群问题，<br>
更为通用的做法是对accept上锁；即避免让多个进程阻塞在accpet调用上，而是都阻塞在获取锁的函数中；</p>

<p>服务端伪代码：</p>

<pre><code>listenFd = socket(AF_INET,SOCK_STREAM,0);
bind(listenFd,addR);
listen(listenFD);
for(int i = 0;i&lt; children;i++){
    if(fork() == 0){
        while(true){
            my_lock_wait();//获取锁
            int connfd = accept(listenfd);
            my_lock_release();//释放锁
            close(listenfd);
            while(n=read(connfd,buf,MAXLINE)&gt;0){
                writen(connfd,buf);
            }
            close(connfd);
        }
    }
}
</code></pre>

<p>上锁可以使用文件上锁，线程上锁；<br>
- 文件上锁的方式可移植到所有的操作系统，但其涉及到文件系统操作，可能比较耗时；<br>
- 线程上锁的方式不仅适用不同线程之间的上锁，也适用于不同进程间的上锁；</p>

<p>关于上锁的编码细节详见《网络编程》第30章；</p>

<h2>预先分配进程池，传递描述符；</h2>

<p>与上面的每个进程各自accept接收监听请求不同，这个方法是在父进程中统一接收accpet()用户请求，在连接建立后，将连接描述符传递给子进程；</p>

<p>处理流程：<br>
1. 主进程阻塞在accpet上等待用户请求，所有子进程不断轮询探查是否有可用的描述符；<br>
2. 有新用户请求到来，主进程accpet建立连接后，从进程池中取出一个进程，通过字节流管道将连接描述符传递给子进程；<br>
3. 子进程收到连接描述符，处理用户请求，处理完成后向父进程发送一个字节的内容（无实际意义），告知父进程我任务已完成；<br>
4. 父进程收到子进程的单字节数据，将子进程放回到进程池；</p>

<p>服务端伪代码：</p>

<pre><code>listenFd = socket(AF_INET,SOCK_STREAM,0);
bind(listenFd,addR);
listen(listenFD);
//预先建立子进程池
for(int i = 0;i&lt; children;i++){
    //使用Unix域套接字创建一个字节流管道，用来传递描述符
    socketpair(AF_LOCAL,SOCK_STREAM,0,sockfd);
    if(fork() == 0){//预先创建子进程
        //子进程字节流到父进程
        dup2(sockfd[1],STDERR_FILENO);
        close(listenfd);
        while(true){
            //收到连接描述符
            if(read_fd(STDERR_FILENO,&amp;connfd) ==0){; 
                continue;
            }
            while(n=read(connfd,buf,MAXLINE)&gt;0){ //处理用户请求
                writen(connfd,buf);
            }
            close(connfd);
            //通知父进程处理完毕，本进程可以回到进程池
            write(STDERR_FILENO,"",1);
        }
    }
}

while(true){
    //监听listen套接字描述符和所有子进程的描述符
    select(maxfd+1,&amp;rset,NULL,NULL,NULL);
    if(FD_ISSET(listenfd,&amp;rset){//有客户连接请求
        connfd = accept(listenfd);//接收客户连接
        //从进程池中找到一个空闲的子进程
        for(int i = 0 ;i &lt; children;i++){
            if(child_status[i] == 0)
                break;
        }
        child_status[i] = 1;//子进程从进程池中分配出去
        write_fd(childfd[i],connfd);//将描述符传递到子进程中
        close(connfd);
    }
    //检查子进程的描述符，有数据，表明已经子进程请求已处理完成，回收到进程池
    for(int i = 0 ;i &lt; children;i++){
        if(FD_ISSET(childfd[i],&amp;rset)){
            if(read(childfd[i])&gt;0){
                child_status[i] = 0;
            }
        }
    }
}
</code></pre>

<h2>多线程处理</h2>

<p>为每个用户创建一个线程，这种方法比为每个用户创建一个进程要快出许多倍；</p>

<p>处理流程：<br>
1. 主线程阻塞在accpet上等待用请求；<br>
2. 有新用户请求时，主线程建立连接，然后创建一个新的线程，将连接描述符传递过去；<br>
3. 子线程处理用户请求，完毕后线程结束；</p>

<p>服务端伪代码：</p>

<pre><code>listenFd = socket(AF_INET,SOCK_STREAM,0);
bind(listenFd,addR);
listen(listenFD);
while(true){
    connfd = accept(listenfd);
        //连接建立后，创建新线程处理具体的用户请求
    pthread_create(&amp;tid,NULL,&amp;do_function,(void*)connfd);
    close(connfd);
}

--------------------
//具体的用户请求处理函数（子线程主体）
void * do_function(void * connfd){
    pthread_detach(pthread_self());
    while(n=read(connfd,buf,MAXLINE)&gt;0){
        writen(connfd,buf);
    close((int)connfd);
}
</code></pre>

<h2>预先创建线程池，每个线程各自accept</h2>

<p>处理流程：<br>
1. 主线程预先创建线程池，第一个创建的子线程获取到锁，阻塞在accept()上，其它子线程阻塞在线程锁上；<br>
2. 用户请求到来，第一个子线程建立连接后释放锁，然后处理用户请求；完成后进入线程池，等待获取锁；<br>
3. 第一个子线程释放锁之后，线程池中等待的线程有一个会获取到锁，阻塞在accept()等待用户请求；</p>

<pre><code>listenFd = socket(AF_INET,SOCK_STREAM,0);
bind(listenFd,addR);
listen(listenFD);
//预先创建线程池，将监听描述符传给每个新创建的线程
for(int i = 0 ;i &lt;threadnum;i++){
    pthread_create(&amp;tid[i],NULL,&amp;thread_function,(void*)connfd);
}

--------------------
//具体的用户请求处理
//通过锁保证任何时刻只有一个线程阻塞在accept上等待新用户的到来；其它的线程都
//在等锁；
void * thread_function(void * connfd){
    while(true){
        pthread_mutex_lock(&amp;mlock); // 线程上锁
        connfd = accept(listenfd);
        pthread_mutex_unlock(&amp;mlock);//线程解锁
        while(n=read(connfd,buf,MAXLINE)&gt;0){
            writen(connfd,buf);
        close(connfd);
    }
}
</code></pre>

<p>使用源自Berkeley的内核的Unix系统时，我们不必为调用accept而上锁，<br>
去掉上锁的两个步骤后，我们发现没有上锁的用户时间减少（因为上锁是在用户空间中执行的线程函数完成的)，而系统时间却增加很多（每一个accept到达，所有的线程都变唤醒，引发内核的惊群问题，这个是在线程内核空间中完成的）;<br>
而我们的线程都需要互斥，让内核执行派遣还不让自己通过上锁来得快；</p>

<p>这里没有必要使用文件上锁，因为单个进程中的多个线程，总是可以通过线程互斥锁来达到同样目的；（文件锁更慢）</p>

<h2>　预先创建线程池，主线程accept后传递描述符</h2>

<p>处理流程：</p>

<ol>
<li>主线程预先创建线程池，线程池中所有的线程都通过调用pthread_cond_wait()而处于睡眠状态（由于有锁的保证，是依次进入睡眠，而不会发生同时调用pthread_cond_wait引发竞争）</li>
<li>主线程阻塞在acppet调用上等待用户请求；</li>
<li>用户请求到来，主线程accpet建立建立，将连接句柄放入约定位置后，发送pthread_cond_signal激活一个等待该条件的线程；</li>
<li>线程激活后从约定位置取出连接句柄处理用户请求；完毕后再次进入睡眠（回到线程池）；</li>
</ol>
<p>激活条件等待的方式有两种：pthread_cond_signal()激活一个等待该条件的线程，存在多个等待线程时按入队顺序激活其中一个；而pthread_cond_broadcast()则激活所有等待线程。</p>

<p>注：一般应用中条件变量需要和互斥锁一同使用；<br>
在调用pthread_cond_wait()前必须由本线程加锁（pthread_mutex_lock()），而在更新条件等待队列以前，mutex保持锁定状态，并在线程挂起进入等待前解锁。在条件满足从而离开pthread_cond_wait()之前，mutex将被重新加锁，以与进入pthread_cond_wait()前的加锁动作对应。</p>

<p>服务端伪代码：</p>

<pre><code>listenFd = socket(AF_INET,SOCK_STREAM,0);
bind(listenFd,addR);
listen(listenFD);
for(int i = 0 ;i &lt;threadnum;i++){
    pthread_create(&amp;tid[i],NULL,&amp;thread_function,(void*)connfd);
}
while(true){
    connfd = accept(listenfd);
    pthread_mutex_lock(&amp;mlock); // 线程上锁
    childfd[iput] = connfd;//将描述符的句柄放到数组中传给获取到锁的线程；
    if(++iput == MAX_THREAD_NUM)
        iput= 0;
    if(iput == iget)
        err_quit("thread num not enuough!");
    pthread_cond_signal(&amp;clifd_cond);//发信号，唤醒一个睡眠线程（轮询唤醒其中的一个）
    pthread_mutex_unlock(&amp;mlock);//线程解锁
}

--------------------
void * thread_function(void * connfd){
    while(true){
        pthread_mutex_lock(&amp;mlock); // 线程上锁
        //当无没有收到连接句柄时，睡眠在条件变量上，并释放mlock锁
        //满足条件被唤醒后，重新加mlock锁
        while(iget == iput)
            pthread_cond_wait(&amp;clifd_cond,&amp;mlock);
        connfd = childfd[iget];
        if(++iget == MAX_THREAD_NUM)
            iget = 0;
        pthread_mutex_unlock(&amp;mlock);//线程解锁
        //处理用户请求
        while(n=read(connfd,buf,MAXLINE)&gt;0){
            writen(connfd,buf);
        close(connfd);
    }
}
</code></pre>

<p>测试表明这个版本的服务器要慢于每个线程各自accpet的版本，原因在于这个版本同时需要互斥锁和条件变量，而上一个版本只需要互斥锁；</p>

<p><strong>线程描述符的传递和进程描述符的传递的区别？</strong><br>
在一个进程中打开的描述符对该进程中的所有线程都是可见的，引用计数也就是1；<br>
所有线程访问这个描述符都只需要通过一个描述符的值（整型）访问；<br>
而进程间的描述符传递，传递的是描述符的引用；（好比一个文件被2个进程打开，相应的这个文件的描述符引用计数增加2）；</p>

<h2>总结</h2>

<ul>
<li>当系统负载较轻时，每个用户请求现场派生一个子进程为之服务的传统并发服务器模型就足够了；</li>
<li>相比传统的每个客户fork一次的方式，预先创建一个子进程池或线程池能够把进程控制cpu时间降低10倍以上；当然，程序会相应复杂一些，需要监视子进程个数，随着客户用户数的动态变化而增加或减少进程池；</li>
<li>让所有子进程或线程自行调用accept通常比让父进程或主线程独自调用accpet并发描述符传递给子进程或线程要简单和快速；</li>
<li>使用线程通常要快于使用进程；</li>
</ul>
<h2>参考资料</h2>

<p>《unix网络编程》第一卷 套接字联网API</p>

<p>Posted by: 大CC<br>
博客：<a rel="nofollow" href="http://blog.me115.com">blog.me115.com</a><br>
微博：<a rel="nofollow" href="http://weibo.com/bigcc115">新浪微博</a></p>

2015年五月4日下午 12:35:27
提交自己的包到bower、npm中
<p><a rel="nofollow" href="http://jslite.io/2015/05/03/%E6%8F%90%E4%BA%A4%E8%87%AA%E5%B7%B1%E5%8C%85%E5%88%B0bower%E3%80%81npm%E4%B8%AD/">转载地址</a></p>

<h1>bower</h1>

<p>Bower 是 twitter 推出的一款包管理工具，基于nodejs的模块化思想，把功能分散到各个模块中，让模块和模块之间存在联系，通过 Bower 来管理模块间的这种联系。</p>

<p><a rel="nofollow" href="http://bower.io/">bower官网</a></p>

<h2>安装Bower</h2>

<p>一旦你已经安装了上面所说的所有必要文件，键入以下命令安装Bower：</p>

<pre><code>$ npm install -g bower
</code></pre>

<p>这行命令是Bower的全局安装，-g 操作表示全局。</p>

<h2>使用bower</h2>

<ol>
<li>直接下载 git 库: <code>bower install git://github.com/JSLite/JSLite.git</code>  </li>
<li>github别名自动解析git库: <code>bower install JSLite/JSLite</code>  </li>
<li>下载线上的任意文件: <code>bower install http://foo.com/jquery.awesome-plugin.js</code>  </li>
<li>下载本地库: <code>bower install ./repos/jquery</code>
</li>
</ol>
<h2>常用命令</h2>

<p><code>$ bower install jquery --save</code> 添加依赖并更新bower.json文件<br><code>$ bower cache clean</code> 安装失败清除缓存<br><code>$ bower install storejs</code> 安装storejs<br><code>$ bower uninstall storejs</code> 卸载storejs</p>

<h2>注册</h2>

<h3>添加配置文件</h3>

<p>bower.json文件的使用可以让包的安装更容易，你可以在应用程序的根目录下创建一个名为 <code>bower.json</code> 的文件，并定义它的依赖关系。使用<code>bower init</code> 命令来创建<code>bower.json</code>文件：</p>

<pre><code>$ bower init
? name: store.js
? version: 1.0.1
? description: "本地存储localstorage的封装，提供简单的AIP"
? authors: (kenny.wang &lt;wowohoo@qq.co&gt;)
? license: MIT
? homepage:
? set currently installed components as dependencies?: Yes
? add commonly ignored files to ignore list?: Yes
? would you like to mark this package as private which prevents it from being accidentally publis? would you like to mark this package as private which prevents it from being accidentally published to the registry?: No

{
  name: 'store.js',
  main: 'store.js',
  version: '1.0.1',
  authors: [
    '(kenny.wang &lt;wowohoo@qq.co&gt;)'
  ],
  description: '"本地存储localstorage的封装，提供简单的AIP"',
  moduleType: [
    'amd',
    'node'
  ],
  keywords: [
    'storejs'
  ],
  license: 'MIT',
  ignore: [
    '**/.*',
    'node_modules',
    'bower_components',
    'test',
    'tests'
  ]
}

? Looks good?: Yes
</code></pre>

<h3>注册自己的包</h3>

<p>可以注册自己的包，这样其他人也可以使用了，这个操作只是在服务器上保存了一个隐射，服务器本身不托管代码。</p>

<pre><code>bower register storejs git://github.com/jaywcjlove/store.js.git
</code></pre>

<h1>npm</h1>

<p>npm全称Node Package Manager，是node.js的模块依赖管理工具。使用github管理NPM包的代码，并定期提交至NPM服务器；<br><a rel="nofollow" href="https://www.npmjs.com/">npm官网</a></p>

<h2>提交自己开发的NPM包</h2>

<h3>创建package.json文件</h3>

<p>package.json文件的使用可以让包的安装更容易，你可以在应用程序的根目录下创建一个名为 <code>package.json</code> 的文件，并定义它的依赖关系。使用<code>npm init</code> 命令来创建<code>package.json</code>文件：</p>

<pre><code>$ npm init
This utility will walk you through creating a package.json file.
It only covers the most common items, and tries to guess sane defaults.

See `npm help json` for definitive documentation on these fields
and exactly what they do.

Use `npm install &lt;pkg&gt; --save` afterwards to install a package and
save it as a dependency in the package.json file.

Press ^C at any time to quit.
name: (store.js)
version: (1.0.0)
description: Local storage localstorage package provides a simple API
entry point: (store.js)
test command: store.js
git repository: (https://github.com/jaywcjlove/store.js.git)
keywords: store.js
author: (kenny.wang &lt;wowohoo@qq.co&gt;)
license: (ISC) MIT
About to write to /Applications/XAMPP/xamppfiles/htdocs/git/github.com/myJS/store.js/package.json:

{
  "name": "store.js",
  "version": "1.0.0",
  "description": "Local storage localstorage package provides a simple API",
  "main": "store.js",
  "scripts": {
    "test": "store.js"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/jaywcjlove/store.js.git"
  },
  "keywords": [
    "store.js"
  ],
  "author": " &lt;wowohoo@qq.co&gt; (kenny.wang &lt;wowohoo@qq.co&gt;)",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/jaywcjlove/store.js/issues"
  },
  "homepage": "https://github.com/jaywcjlove/store.js"
}


Is this ok? (yes) yes
</code></pre>

<h2>发布到线上</h2>

<h3>添加用户</h3>

<p>按照提示输入用户名，密码和邮箱</p>

<pre><code>npm adduser
</code></pre>

<h3>登陆用户</h3>

<p>按照提示输入用户名，密码和邮箱</p>

<pre><code>npm adduser
</code></pre>

<h3>发布</h3>

<pre><code>npm publish
</code></pre>

<p>如果不带参数，则会在当前目录下查找package.json文件，按照该文件描述信息发布；<br>
如果指定目录，就会在指定目录下查找package.json文件<br>
测试是否发布成功，在官网搜索一下<a rel="nofollow" href="https://www.npmjs.com/">www.npmjs.com</a></p>

<p>注： <code>package.json</code> 中的<code>name</code>不要又特殊字符哦</p>

<h4>版本更新</h4>

<p>修改package.json里的版本号，重新npm publish</p>

<h4>取消发布</h4>

<pre><code>npm unpublish
</code></pre>

<h2>其它命令</h2>

<p><code>npm install storejs</code>  下载使用<br><code>npm config set registry https://registry.npm.taobao.org</code>  更换镜像地址<br><code>npm config get registry</code>  获取镜像地址<br><code>npm dist-tag ls jslite</code>  查看当前版本<br><code>npm dedupe</code> 尽量压平依赖树</p>

<h2>国内优秀npm镜像</h2>

<p>由于npm的源在国外，所以国内用户使用起来各种不方便。<br><a rel="nofollow" href="http://segmentfault.com/a/1190000000491162">利用kappa搭建私有NPM仓库</a></p>

<h3>淘宝npm镜像</h3>

<ol>
<li>搜索地址：<a rel="nofollow" href="http://npm.taobao.org/">http://npm.taobao.org/</a>
</li>
<li>registry地址：<a rel="nofollow" href="http://registry.npm.taobao.org/">http://registry.npm.taobao.org/</a>
</li>
</ol>
<h3>cnpmjs镜像</h3>

<ol>
<li>搜索地址：<a rel="nofollow" href="http://cnpmjs.org/">http://cnpmjs.org/</a>
</li>
<li>registry地址：<a rel="nofollow" href="http://r.cnpmjs.org/">http://r.cnpmjs.org/</a>
</li>
</ol>
<h3>临时使用</h3>

<pre><code>npm --registry https://registry.npm.taobao.org install express
</code></pre>

<h3>持久使用</h3>

<pre><code>npm config set registry https://registry.npm.taobao.org
// 配置后可通过下面方式来验证是否成功
npm config get registry
// 或
npm info express
</code></pre>

<h3>通过cnpm使用</h3>

<pre><code>npm install -g cnpm --registry=https://registry.npm.taobao.org

// 使用
cnpm install expresstall express
</code></pre>

<h1>spmjs</h1>

<p><a rel="nofollow" href="http://spmjs.io">spmjs</a></p>

<p>据说已经不更新了，日后如果有研究再补充！</p>

2015年五月4日中午 12:11:31
【北京朝外·日坛国际公寓】急招web前端一枚，快到碗里来，发简历至vivian.sheng@123lian.com
<div class="markdown-text"><p>我们的创始团队来自PwC，360等公司，在做的是帮助大家找人一起来玩体育运动的app - 找炼运动。我们的CEO是连续创业者，之前已经做过一家不大不小的公司。我们的主程去年才从美国跑到北京，因此整天挂在嘴上的都是一些很有逼格的新技术，什么React啊，Docker啊，Ansible啊。我们还有“需求一锤子敲定，不用天天改来改去的”产品经理，和她一起工作，保证是件身心愉悦的乐事。</p>
<p>我们的主程是Pivotal Labs的脑残粉，所以我们会和你：pair programming，这是我们所知对工程师来说提升很大的一种编程方法，对一个好的学习者来说，近距离观察别的程序员如何写测试，在代码中找到bug或者加新功能，是非常有效的学习过程。如果你是更资深的工程师，那就让我们从你那里学点东西吧：）当然，这过程中大屏幕的Mac是少不了的。</p>
<p>我们的办公室在朝阳门外，可以直接俯瞰日坛公园，好风景，工作也会有好心情。</p>
<p>我们需要你：
与设计师/产品经理/后端工程师沟通，完成微信和Web端应用的功能设计、开发和实现
与后端开发人员一起研讨技术实现方案，制定服务接口</p>
<p>我们的要求：
愿意在创业公司工作，有创造的意愿和热情
接触过Angular.js/React.js/Ember.js/Backbone.js等主流客户端框架中的一种
有良好的编码习惯</p>
<p>加分项：
熟悉移动端网站开发，了解兼容不同浏览器的最优前端解决方案
接触过任何一门后端语言（Node.js/Ruby/Python/PHP等）
有前端代码优化经验</p>
<p>我们的面试过程：
没有算法题，我们会和你一起编程，解决一个小问题。</p>
</div>

2015年五月4日上午 10:48:21
北京海淀【功夫熊】-Node开发者（移动互联网O2O，弹性工作，扁平化管理，战斗力爆表~）
<div class="markdown-text"><p>Node开发工程师：
主要工作：基于Node的产品研发
岗位职责：
1 参与讨论开发需求
2 负责手机web端和产品后台的研发
岗位需求：
1 熟悉Node，熟悉Mongodb
2 熟悉Html5，能够完成完整的web应用
3 学习能力强，有强烈的工作责任心，具有一定的沟通及协调能力</p>
<p>高级Node开发工程师：
主要工作：基于Node的产品研发
岗位职责：
1 参与讨论开发需求
2 负责系统后端全部体系开发
3 负责后台REST API设计及mongodb的结构设计
4 负责复杂数据的mongodb存储格式设计和算法及性能优化
岗位需求：
1 一年及以上的Node开发工作经验
2 知识体系全面，熟悉主流前后端技术，有复杂大型后端系统的开发经验
3 具备Express、async、underscore等框架的使用经验，熟悉HTTP，TCP/IP网络协议
4 有Restful API开发和NoSQL项目开发经验
5 学习能力强，有强烈的工作责任心，具有一定的沟通及协调能力</p>
<p>加分：
1 有高并发Web项目后端开发和海量数据处理经验
2 有敏捷或流行软件开发流程的经验</p>
<p>PS：O2O全新领域，百度系研发团队，战斗力爆表，弹性工作、无限量零食~~</p>
<p>公司主页：<a href="http://www.gfxiong.com">www.gfxiong.com</a>
公司简介：
功夫熊——上门推拿第一大；
O2O上门推拿互联网平台，为都市人提供专业便捷的上门服务；
推拿师全部具有5年以上工作经验，有的从迪拜阿联酋回来的，有的从中医院出来；
通过微信平台（gfxiong）即可下单预约推拿师。
2014年10月上线，100天做到行业第一，光顾过央视、东方卫视、教育电视台、台湾中天卫视等各种TV，现北京上海均已开通。</p>
<p>附上功夫熊的服务宣传链接：
<a href="http://card.maka.im/mview/viewer.html?id=AQUX7YMZ&amp;from=timeline&amp;isappinstalled=0">http://card.maka.im/mview/viewer.html?id=AQUX7YMZ&amp;from=timeline&amp;isappinstalled=0</a></p>
<p>请有意向者投递简历至邮箱：<a href="mailto:hr@gfxiong.com">hr@gfxiong.com</a>
邮件名称：姓名-Node-Cnode社区</p>
</div>

2015年五月4日上午 9:41:52
Node.js 服务器提升CPU个数和提升RAM哪个对性能的提升影响大？
<div class="markdown-text"><p>我有个疑惑。。Node.js是单线程的，意味着一个进程就只能有一个线程，也就意味着CPU一个核只能处理一个线程对吧？（如果说错了求指正。。）</p>
<p>所以说从单核CPU升级到4核CPU，意味着本来同一时刻只能处理一个用户请求变成可以同时处理4个用户同时的请求。所以性能是提升了4倍。</p>
<p>如果提升RAM，相当于提升了单个进程的处理速度，其实一样能大幅提升性能。</p>
<p>想问问大家都用什么样的server？ AWS上自己配么？我建一个供企业内部使用的dashboard website，外加一些web services，我打算买这个服务：
<a href="https://www.digitalocean.com/pricing/">https://www.digitalocean.com/pricing/</a>
4GBMemory
2 CoreProcessor
60GBSSD Disk
4TBTransfer</p>
<p>大神们有什么见解么？</p>
</div>

2015年五月4日上午 9:38:38
关于socket.io的问题
<div class="markdown-text"><p>今天在看node.js实战（吴海星 译）的时候，里面有段代码
<code>io.sockets.clients(room)</code>
这是什么意思？我在官方文档里也没找着<code>.clients</code>
谁能帮我解释一下啊？</p>
</div>

2015年五月4日早上 7:56:44
【译】PHP:40+开发工具推荐
<p>PHP是为Web开发设计的服务器脚本语言，但也是一种通用的编程语言。超过2.4亿个索引域使用PHP，包括很多重要的网站，例如Facebook、Digg和WordPress。和其它脚本语言相比，例如Python和Ruby，Web开发者有很多不错的理由皮偏爱PHP。<br>
对于PHP开发者，在互联网上有很多可用的开发工具，但是找到一个合适的PHP开发工具是很难的，需要花费很多努力和时间。今天，就为开发者介绍45个方便的PHP工具。</p>

<h3>Plates</h3>

<p><a rel="nofollow" href="http://platesphp.com/">Plates</a>是一个简单易用的PHP模板系统。Plates是为那些喜欢使用本地模板而不是编译模板的人设计的。</p>

<h3>Laravel</h3>

<p><a rel="nofollow" href="http://laravel.com/">Laravel</a>是一个有着优雅表达语言的开源框架。</p>

<h3>Parsedown</h3>

<p>一个Laravel的<a rel="nofollow" href="http://parsedown.org/">Parsedown</a>包装器，能够将markdown编译成HTML。Parsedown运行很快，并支持GitHub flavored markdown.</p>

<h3>Guzzle</h3>

<p><a rel="nofollow" href="http://docs.guzzlephp.org/en/latest/">Guzzle</a>是一个PHP版的HTTP客户端，让PHP很容易的和HTTP/1.1协议一起使用，并能减少Web服务带来的痛苦。</p>

<h3>Hoa</h3>

<p><a rel="nofollow" href="http://hoa-project.net/En/">Hoa</a>是一组PHP库，它创建了工业和研究之间的桥梁。</p>

<h3>PHP-CPP</h3>

<p><a rel="nofollow" href="http://www.php-cpp.com/">PHP-CPP</a>是一个C++写的PHP扩展库。它提供了一个良好的文档记录和易于使用的类的集合,可以使用和扩展构建本地PHP扩展。</p>

<h3>Twig</h3>

<p><a rel="nofollow" href="http://twig.sensiolabs.org/">Twig</a>是一个快速、安全和稳定的PHP模板引擎。</p>

<h3>Requests for PHP</h3>

<p><a rel="nofollow" href="http://requests.ryanmccue.info/">Requests</a>是用PHP写的HTTP库。</p>

<h3>The Prettifier</h3>

<p><a rel="nofollow" href="http://prettifier.net/">Prettifier</a>为一些编程语言，如CSS/HTMl/XML/PHP/SQL/Perl等，提供了一个在线编辑、格式和语言高亮的平台。</p>

<h3>Geocoder PHP</h3>

<p><a rel="nofollow" href="http://geocoder-php.org/Geocoder/">Geocoder</a>是一个构建geo应用很好的库，为geocoding操作提供了一个抽象层。</p>

<h3>Slim Starter</h3>

<p><a rel="nofollow" href="http://www.xsanisty.com/">Slim Starter</a>由Xsanisty创建，是创建高级Web应用的解决方案。</p>

<h3>Mink</h3>

<p><a rel="nofollow" href="http://mink.behat.org/en/latest/index.html">Mink</a>是一个PHP库，可以让你以交互的方式在浏览器中测试Web APP，它移除了两种浏览器模拟器之间的API差异，为你提供一个更准确的测试环境。</p>

<h3>Forp</h3>

<p><a rel="nofollow" href="http://anthonyterrien.com/forp/">Forp</a>是用C写的PHP分析器。Forp是轻量级的PHP扩展，它提供了一个简单的PHP数组或JSON输出，其包含了完整的脚本调用堆栈和CPU和内存使用情况。forp是非侵入性,并提供PHP注释来完成工作。</p>

<h3>Belt</h3>

<p>对PHP开发者来说，<a rel="nofollow" href="https://github.com/ilya-dev/belt">Belt</a>是一个非常有用的工具，它提供了超过60个有用的函数。</p>

<h3>Icon Generator for PHP</h3>

<p><a rel="nofollow" href="https://github.com/runmybusiness/initialcon">Icon Generator</a>允许你生成基于彩色背景的Icon图标，这和Gmail的类似。</p>

<h3>Rainloop</h3>

<p><a rel="nofollow" href="http://www.rainloop.net/">Rainloop</a>是一个免费开源的PHP Web邮件应用，它有现代的用户接口，支持SMTP + IMAP。</p>

<h3>Pattern Lab</h3>

<p><a rel="nofollow" href="http://patternlab.io/">Pattern Lab</a>不仅是一个前端框架，也是一个PHP驱动的静态网站生成器、项目模式库和前端风格指南。</p>

<h3>Composer</h3>

<p><a rel="nofollow" href="https://getcomposer.org/">Composer</a>是一个独立的PHP管理插件，在你项目的根目录创建一个组合器文件，再运行一个命令，则你所有的依赖都可以下载使用了。</p>

<h3>Directus</h3>

<p><a rel="nofollow" href="http://getdirectus.com/">Directus</a>是用Backbone.js创建的免费开源的、客户端友好的数据库GUI，它提供了丰富的功能用户快速开发和自定义数据库解决方案管理。</p>

<h3>PHP Debug Bar</h3>

<p><a rel="nofollow" href="http://phpdebugbar.com/">Debug</a>可以很容易的集成到任何项目中，并能显示来自应用任何部分的分析数据。它来自于PHP内置数据收集器的特性和受欢迎的项目。</p>

<h3>Phalcon PHP</h3>

<p><a rel="nofollow" href="http://phalconphp.com/en/">Phalcon PHP</a>是C扩展的一个Web框架，提供了高性能和低资源消耗。</p>

<h3>Pinboard</h3>

<p><a rel="nofollow" href="http://intaro.github.io/pinboard/">Pinboard</a>是一个MySQL存储引擎，为PHP的MYSQL使用情况提供了实时监控/统计数据服务的只读接口。</p>

<h3>Casebox</h3>

<p><a rel="nofollow" href="https://www.casebox.org/">Casebox</a>是一个开源的PHP/MYSQL驱动的Web应用，用于存储和管理记录、任务和文件。它有一个类似桌面的界面,我们可以创建一个unlimited-level目录用于优先存储结构化的东西。</p>

<h3>Munee</h3>

<p><a rel="nofollow" href="http://mun.ee/">Munee</a>是一个一体化库，开源处理很多与Web资源优化和操作相关的事情。Munee也有很强大的缓存功能，可以在服务器和客户端缓存资源。</p>

<h3>ImageWorkshop</h3>

<p><a rel="nofollow" href="http://phpimageworkshop.com/">ImageWorkshop</a>是一个基于GD库的开源类，可以帮助你用PHP管理图像。这个类很像PS、GIMP一类的图像编辑软件：你可以添加许多层或层组,每一层都有一个背景图像。</p>

<h3>Sylius</h3>

<p><a rel="nofollow" href="http://sylius.com/">Sylius</a>为PHP而设计的免费开源的电子商务解决方案（基于Symfony2），它能够管理任何规模的商店和复杂的产品类别。</p>

<h3>Pico</h3>

<p><a rel="nofollow" href="http://picocms.org/">Pico</a>是一个开源的CMS应用，没有多余的东西，这才是最重要的。它使用平面文件作为数据库，用PHP构建。简单的说，不用设置什么，这个APP就能运行。</p>

<h3>PHP MyFAQ</h3>

<p><a rel="nofollow" href="http://www.phpmyfaq.de/">PHP MyFAQ</a>是一个稳定开源的PHP F.A.Q. 应用，为构建一个很好的F.A.Q.系统提供了很多功能，并提供了强大的管理界面来管理类别、条目、用户和查看统计数据。A###PHP Documentor<br><a rel="nofollow" href="http://phpdoc.org/">PHP Documentor</a>能读取代码的结构,文件系统结构、类、函数和介于两者之间的,并生成文档。</p>

<h3>CakePHP</h3>

<p><a rel="nofollow" href="http://cakephp.org/">CakePHP</a>是一个开源的Web应用框架，遵循MVC模式，并有PHP编写。它仿照Ruby on Rails的概念,在MIT许可下发布的。</p>

<h3>CodeIgniter</h3>

<p><a rel="nofollow" href="http://www.codeigniter.com/">CodeIgniter</a>是一个强大的、开源的PHP框架。</p>

<h3>Monsta FTP</h3>

<p><a rel="nofollow" href="http://www.monstaftp.com/">Monsta FTP</a>是一个PHP云件，并能将FTP文件管理放置在Web浏览器中，你可以在浏览器中进行文件的拖放。</p>

<h3>XAMPP</h3>

<p><a rel="nofollow" href="https://www.apachefriends.org/index.html">XAMPP</a>是一个免费和开源的跨平台web服务器解决方案，主要包括Apache HTTP服务器、MySQL数据库、PHP和Perl编写的脚本解释器。</p>

<h3>NetBeans</h3>

<p><a rel="nofollow" href="https://netbeans.org/">NetBeans</a>是开源的，并允许你使用Java, HTML5, PHP, C/C++等快速开发桌面、移动和Web应用。</p>

<h3>Aura</h3>

<p><a rel="nofollow" href="http://auraphp.com/">Aura</a>为PHP5.4+提供了独立的库包。这些包可以单独使用,具有一致性、也能自我组合成一个完整的框架。</p>

<h3>PHPCheckstyle</h3>

<p><a rel="nofollow" href="https://phpcheckstyle.github.io/">PHPCheckstyle</a>是一个开源功能，能帮助PHP程序员保持一致的编码风格。该工具检查输入PHP源代码和报告任何违反给定的标准。</p>

<h3>PHP Mess Detector</h3>

<p><a rel="nofollow" href="http://phpmd.org/">PHP Mess Detector</a>易于配置，前端用户友好。它能检查代码中的潜在问题,包括可能的错误,次优的代码,未使用的参数,等等。</p>

<h3>Kohana</h3>

<p><a rel="nofollow" href="https://kohanaframework.org/">Kohana</a>一个基于PHP5的优雅的、开源和面向对象HMVC框架,由一群志愿者维护和开发。它的目标是迅速,安全,和轻量。</p>

<h3>Sabberworm</h3>

<p>用PHP编写的一个CSS文件解析器。<a rel="nofollow" href="http://www.sabberworm.com/blog/2010/6/10/php-css-parser">Sabberworm</a>允许提取CSS文件到一个数据结构,操纵结构和输出(优化的)CSS。</p>

<h3>Nette</h3>

<p><a rel="nofollow" href="http://nette.org/en/">Nette</a>框架是一个PHPweb开发的工具。它被设计成尽可能友好、易用。它侧重于安全性和性能，绝对是最安全的PHP开发框架之一。</p>

<h3>PHP Markdown</h3>

<p>这是一个库包，包含了<a rel="nofollow" href="https://michelf.ca/projects/php-markdown/">PHP Markdown</a>解析器和额外的功能扩展。Markdown是一个text-to-html的转换工具。</p>

<h3>Yii 2</h3>

<p><a rel="nofollow" href="http://www.yiiframework.com/">Yii 2</a>完整重写它的先前版本1.1,Yii也是最流行的PHP开发框架之一。Yii是一个高性能的PHP框架，最适合开发Web 2.0应用程序。</p>

<h3>PHP Sandbox</h3>

<p><a rel="nofollow" href="https://github.com/fieryprophet/php-sandbox">PHP Sandbox</a>利用PHPParser来防止沙箱运行不安全的代码。它利用FunctionParser分解传递到沙箱的调用,这样，即使没有转换成字符串，PHP调用也可以在沙箱中运行。</p>

<p>译文出处：<a rel="nofollow" href="http://www.ido321.com/1546.html"></a><a rel="nofollow" href="http://www.ido321.com/1546.html">http://www.ido321.com/1546.html</a></p>

<p>英文原文：<a rel="nofollow" href="http://www.developerdrive.com/2015/03/40-tools-for-writing-better-php/">40+ tools for writing better PHP</a></p>

2015年五月3日晚上 8:57:23
HT for Web的HTML5树组件延迟加载技术实现
<p><a rel="nofollow" href="http://www.hightopo.com/">HT for Web</a>的<a rel="nofollow" href="http://www.hightopo.com/">HTML5树组件</a>有延迟加载的功能，这个功能对于那些需要从服务器读取具有层级依赖关系数据时非常有用，需要获取数据的时候再向服务器发起请求，这样可减轻服务器压力，同时也减少了浏览器的等待时间，让页面的加载更加流畅，增强用户体验。<br>
进入正题，今天用来做演示的Demo是，客户端请求服务器读取系统文件目录结构，通过<a rel="nofollow" href="http://www.hightopo.com/">HT for Web</a>的HTML5树组件显示系统文件目录结构。<br>
首先，我们先来设计下服务器，这次Demo的服务器采用<a rel="nofollow" href="https://nodejs.org/">Node.js</a>，用到了Node.js的<a rel="nofollow" href="http://expressjs.com/">express</a>、<a rel="nofollow" href="http://socket.io/get-started/chat/">socket.io</a>、fs和http这四个模块，<a rel="nofollow" href="https://nodejs.org/">Node.js</a>的相关知识，我在这里就不阐述了，网上的教材一堆，这里推荐下<a rel="nofollow" href="http://socket.io/get-started/chat/">socket.io</a>的相关入门<a rel="nofollow" href="http://socket.io/get-started/chat/">http://socket.io/get-started/chat/</a>。<br>
服务端代码代码：</p>

<pre><code>var fs = require('fs'),
    express = require('express'),
    app = express(),
    server = require('http').createServer(app),
    io = require('socket.io')(server),
    root = ‘/Users/admin/Projects/ht-for-web/guide‘;

io.on('connection', function(socket){
    socket.on('explore', function(url){
        socket.emit('file', walk(url || root));
    });
});

app.use(express.static('/Users/admin/Projects/ht-for-web'));

server.listen(5000, function(){
    console.log('server is listening at port 5000');
});
</code></pre>

<p>io监听了connection事件，并获得一个socket；socket再监听一个叫explore的自定义事件，通过url参数获取到数据后，派发一个叫file的自定义事件，供客户端监听并做相应处理；通过app.use结合express.static设置项目路径；最后让server监听5000端口。<br>
到此，一个简单的服务器就搭建好了，现在可以通过<a rel="nofollow" href="http://localhost:5000">http://localhost:5000</a>来访问服务器了。等等，好像缺了点什么。对了，获取系统文件目录结构的方法忘记给了，OK，那么我们就先来看看获取整站文件的代码是怎么写的：</p>

<pre><code>function walk(pa) {
    var dirList = fs.readdirSync(pa),
        key = pa.substring(pa.lastIndexOf('/') + 1),
        obj = {
            name: key,
            path: pa,
            children: [],
            files: []
        };
    dirList.forEach(function(item) {
        var stats = fs.statSync(pa + '/' + item);
        if (stats.isDirectory()) {
            obj.children.push(walk(pa + '/' + item));
        }
        else {
            obj.files.push({name: item, dir: pa + '/' + item});
        }
    });

    return obj;
}
</code></pre>

<p>如大家所见，采用递归的方式，逐层遍历子目录，代码也没什么高深的地方，相信大家都看得懂。那我们来看看运行效果吧：<br><img src="/img/bVlAVN" alt="031953507553944.png"><br>
duang～文件目录结构出来了，是不是感觉酷酷的，这代码量不小吧。其实，代码并不多，贴出来大家瞅瞅：</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head lang="en"&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;tree-loader&lt;/title&gt;
    &lt;script src="/socket.io/socket.io.js"&gt;&lt;/script&gt;
    &lt;script src="/lib/core/ht.js"&gt;&lt;/script&gt;
    &lt;script&gt;
        var socket = io(), idMap = {};
        function init() {
            var dm = window.dm = new ht.DataModel(),
                    tree = new ht.widget.TreeView(dm);

            tree.addToDOM();

            socket.on('file', function(data) {
                var root = dm.getDataById(idMap[data.path]);
                createChildren(data.children || [], root, dm);
                createFiles(data.files || [], root, dm);
            });
            socket.emit('explore');
        }

        function createChildren(children, parent, dm) {
            children.forEach(function(child) {
                var n = createData(child, parent);
                dm.add(n);
                createChildren(child.children || [], n, dm);
                createFiles(child.files || [], n, dm);
            });
        }

        function createFiles(files, parent, dm){
            files.forEach(function(file){
                var n = createData(file, parent);
                dm.add(n);
            });
        }

        function createData(data, parent){
            var n = new ht.Data();
            n.setName(data.name);
            n.setParent(parent);
            n.a('path', data.path);
            idMap[data.path] = n.getId();
            return n;
        }
    &lt;/script&gt;
&lt;/head&gt;
&lt;body onload="init();"&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>这就是全部的HTML代码，加上空行总共也就50几行，怎么样，有没有感觉<a rel="nofollow">HT for Web</a>很强大。废话不多说，来看看这些代码都干了些什么：</p>

<ul>
<li><p>要用到<a rel="nofollow" href="http://socket.io/get-started/chat/">socket.io</a>就需要在页面引入&lt;script src=“/socket.io/socket.io.js”&gt;&lt;/script&gt;，其实在我的项目中并不存在/socket.io/socket.io.js文件，但是却能正常使用，具体什么原因，我就不多说，大家自己研究去吧；</p></li>
<li><p>最重要的是要引入<a rel="nofollow" href="http://www.hightopo.com/">HT for Web</a>的核心包&lt;script src=“/lib/core/ht.js”&gt;&lt;/script&gt;，这个包不引入的话，下面的HT for Web组件就无法使用；</p></li>
<li><p>接下来就是代码了，首先创建一个数据容器<a rel="nofollow" href="http://www.hightopo.com/">DataModel</a>，用来存放文件目录的节点数据，再创建一个<a rel="nofollow" href="http://www.hightopo.com/">TreeView</a>对象并引用刚创建到数据容器，接下来通过socket监听file事件，获取服务器返回的数据，在回调函数中通过调用createChildren和createFiles函数，创建文件目录节点对象，并添加到数据容器中，最后是向服务器发起数据请求，即通过socket派发explore事件。</p></li>
</ul>
<p>整体的思路是这样子的，当然这离我们要实现的树组件的延迟加载技术还有些差距，那么，<a rel="nofollow" href="http://www.hightopo.com/">HT for Web的HTML5树组件</a>的延迟加载技术是怎么实现的呢？不要着急，马上开始探讨。<br>
首先我们需要改造下获取文件目录的方法walk，因为前面介绍的方法中，使用的是加载整站文件目录，所以我们要将walk方法改造成只获取一级目录结构，改造起来很简单，就是将递归部分改造成获取当前节点就可以了，具体代码如下：</p>

<pre><code>obj.children.push(walk(pa + '/' + item));
// 将上面对代码改成下面的代码
obj.children.push({name: item, path: pa + '/' + item});
</code></pre>

<p>这样子服务器就只请求当前请求路径下的第一级文件目录结构。接下来就是要调整下客户端代码了，首先需要给tree设置上loader:</p>

<pre><code>tree.setLoader({
    load: function(data) {
        socket.emit('explore', data.a('path'));
        data.a('loaded', true);
    },
    isLoaded: function(data) {
        return data.a('loaded');
    }
});
</code></pre>

<p>loader包含了两个方法，load和isLoaded，这两个方法的功能分别是加载数据和判断数据是否已经加载，在load方法中，对socket派发explore事件，当前节点的path为参数，向服务器请求数据，之后将当前节点的loaded属性设置为true；在isLoaded方法中，返回当前节点的loaded属性，如果返回为true，那么<a rel="nofollow" href="http://www.hightopo.com/">tree</a>将不会在执行load方法向服务器请求数据。<br>
接下来需要移除createChildren的两个回调方法，并且在createFiles方法中为创建出来的节点的loaded属性设置成true，这样在不是目录的节点前就不会有展开的图标。createChildren和createFiles两个方法修改后的代码如下：</p>

<pre><code>function createChildren(children, parent, dm) {
    children.forEach(function(child) {
        var n = createData(child, parent);
        dm.add(n);
    });
}

function createFiles(files, parent, dm){
    files.forEach(function(file){
        var n = createData(file, parent);
        n.a('loaded', true);
        dm.add(n);
    });
}
</code></pre>

<p>如此，<a rel="nofollow" href="http://www.hightopo.com/">HT for Web的HTML5树组件</a>延迟加载技术就设计完成了，我在服务器的控制台打印出请求路径，看看这个延迟加载是不是真的，如下图：<br><img src="/img/bVlAVS" alt="031957283802225.png"><br><img src="/img/bVlAVU" alt="031958228967071.png"><br>
看吧，控制台打印的是4条记录，第一条是请求跟目录时打印的，我在浏览器中展开里三个目录，在控制台打印了其对应的目录路径。<br>
等等，现在这个目录看起来好烦，只有文字，除了位子前的展开图标可以用来区别文件和目录外，没有其他什么区别，所以我决定对其进行一番改造，让每一级目录都有图标，而且不同文件对应不同的图标，来看看效果吧：<br><img src="/img/bVlAVW" alt="031959440051625.png"><br>
怎么样，是不是一眼就能看出是什么文件，这个都是样式上面的问题，我就不再一一阐述了，直接上代码：</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head lang="en"&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;script src="/socket.io/socket.io.js"&gt;&lt;/script&gt;
    &lt;script src="/build/ht-debug.js"&gt;&lt;/script&gt;
    &lt;script&gt;
        var socket = io(), idMap = {};
        function init() {
            var icons = ['css', 'dir-open', 'dir', 'file', 'flash', 'gif', 'html', 'jar',
                'java', 'mp3', 'pdf', 'png', 'script', 'txt', 'video', 'xml', 'zip'];
            icons.forEach(function(c){
                ht.Default.setImage(c, 16, 16, '/test/wyl/images/' + c + '.png');
            });

            var dm = window.dm = new ht.DataModel(),
                    tree = new ht.widget.TreeView(dm);
            tree.setLoader({
                load: function(data) {
                    socket.emit('explore', data.a('path'));
                    data.a('loaded', true);
                },
                isLoaded: function(data) {
                    return data.a('loaded');
                }
            });
            tree.getLabelFont = function(data){
                return '13px Helvetica, Arial, sans-serif';
            };
            tree.getLabelColor = function (data) {
                return this.isSelected(data) ? 'white' : 'black';
            };
            tree.getSelectBackground = function (data) {
                return '#408EDB';
            };
            tree.getIcon = function (data) {
                var icon = data.getIcon() || 'file';
                if (data.a('isdir')) {
                    if (this.isExpanded(data)) {
                        icon = 'dir-open';
                    } else {
                        icon = 'dir';
                    }
                }
                return icon;
            };
            tree.addToDOM();

            socket.on('file', function(data) {
                var root = dm.getDataById(idMap[data.path]);
                createChildren(data.children || [], root, dm);
                createFiles(data.files || [], root, dm);
            });
            socket.emit('explore');
        }

        function createChildren(children, parent, dm) {
            children.forEach(function(child) {
                var n = createData(child, parent);
                n.a('isdir', true);
                dm.add(n);
            });
        }

        function createFiles(files, parent, dm){
            files.forEach(function(file){
                var n = createData(file, parent);
                n.a('loaded', true);
                dm.add(n);
            });
        }

        function createData(data, parent){
            var name = data.name,
                    icon = 'file';
            if (/.jar$/.test(name)) icon = 'jar';
            else if (/.css$/.test(name)) icon = 'css';
            else if (/.gif$/.test(name)) icon = 'gif';
            else if (/.png$/.test(name)) icon = 'png';
            else if (/.js$/.test(name)) icon = 'script';
            else if (/.html$/.test(name)) icon = 'html';
            else if (/.zip$/.test(name)) icon = 'zip';
            var n = new ht.Data();
            n.setName(data.name);
            n.setParent(parent);
            n.setIcon(icon);
            n.a('path', data.path);
            idMap[data.path] = n.getId();
            return n;
        }
    &lt;/script&gt;
&lt;/head&gt;
&lt;body onload="init();"&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>在最后，附上完整的服务器代码：</p>

<pre><code>var fs = require('fs'),
    express = require('express'),
    app = express(),
    server = require('http').createServer(app),
    io = require('socket.io')(server),
    root = '/Users/admin/Projects/ht-for-web/guide';

io.on('connection', function(socket){
    socket.on('explore', function(url){
        socket.emit('file', walk(url || root));
    });
});

app.use(express.static('/Users/admin/Projects/ht-for-web'));

server.listen(5000, function(){
    console.log('server is listening at port 5000');
});

function walk(pa) {
    var dirList = fs.readdirSync(pa),
        key = pa.substring(pa.lastIndexOf('/') + 1),
        obj = {
            name: key,
            path: pa,
            children: [],
            files: []
        };
    dirList.forEach(function(item) {
        var stats = fs.statSync(pa + '/' + item);
        if (stats.isDirectory()) {
            obj.children.push({name: item, path: pa + '/' + item});
        }
        else {
            obj.files.push({name: item, dir: pa + '/' + item});
        }
    });

    return obj;
}
</code></pre>

2015年五月3日晚上 8:05:17
改造了一个Markdown在线编辑器，现在它终于让我感到完美了！
<p><a rel="nofollow" href="http://segmentfault.com/">http://segmentfault.com/</a> 怎么老是莫名其妙地挂掉？网页会莫名其妙地打不开。<br>
好吧，我且不说这事了。今天我花了一天时间在改造一个Markdown 在线编辑器，终于把它改造得满符合我的想法了。哈哈，好有成就感。我曾经在网上试用了很多markdown在线编辑器，发现绝大部分都有一个毛病：在输入框里敲下Tab键，它不是自动插入一个tab制表符，而是焦点自动跳到下一个链接处了。这对经常要写代码的我简直是抓狂。好在我终于找到了一个在线编辑器 <a rel="nofollow" href="http://lab.lepture.com/editor/">http://lab.lepture.com/editor/</a>，它对Tab键的处理恰好好处。但是我觉得还不够完美，于是自己动手改造它。<br>
先说下我做了点什么修改，看图：<br><img src="/img/bVlASH" alt="图片描述"><br>
我加了一几个按钮：插入视频，插入音乐，插入代码，并为它们一一分配了快捷键。并且还为Ctrl+S分配了快速提交功能。<br>
其次是粘贴功能，这是我今天改造的重头戏。我觉得把网页上的内容粘贴到这个在线编辑器里，还得手工把它修改成Markdown代码，太费事了。于是希望能够自动完成。另外，上传图片，本来它是没有图片上传功能的，只能手工输入图片地址。费事啊！我也把这个功能集成到粘贴功能里了。<br>
首先，需要在在线编辑器中绑定<code>onPaste</code>事件。<br>
我看到那个editor.js中第1580行中有<code>onKeyPress</code>事件绑定。我先给它加了一个<code>onPaste</code>事件绑定。</p>

<pre><code>javascript</code><code>    on(d.input, "input", bind(fastPoll, cm));
    on(d.input, "keydown", operation(cm, onKeyDown));
    on(d.input, "keypress", operation(cm, onKeyPress));
    on(d.input, "paste", operation(cm,onPaste)); // 这句是我添加的
    on(d.input, "focus", bind(onFocus, cm));
    on(d.input, "blur", bind(onBlur, cm));
</code></pre>

<p>然后 ，需要写一个<code>onPaste</code>函数。我把它写在onKeyPress函数后面。<br>
我先是想实现在粘贴时自动把HTML代码转换成Markdown的功能。于是写了这么一个函数。</p>

<pre><code>javascript</code><code>   function onPaste(e){
       if(!e.clipboardData)return true;
       //IE浏览器不支持e.clipboardData对象，无奈
       if(e.clipboardData.types=='text/plain')return true;
       // 如果剪贴板中的内容是纯文本内容，直接粘贴。
       else if(e.clipboardData.types=='text/plain,text/html'){
       // 如果剪贴板中的内容是HTML内容，则需要对它进行一番改造
       var html=e.clipboardData.getData('text/html');
       html=html.replace(/&lt;html&gt;(\r?\n)+&lt;body&gt;(\r?\n)+&lt;!--StartFragment--&gt;(.*?)&lt;!--EndFragment--&gt;(\r?\n)+&lt;\/body&gt;(\r?\n)+&lt;\/html&gt;/,"$3");
       html=toMarkdown(html);
       // toMarkdown函数 http://segmentfault.com/a/1190000002723901 在这里已经写了
       var cm=this;
        _replaceSelection(cm, false, html,'');
       e.preventDefault();
       }
     }
</code></pre>

<p>这里有一个很详细的剪贴板js原生对象的介绍：<a rel="nofollow" href="http://wizard.ae.krakow.pl/~jb/localio.html">http://wizard.ae.krakow.pl/~jb/localio.html</a><br>
本来这样算是大功告成了，但是我又觉得还有点不甘心，因为我希望以后粘贴图片方便点。<br>
于是我继续修改这个<code>onPaste</code>函数，并加了一个图片上传功能。</p>

<pre><code>javascript</code><code>   function onPaste(e){
       if(!e.clipboardData)return true;
       if(e.clipboardData.types=='text/plain')return true;
       else if(e.clipboardData.types=='text/plain,text/html'){
       var html=e.clipboardData.getData('text/html');
       html=html.replace(/&lt;html&gt;(\r?\n)+&lt;body&gt;(\r?\n)+&lt;!--StartFragment--&gt;(.*?)&lt;!--EndFragment--&gt;(\r?\n)+&lt;\/body&gt;(\r?\n)+&lt;\/html&gt;/,"$3");
       html=toMarkdown(html);
       var cm=this;
        _replaceSelection(cm, false, html,'');
       e.preventDefault();
       }
       else if(e.clipboardData.types=='text/html,Files'){
        imgReader(e.clipboardData.items[1])
           e.preventDefault();
           }
        else if(e.clipboardData.types=='Files'){
           imgReader(e.clipboardData.items[0])
        }
      }

  function imgReader(item){
      if(item.kind=='file'&amp;&amp;item.type=='image/png'){
      var file = item.getAsFile(),reader = new FileReader();
      reader.onload = function( e ){
        var img = new Image();
        img.src = e.target.result;
        document.body.appendChild( img );
        // 把图片放在网页最下面，以便预览
        $.post('saveremoteimg.php',{'urls':e.target.result},function(data){
            _replaceSelection(editor.codemirror,false , '![', ']('+data+')\n');
            })
        };
    reader.readAsDataURL(file);
    }
};
</code></pre>

<p>saveremoteimg.php的源码是：</p>

<pre><code>php</code><code>&lt;?php
header('Content-Type: text/html; charset=UTF-8');
$attachDir='upload';//上传文件保存路径，结尾不要带/
$dirType=1;//1:按天存入目录 2:按月存入目录 3:按扩展名存目录  建议使用按天存
$maxAttachSize=2097152;//最大上传大小，默认是2M
$upExt="jpg,jpeg,gif,png";//上传扩展名
ini_set('date.timezone','Asia/Shanghai');//时区

//保存远程文件
function saveRemoteImg($sUrl){
    global $upExt,$maxAttachSize;
    $reExt='('.str_replace(',','|',$upExt).')';
    if(substr($sUrl,0,10)=='data:image'){//base64编码的图片，可能出现在firefox粘贴，或者某些网站上，例如google图片
        if(!preg_match('/^data:image\/'.$reExt.'/i',$sUrl,$sExt))return false;
        $sExt=$sExt[1];
        $imgContent=base64_decode(substr($sUrl,strpos($sUrl,'base64,')+7));
    }
    else{//url图片
        if(!preg_match('/\.'.$reExt.'$/i',$sUrl,$sExt))return false;
        $sExt=$sExt[1];
        $imgContent=getUrl($sUrl);
    }
    if(strlen($imgContent)&gt;$maxAttachSize)return false;//文件体积超过最大限制
    $sLocalFile=getLocalPath($sExt);
    file_put_contents($sLocalFile,$imgContent);
    //检查mime是否为图片，需要php.ini中开启gd2扩展
    $fileinfo= @getimagesize($sLocalFile);
    if(!$fileinfo||!preg_match("/image\/".$reExt."/i",$fileinfo['mime'])){
        @unlink($sLocalFile);
        return false;
    }
    return $sLocalFile;
}
//抓URL数据
function getUrl($sUrl,$jumpNums=0){
    $arrUrl = parse_url(trim($sUrl));
    if(!$arrUrl)return false;
    $host=$arrUrl['host'];
    $port=isset($arrUrl['port'])?$arrUrl['port']:80;
    $path=$arrUrl['path'].(isset($arrUrl['query'])?"?".$arrUrl['query']:"");
    $fp = @fsockopen($host,$port,$errno, $errstr, 30);
    if(!$fp)return false;
    $output="GET $path HTTP/1.0\r\nHost: $host\r\nReferer: $sUrl\r\nConnection: close\r\n\r\n";
    stream_set_timeout($fp, 60);
    @fputs($fp,$output);
    $Content='';
    while(!feof($fp))
    {
        $buffer = fgets($fp, 4096);
        $info = stream_get_meta_data($fp);
        if($info['timed_out'])return false;
        $Content.=$buffer;
    }
    @fclose($fp);
    global $jumpCount;//重定向
    if(preg_match("/^HTTP\/\d.\d (301|302)/is",$Content)&amp;&amp;$jumpNums&lt;5)
    {
        if(preg_match("/Location:(.*?)\r\n/is",$Content,$murl))return getUrl($murl[1],$jumpNums+1);
    }
    if(!preg_match("/^HTTP\/\d.\d 200/is", $Content))return false;
    $Content=explode("\r\n\r\n",$Content,2);
    $Content=$Content[1];
    if($Content)return $Content;
    else return false;
}
//创建并返回本地文件路径
function getLocalPath($sExt){
    global $dirType,$attachDir;
    switch($dirType)
    {
        case 1: $attachSubDir = 'day_'.date('ymd'); break;
        case 2: $attachSubDir = 'month_'.date('ym'); break;
        case 3: $attachSubDir = 'ext_'.$sExt; break;
    }
    $newAttachDir = $attachDir.'/'.$attachSubDir;
    if(!is_dir($newAttachDir))
    {
        @mkdir($newAttachDir, 0777);
        @fclose(fopen($newAttachDir.'/index.htm', 'w'));
    }
    PHP_VERSION &lt; '4.2.0' &amp;&amp; mt_srand((double)microtime() * 1000000);
    $newFilename=date("YmdHis").mt_rand(1000,9999).'.'.$sExt;
    $targetPath = $newAttachDir.'/'.$newFilename;
    return $targetPath;
}

$arrUrls=explode('|',$_POST['urls']);
$urlCount=count($arrUrls);
for($i=0;$i&lt;$urlCount;$i++){
    $localUrl=saveRemoteImg($arrUrls[$i]);
    if($localUrl)$arrUrls[$i]=$localUrl;
}
echo implode('|',$arrUrls);
?&gt;
</code></pre>

<p>想一想觉得还有点想改造的。在行内插入代码是需要在文字左右加两个点（键盘上Tab键上方的那个键），但是我发现在中文输入法中，它是自动打出·的，需要切换到英文输入状态才能打出想要的那个点。多敲一次键盘对我来说都是抓狂。我必须继续改造它，让它能像切换粗体或斜体那样用快捷键来实现。<br>
这倒好办。再写一个 toggleCode函数，添加在toggleItalic 函数下面：</p>

<pre><code>javascript</code><code>function toggleCode(editor) {
  var cm = editor.codemirror;
  var stat = getState(cm);

  var text;
  var start = '`';
  var end = '`';

  var startPoint = cm.getCursor('start');
  var endPoint = cm.getCursor('end');
  if (stat.code) {
    text = cm.getLine(startPoint.line);
    start = text.slice(0, startPoint.ch);
    end = text.slice(startPoint.ch);
    start = start.replace(/^(.*)?(`)(\S+.*)?$/, '$1$3');
    end = end.replace('`','');
    startPoint.ch -= 1;
    endPoint.ch -= 1;
    cm.setLine(startPoint.line, start + end);
  } else {
    text = cm.getSelection();
    cm.replaceSelection(start + text + end);

    startPoint.ch += 1;
    endPoint.ch += 1;
  }
  cm.setSelection(startPoint, endPoint);
  cm.focus();
}
</code></pre>

<p>然后在shortcuts数组中添加一项<code>'Cmd-Y': toggleCode</code>，改成这样子：</p>

<pre><code>javascript</code><code>var shortcuts = {
  'Cmd-B': toggleBold,
  'Cmd-I': toggleItalic,
  'Cmd-Y': toggleCode,  // 这项是我加的
  'Cmd-K': drawLink,
  'Cmd-Alt-I': drawImage,
  'Cmd-Q': drawCode, // 这项也是我加入的
  'Cmd-\'': toggleBlockquote,
  'Cmd-Alt-L': toggleOrderedList,
  'Cmd-L': toggleUnOrderedList,
  'Cmd-P': togglePreview
};
</code></pre>

<p>与此同时，getStatus函数需要改成这样：</p>

<pre><code>javascript</code><code>function getState(cm, pos) {
  pos = pos || cm.getCursor('start');
  var stat = cm.getTokenAt(pos);
  if (!stat.type) return {};

  var types = stat.type.split(' ');

  var ret = {}, data, text;
  for (var i = 0; i &lt; types.length; i++) {
    data = types[i];
    if (data === 'strong') {
      ret.bold = true;
    } else if (data === 'variable-2') {
      text = cm.getLine(pos.line);
      if (/^\s*\d+\.\s/.test(text)) {
        ret['ordered-list'] = true;
      } else {
        ret['unordered-list'] = true;
      }
    } else if (data === 'atom') {
      ret.quote = true;
    } else if (data === 'comment'){ // 这句是我加上去的
      ret.code = true;   // 这句也是我加上去的
    } else if (data === 'em') {
      ret.italic = true;
    }
  }
  return ret;
}
</code></pre>

<p>我觉得工具栏中没有按钮提示很不好。于是改改改~，改成下面这样：</p>

<pre><code>javascript</code><code>var toolbar = [
  {name: 'bold', action: toggleBold, shortcut:'Toggle Bold(Cmd-B)'},
  {name: 'italic', action: toggleItalic, shortcut:'Toggle Italic(Cmd-I)'},
  '|',

  {name: 'quote', action: toggleBlockquote, shortcut: 'toggle Blockquote(Cmd-\')'},
  {name: 'unordered-list', action: toggleUnOrderedList, shortcut:'Toggle UnorderList(Cmd-Alt-L)'},
  {name: 'ordered-list', action: toggleOrderedList, shortcut:'Toggle OrderList(Cmd-L)'},
  '|',

  {name: 'link', action: drawLink, shortcut:'Insert Link(Cmd-K)'},
  {name: 'image', action: drawImage, shortcut: 'Insert Image(Cmd-Alt-I)'},
  {name: 'play', action: drawVideo, shortcut: 'Insert Video'},
  {name: 'music', action: drawAudio, shortcut: 'Insert Audio'},
  {name: 'code', action: drawCode, shortcut: 'Insert Code(Cmd-Q)'},
  '|',

  {name: 'info', action: 'http://lab.lepture.com/editor/markdown'},
  {name: 'preview', action: togglePreview, shortcut: 'Toggle Preview'},
  {name: 'fullscreen', action: toggleFullScreen, shortcut: 'Toggle FullScreen'}
];

</code></pre>

<p>其实我发现原来的程序里有个小bug，就是用Ctrl+B或者Ctrl+I切换粗体、斜体的时候，第一次按Ctrl+B，会在选中块去的前后各加两个星号，而第二次按Ctrl+B的时候，前面的星号去掉了，后面的星号却没变化。我仔细看，发现原来的代码中正则表达式写错了。<br>
我修改了<code>toggleBold</code>和<code>toggleItalic</code>函数，现在总算正常了。</p>

<pre><code>javascript</code><code>function toggleBold(editor) {
  var cm = editor.codemirror;
  var stat = getState(cm);

  var text;
  var start = '**';
  var end = '**';

  var startPoint = cm.getCursor('start');
  var endPoint = cm.getCursor('end');
  if (stat.bold) {
    text = cm.getLine(startPoint.line);
    start = text.slice(0, startPoint.ch);
    end = text.slice(startPoint.ch);

    start = start.replace(/^(.*)?(\*|\_){2}(\S+.*)?$/, '$1$3');
    end = end.replace(/(\*|\_){2}/, '');// 这句是我修改过的
    startPoint.ch -= 2;
    endPoint.ch -= 2;
    cm.setLine(startPoint.line, start + end);
  } else {
    text = cm.getSelection();
    cm.replaceSelection(start + text + end);

    startPoint.ch += 2;
    endPoint.ch += 2;
  }
  cm.setSelection(startPoint, endPoint);
  cm.focus();
}

function toggleItalic(editor) {
  var cm = editor.codemirror;
  var stat = getState(cm);

  var text;
  var start = '*';
  var end = '*';

  var startPoint = cm.getCursor('start');
  var endPoint = cm.getCursor('end');
  if (stat.italic) {
    text = cm.getLine(startPoint.line);
    start = text.slice(0, startPoint.ch);
    end = text.slice(startPoint.ch);

    start = start.replace(/^(.*)?(\*|\_)(\S+.*)?$/, '$1$3');
    end = end.replace(/(\*|\_)/, ''); // 这句是我修改过的
    startPoint.ch -= 1;
    endPoint.ch -= 1;
    cm.setLine(startPoint.line, start + end);
  } else {
    text = cm.getSelection();
    cm.replaceSelection(start + text + end);

    startPoint.ch += 1;
    endPoint.ch += 1;
  }
  cm.setSelection(startPoint, endPoint);
  cm.focus();
}
</code></pre>

<p>现在很疲惫，不过总算改得令自己满意了。掌柜的站长也改进一下segmentfault.com的在线编辑器吧。</p>

2015年五月3日晚上 7:11:25
总是出问题的Crontab
<p>最近用Python写了一些数据统计的脚本，并使用crontab自动执行，但是配置crontab总是要过几个坑才行的，这里总结一下这次遇到的坑。</p>

<h2>输出</h2>

<p>要将crontab命令的输出记录到日志文件中，可以使用重定向，不仅要重定向<code>stdout</code>也要重定向<code>stderr</code>，因为Python解释器会将异常输出到<code>stderr</code>。示例：</p>

<pre><code>$HOME/path/to/script &gt; $HOME/log/file 2&gt;&amp;1
</code></pre>

<h2>环境变量</h2>

<p>crontab会以用户的身份执行配置的命令，但是不会加载用户的环境变量，crontab会设置几个默认的环境变量，例如SHELL、PATH和HOME等，一定要注意PATH可不是用户自定义的PATH。</p>

<p>我们往往会在<code>.bash_profile</code>文件中定义一些全局的环境变量，但是crontab执行时并不会加载这个文件，所以你在shell中正常执行的程序，放到crontab里就不行了，很可能就是因为找不到环境变量了。要解决这个问题只能是自己加载环境变量了，可以在shell脚本中添加<code>source $HOME/.bash_profile</code>，或者直接添加到crontab中。</p>

<pre><code>0 12 * * * source $HOME/.bash_profile &amp;&amp; $HOME/path/to/script &gt; $HOME/log/file 2&gt;&amp;1
</code></pre>

<h2>路径</h2>

<p>我们在写脚本时往往会使用相对路径，但是在crontab执行脚本时，由于工作目录不同，就会出现找不到文件或者目录不存在的问题。</p>

<p>解决方法是脚本中使用绝对路径或者在执行程序前切换工作目录，例如直接在crontab命令中切换工作目录：</p>

<pre><code>0 12 * * * source $HOME/.bash_profile &amp;&amp; cd $HOME/path/to/workdir &amp;&amp; ./script &gt; /HOME/log/file 2&gt;&amp;1
</code></pre>

<h2>编码</h2>

<p>我写的Python程序中输出了一些中文（编码是utf-8），在shell中直接执行没有问题，但是crontab执行时出现了UnicodeEncodeError的错误，Google了一下发现这个问题不仅仅是在crontab中会出现，在使用管道或者重定向的时候都会出现这个问题，原因是编码不同。</p>

<p>在终端中直接执行Python程序时，Python会将输出内容自动编码为终端所使用的编码，我使用的终端编码是utf-8，所以不会出错，输出的内容也是正常的。但是在使用管道或者重定向时，编码格式为ascii，Python会用ascii编码格式去encode输出的字符串，但是字符串的编码使用的时utf-8，所以会出现UnicodeEncodeError的错误。</p>

<p>解决方法：<br>
方法一：在程序中输出的字符串都加上<code>encode('utf-8')</code>；<br>
方法二：在crontab中加上<code>PYTHONIOENCODING=utf-8</code>，将Python的<code>stdout/stderr/stdin</code>编码设置为utf-8。</p>

2015年五月3日下午 5:22:24
关于 Monad 的学习笔记
<p>假期终于看明白了 Monad, 这个关卡卡了好几年了, 终于过了<br>
我现在只能说初步了解到 Monad, 不够深入, 打算留一点笔记下来</p>

<p>现在回头看, 如果从前学习得法的话, 最快可能几天或者几周就搞定的<br>
比如说有 Node.js 那样成熟的社区跟教程, 或者公司里有就有人教的话<br>
此前在 Haskell 中文论坛问过, 知乎问过, 微博私信问过, 英文教程也看了<br>
总体上 Monad 就成了越来越吸引我注意力的一个概念</p>

<h3>Rich Hichey 的影响</h3>

<p>我强烈推荐 Rich Hickey 的演讲, 因为我觉得他非常有智慧<br><a rel="nofollow" href="https://github.com/matthiasn/talk-transcripts/tree/master/Hickey_Rich">https://github.com/matthiasn/talk-transcripts/tree/master/Hickey_Rich</a><br>
虽然很多是我听不懂的, 但让我能从更高的层次去理解函数式编程为什么好<br>
比如说变量的问题, 他讲了好多例子, 讲清楚数据会发生改变是不可靠的<br>
还有保持简单对于系统的可靠性会带来多大改善, 为什么面向对象有问题<br>
好吧大部分是我听不懂, 但感觉很有启发</p>

<p>过程式编程是直观的, 但也是很存在问题的, 特别是学了函数式编程再回头看<br>
比如说 <code>null</code> 值的问题, 看似自然而然, 实际却是考虑不够严谨<br>
还有语句(或者说指令)按顺序执行的问题, 也很自然, 实际却考虑不足<br>
这类问题导致我们在编写代码过程中不断发现有特殊的情况需要回头考虑<br>
诚然迎合了新人学习编程所需的方便, 可代价却是对代码控制流的操作不够强大</p>

<p>我不否认有丰富经验跟能力的程序员能用过程式代码写出极为可靠的程序<br>
然而引入函数式编程强大的复合能力, 有可能让程序变得更加简短清晰<br>
而且如同 Haskell 这样搭配类型系统, 能让难以理解的过程稍微变得直观一些<br>
当然, 函数式编程所需的抽象能力真的不是为新手准备的, 这带来巨大的门槛</p>

<h3>纯函数</h3>

<p>要理解 Monad 首先要对纯函数有足够的认识, 我假设读者有了解过 Haskell<br>
相比过程式语言当中的函数(或者叫方法, procedure), Haskell 当中有很多不同:</p>

<ul>
<li>Haskell 当中能定义, 但不能赋值, 不能修改已经定义好的数据</li>
<li>纯函数传入参数相同, 返回值就一定相同, 不会有例外</li>
<li>读写文件这类 IO 操作, 也是有返回值的, 比如 <code>IO String</code>, <code>IO ()</code>
</li>
<li>Haskell 当中没有语句用于实现过程, 而是用函数模拟出来过程</li>
</ul>
<p>最后一点跟流行编程语言区别尤其大, 即便跟 Lisp 的设计也差别很大<br>
Lisp 虽然号称"一切皆表达式", 但在函数体, 在 <code>begin</code> 当中语句照样用:</p>

<pre><code>racket</code><code>(define (print-back)
  (define x (read))
  (print x))
</code></pre>

<p>比如这样的一段 Racket, 转化成 Haskell 看起来像是这样:</p>

<pre><code>haskell</code><code>printBack :: IO ()
printBack = do
  x &lt;- getLine
  print x
</code></pre>

<p>然而 <code>do</code> 表达式并不是 Haskell 真实的代码, 这是一套语法糖<br>
执行过程会被转化为 <code>&gt;&gt;=</code> 或者 <code>&gt;&gt;</code> 函数, 就像是下面这样:</p>

<pre><code>haskell</code><code>printBack = getLine &gt;&gt;= (\x -&gt; print x)
</code></pre>

<p>或者把函数放到前面来, 这样看得就更明确了:</p>

<pre><code>haskell</code><code>printBack = (&gt;&gt;=) getLine (\x -&gt; print x)
</code></pre>

<p>就是说 <code>getLine</code> 的执行结果, 还有后面的函数, 都是 <code>&gt;&gt;=</code> 这个函数的参数<br>
后边的 <code>(\x -&gt; print x)</code> 几乎就是个回调函数, 对, 类似 Callback Hell<br>
所以 <code>do</code> 表达式完全就是个障眼法, Haskell 里大量使用回调的写法<br>
同时因为回调, 所以 Haskell 不会暗地里并行执行参数里的操作, 而是有明确的先后顺序<br>
只不过 Haskell 语法灵活, 大量嵌套函数, 看起来还能跟没事一样, 看文档:<br><a rel="nofollow" href="http://en.wikibooks.org/wiki/Haskell/do_notation">http://en.wikibooks.org/wiki/Haskell/do_notation</a></p>

<p>总结一下就是纯函数编程, 过程式语言常用的招数都被废掉了<br>
整个 Haskell 的函数都往数学函数逼近, 比如 <code>f(x) = x^2 + 2*x + 1</code><br>
另外, 加上了一套代数化的类型系统, 能够容纳编程需要的各种类型</p>

<h3>IO 的特殊性</h3>

<p>IO 要特别梳理一下, 因为相较于过程式语言, 这里的 IO 处理很奇怪<br><a rel="nofollow" href="https://wiki.haskell.org/IO_inside">https://wiki.haskell.org/IO_inside</a><br>
通常编程语言的做法, 比如说常用的读取文件吧, 调用, 返回字符串, 很好理解:</p>

<pre><code>js</code><code>content = fs.readFileSync('filename', 'utf8') // Node.js
</code></pre>

<pre><code>julia</code><code>content = readall("filename") # Julia
</code></pre>

<pre><code>racket</code><code>(define content (file-&gt;string "filename")) ; Racket
</code></pre>

<p>但在纯函数语言当中有个大问题, 不是说好了参数一样, 返回值一样吗?<br>
所以在 Haskell 当中 <code>readFile</code> 返回值并不是 <code>String</code>, 而是加上了 <code>IO</code>:</p>

<pre><code>haskell</code><code>readFile :: IO String
</code></pre>

<p>结果就是处理文件内容时, 必需引入 Monad 的写法才行:</p>

<pre><code>haskell</code><code>main = do
  content &lt;- readFile "filename"
  putStr content
</code></pre>

<p>这个地方的 <code>IO String</code> 对 <code>String</code> 做了一层封装, 后面会遇到更多封装</p>

<h3>代数类型系统</h3>

<p>关于这一点, 我理解不准确, 但是举一些例子大概可以明白一些,<br>
比如这是类似加法的方式定义新的类型:</p>

<pre><code>haskell</code><code>data MySumType = Foo Bool | Bar Char
</code></pre>

<p>这是类似乘法的方式定义新的类型:</p>

<pre><code>haskell</code><code>data MyProductType = Baz (Bool, Char)
</code></pre>

<p>这是以递归的方式定义新的类型:</p>

<pre><code>haskell</code><code>data List a = Nil | Cons a (List a)
</code></pre>

<p>相比 C 或者 Go 通过 <code>struct</code> 定义新的类型, Haskell 显得很数学化<br>
因为, 如果用在 Go 里定义类型是 <code>A</code> 或者 <code>B</code>, 怎么定义? 还有递归?</p>

<p>Haskell 当中关于类型的概念, 整理在一起就是一些关键字:</p>

<ul>
<li>
<code>data</code>, <code>type</code>, <code>newtype</code> 用来定义类型或者类型的别名</li>
<li>
<code>instance</code>, <code>class</code> 用来实现类型之间的关联, 或者说定义实现类型类</li>
</ul>
<p>具体看这篇文章概括的, Haskell 当中类型, 类型类的一些操作<br><a rel="nofollow" href="http://joelburget.com/data-newtype-instance-class/">http://joelburget.com/data-newtype-instance-class/</a></p>

<p>这里的概念跟面向对象方面的, "类", "接口", "继承"有很多相似之处<br>
但是看下例子, 这在 Haskell 当中是怎样使用的,<br>
比如有一个叫做 <code>Functor</code> 的 Typeclass, 很多的 Type 都属于这个 Typeclass:</p>

<pre><code>haskell</code><code>class Functor f where  
    fmap :: (a -&gt; b) -&gt; f a -&gt; f b  
</code></pre>

<p>比如 <code>Maybe</code> Type 就是基于 <code>Functor</code> 实现, 首先用 <code>data</code> 定义 <code>Maybe</code> Type:</p>

<pre><code>haskell</code><code>data Maybe a = Just a | Nothing
    deriving (Eq, Ord)
</code></pre>

<p>然后通过 <code>instance</code> 在 <code>Maybe</code> 上实现 <code>Functor</code> 约定的函数 <code>fmap</code>:</p>

<pre><code>haskell</code><code>instance Functor Maybe where
    fmap f (Just x) = Just (f x)
    fmap f Nothing = Nothing
</code></pre>

<p>再比如 <code>[]</code> 也是, 那么首先 <code>[]</code> 大致可以这样定义<br>
然后会有 <code>[]</code> 上实现的 <code>Functor</code> 约定的 <code>fmap</code> 方法:</p>

<pre><code>haskell</code><code>data [a] = [] | a : [a] -- 演示代码, 可能有遗漏

instance Functor [] where
    fmap = map
</code></pre>

<p>还有一个例子比如说 <code>Tree</code> Type, 也可以同样实现 <code>fmap</code> 函数:</p>

<pre><code>haskell</code><code>data Tree a = Node a [Tree a]

instance Functor Tree where
    fmap f (Leaf x) = Leaf (f x)
    fmap f (Branch left right) = Branch (fmap f left) (fmap f right)
</code></pre>

<p>就是说, Haskell 当中的类型, 是通过这样一套写法定义出来的<br>
同样, <code>Monad</code> 也是个 Typeclass, 也就可以按上边这样理解<br>
单看写法, Go 的 <code>interface</code> 定义看起来相似, 至少语法上可以理解</p>

<h3>Functor, Applicative, Monad</h3>

<p>Haskell 首先是我们熟悉的 Value 还有 Function 的世界<br>
而 <code>Functor</code>, <code>Applicative</code>, <code>Monad</code> 在大谈封装的问题,<br>
就是值会被装进一个盒子当中, 然后从盒子外边用这三种手法去操作,<br><a rel="nofollow" href="http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html">http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_...</a></p>

<p>首先难以理解的是, 这层封装是什么? 为什么硬生生造出一个其他语言没有的概念?<br>
考虑到 Haskell 当中大量的 Category Theory(范畴论)的术语, 好像高等代数学到过..<br>
范畴论群论依然是我无法理解的数学语言, 所以这我依然不能解释, 究竟为什么有一层封装?<br>
没有办法, 只能先看一下这一层封装在 Haskell 当中派上了什么用场?</p>

<ul>
<li><code>Maybe</code></li>
</ul>
<p>首先 <code>Maybe</code> Type 实现了 <code>Monad</code>, 那么看下 <code>Maybe</code> 典型的场景<br>
注意下 Haskell 里 <code>1 / 0</code> 结果是 <code>Infinity</code>,, 这个大概也不是我们想要的<br>
下面是封装过的除法, <code>0</code> 不能作为被除数, 所以有了个 <code>Nothing</code>:</p>

<pre><code>haskell</code><code>divide :: (Fractional a) =&gt; a -&gt; a -&gt; Maybe a
divide a 0 = Nothing
divide a b = Just $ a / b
</code></pre>

<p>考虑一下这样一个四则运算, 上面提示了, 一个情况 <code>b</code> 可能是 <code>0</code>, 除法有问题<br>
但是作为例子, 很多 <code>x / 0</code> 在实际的编程当中我们会当成报错来处理,<br>
好, 先认为报错, 那么整个程序就退出了</p>

<pre><code>haskell</code><code>((a / b) * c) + d
</code></pre>

<p>不过, 引入 <code>Maybe</code> Type 给出了一套不同的方案, 对应有报错和没有报错的情况:</p>

<pre><code>haskell</code><code>(Just 0.5 * Just 3) + Just 4
Just 1.5 + Just 4
Just 4.5
</code></pre>

<pre><code>haskell</code><code>((Just 1 / Just 0) * Just 3) + Just 4
(Nothing * Just 3) + Just 4
Nothing + Just 4
Nothing
</code></pre>

<p>没有报错, 一切正常. 如果有报错后边的结果都是 Nothing<br>
这个就像 Railway Oriented Programming 给的那样, 增加了一套可能的流程:<br><a rel="nofollow" href="http://fsharpforfunandprofit.com/posts/recipe-part2/">http://fsharpforfunandprofit.com/posts/recipe-part2/</a><br><img src="http://fsharpforfunandprofit.com/assets/img/Recipe_Function_ErrorTrack.png" alt=""></p>

<ul>
<li><code>List</code></li>
</ul>
<p>然后, List 也实现了 <code>Monad</code>, 就来看下例子, 下面一段代码打印了什么结果</p>

<pre><code>haskell</code><code>example :: [(Int, Int, Int)]
example = do
  a &lt;- [1,2]
  b &lt;- [10,20]
  c &lt;- [100,200]
  return (a,b,c)
-- [(1,10,100),(1,10,200),(1,20,100),(1,20,200),(2,10,100),(2,10,200),(2,20,100),(2,20,200)]
</code></pre>

<p>其实是列表解析, 如果按花哨的写法写, 应该是这样:</p>

<pre><code>haskell</code><code>[(a, b, c) | a &lt;- [1,2], b &lt;- [10,20], c &lt;- [100,200]]
</code></pre>

<ul>
<li><code>(-&gt;) r</code></li>
</ul>
<p>后面的两个例子难以理解, 但是大概看一看, <code>(-&gt;) r</code> 也实现了 <code>Functor</code> Typeclass<br><code>(-&gt;) r</code> 是什么? 是函数, 一个参数的函数. 注意 Haskell 里的函数参数都是一个...</p>

<pre><code>haskell</code><code>instance Functor ((-&gt;) r) where
    fmap = (.)
</code></pre>

<p>函数作为 <code>fmap</code> 第二个参数, 最后效果居然是实现了函数复合! <code>f . g</code></p>

<pre><code>haskell</code><code>ghci&gt; :t fmap (*3) (+100)
fmap (*3) (+100) :: (Num a) =&gt; a -&gt; a
ghci&gt; fmap (*3) (+100) 1
303
</code></pre>

<ul>
<li><code>sequenceA</code></li>
</ul>
<p>更复杂的是实现了 <code>Applicative</code> Typeclass 的 <code>sequenceA</code> 函数</p>

<pre><code>haskell</code><code>sequenceA :: (Applicative f) =&gt; [f a] -&gt; f [a]  
sequenceA = foldr (liftA2 (:)) (pure [])  
</code></pre>

<p>这个函数能把别的函数组合在一起用, 还能把 IO 操作组合在一起用,<br>
而且这么密集的抽象... 3 个 IO 操作被排在一起了...</p>

<pre><code>haskell</code><code>ghci&gt; sequenceA [(&gt;4),(&lt;10),odd] 7  
[True,True,True]  
ghci&gt; and $ sequenceA [(&gt;4),(&lt;10),odd] 7  
True  

ghci&gt; sequenceA [getLine, getLine, getLine]  
heyh  
ho  
woo  
["heyh","ho","woo"]  
</code></pre>

<p>好, 回到上面的问题, <code>Functor</code>, <code>Applicative</code>, <code>Monad</code> 为什么有?<br>
之前说函数是语言一切都是函数, 一些过程式的写法写不了了,<br>
现在借助几个抽象, 好像又回来了, 而且花样还很多.. 连复合函数都构造了一遍<br>
在这样的认识之下, 再看下 <code>IO Monad</code> 做了什么, 加上 <code>do</code> 表达式:</p>

<pre><code>haskell</code><code>main :: IO ()
main = do putStrLn "What is your name: "
          name &lt;- getLine
          putStrLn name
</code></pre>

<p>完全就是在模仿面向过程的编程, 或者说把面向过程里的一些东西重新造了一遍<br>
当然我个人学到这里依然没明白设计思路, 但我知道是为什么要设计了<br>
按照教程上的说法, 我可以整理一下几个函数之间的关联的递进:</p>

<p>首先, Haskell 通常的代码可以看作是对基础类型进行操作<br>
比如我们有个函数 <code>f</code>, 有个数据 <code>x</code>, 通过 <code>call</code> 来调用:</p>

<pre><code>haskell</code><code>Prelude&gt; let call f x = f x
Prelude&gt; :t call
call :: (a -&gt; b) -&gt; a -&gt; b
</code></pre>

<p>那么 <code>call</code> 的类型声明就是 <code>(a -&gt; b) -&gt; a -&gt; b</code></p>

<ul>
<li><code>Functor</code></li>
</ul>
<pre><code>haskell</code><code>class Functor f where  
    fmap :: (a -&gt; b) -&gt; f a -&gt; f b  
</code></pre>

<p>接着是 <code>Functor</code>, 注意类型声明变成的改变, 多了一层封装:</p>

<pre><code>haskell</code><code>(a -&gt; b) -&gt; a -&gt; b -- call
(a -&gt; b) -&gt; f a -&gt; f b -- fmap
</code></pre>

<ul>
<li><code>Applicative</code></li>
</ul>
<pre><code>haskell</code><code>class (Functor f) =&gt; Applicative f where  
    pure :: a -&gt; f a  
    (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b  
</code></pre>

<p>到了 <code>Applicative</code> 呢, 又在前面加上了一层封装:</p>

<pre><code>haskell</code><code>(a -&gt; b) -&gt; a -&gt; b -- call
(a -&gt; b) -&gt; f a -&gt; f b -- fmap
f (a -&gt; b) -&gt; f a -&gt; f b  -- &lt;*&gt;
</code></pre>

<ul>
<li><code>Monad</code></li>
</ul>
<pre><code>haskell</code><code>class Monad m where  
    return :: a -&gt; m a  

    (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b  

    (&gt;&gt;) :: m a -&gt; m b -&gt; m b  
    x &gt;&gt; y = x &gt;&gt;= \_ -&gt; y  

    fail :: String -&gt; m a  
    fail msg = error msg  
</code></pre>

<p>到了 <code>Monad</code>, 参数顺序跟具体的封装又做了改进(<code>m</code> 写成 <code>f</code> 方便对比):</p>

<pre><code>haskell</code><code>(a -&gt; b) -&gt; a -&gt; b -- call
(a -&gt; b) -&gt; f a -&gt; f b -- fmap
f (a -&gt; b) -&gt; f a -&gt; f b  -- (&lt;*&gt;)
f a -&gt; (a -&gt; f b) -&gt; f b  -- (&gt;&gt;=)
</code></pre>

<p>大致上有个规律, 就是调用函数封装 <code>f</code>, 手段都是为了函数能超越封装使用<br>
而且 <code>f</code> 会是什么? 有 <code>Maybe [] ((-&gt;) r) IO</code>, 还有其他很多<br>
带来效果是什么? 有处理报错, 列表解析, 符合函数, 批量的 IO, 以及其他<br>
Haskell 用纯函数补上了操作控制流和 IO 的功能, Monad 是其中一个手段</p>

<h3>Monad 的写法</h3>

<p>然后看下 Monad 去掉 <code>do</code> 表达式语法糖的时候怎么写, 原始的代码:<br><a rel="nofollow" href="http://stackoverflow.com/q/16964732/883571">http://stackoverflow.com/q/16964732/883571</a></p>

<pre><code>haskell</code><code>do num &lt;- numberNode x
   nt1 &lt;- numberTree t1
   nt2 &lt;- numberTree t2
   return (Node num nt1 nt2)
</code></pre>

<p>去掉了语法糖, 是一串 <code>&gt;&gt;=</code> 函数连接在一起, 一层层的缩进:</p>

<pre><code>haskell</code><code>numberNode x &gt;&gt;= \num -&gt;
  numberTree t1 &gt;&gt;= \nt1 -&gt;
    numberTree t2 &gt;&gt;= \nt2 -&gt;
      return (Node num nt1 nt2)
</code></pre>

<p>还有一个 <code>Applicative</code> 的写法</p>

<pre><code>haskell</code><code>Node &lt;$&gt; numberNode x &lt;*&gt; numberTree t1 &lt;*&gt; numberTree t2
</code></pre>

<p>最后一个我得看老半天... 好吧, 总之, Haskell 就是提供了如此复杂的抽象<br><code>print("x")</code> 在过程式语言中仅仅是指令, 在 Haskell 中却被处理为纯函数的调用<br>
Haskell 将纯函数用于高阶的函数的转化以及操作, 变成很强大的控制流<br>
前面说了, 实际上只是作为参数, 跟 Node.js 使用深度的回调很相似</p>

<p>不过还记得 Railway Oriented 那张图吗, 跟 Node.js 对比一下:</p>

<pre><code>js</code><code>fs.readFile("filename", "utf8", function(err, content) {
  if (err) { throw err }
  console.log(content)
})
</code></pre>

<p>注意 <code>err</code> 的处理, Haskell 当中可没有写 <code>err</code> 而是在 <code>&gt;&gt;=</code> 内部处理掉了<br>
而且 Haskell 也不会执行到这里就吐出返回值, 而是等全部执行完再返回<br>
上边我用过 Callback Hell 打比方, 不过除了写法相似, 其他方面差别不小</p>

<h3>总结</h3>

<p>好了我不是在写 <code>Monad</code> 教程, 我也没全弄明白, 但是上边记录了我理解的思路:</p>

<ul>
<li>可变数据, 副作用, 种种不确定性是编程当中混乱的来源</li>
<li>纯函数相对于过程式代码的特殊性, 决定了它不能简单使用语句或者指令直接写程序</li>
<li>Haskell 当中的 IO 做了封装, 使之融合到纯函数当中来</li>
<li>
<code>Monad</code> 是 Haskell 当中的 Typeclass, 所以我先不去管数学中的定义</li>
<li>什么是封装, 为什么 Haskell 中函数和数据会被封装</li>
<li>
<code>Monad</code> 起到了怎样的作用, 怎样理解它的作用</li>
</ul>
<p>我之前一直在想 Monad 会是数学结构当中某种强大的概念, 群论如何如何<br>
但是回头看, 这更像是人为定义出来的方便编程语言使用的几个 Typeclass 而已<br>
当新的数据类型被需要, 还可以自己定义, 用高阶函数玩转...<br>
总之我不必为了弄懂 Monad 是什么回去把高等代数啃一遍...</p>

<p>不过呢, 过了这一关我还是不会写稍微复杂点的程序, 类型系统难点真挺多的</p>

2015年五月3日下午 2:20:47
Lumen 初体验
<h2>介绍</h2>

<p>Lumen：“为速度而生的 Laravel 框架”。</p>

<p>Lumen 是 Laravel 的作者（Taylor Otwell）的又一力作。简单、快速、优雅的它的特点，适合用于构建微服务架构和 API 应用。<br>
官网：<a rel="nofollow" href="http://lumen.laravel.com"></a><a rel="nofollow" href="http://lumen.laravel.com">http://lumen.laravel.com</a><br>
介绍：<a rel="nofollow" href="https://phphub.org/topics/701"></a><a rel="nofollow" href="https://phphub.org/topics/701">https://phphub.org/topics/701</a><br>
中文文档：<a rel="nofollow" href="http://lumen.laravel-china.org/docs"></a><a rel="nofollow" href="http://lumen.laravel-china.org/docs">http://lumen.laravel-china.org/docs</a></p>

<h2>安装</h2>

<p>使用 composer 安装：</p>

<pre><code>bash</code><code>composer create-project laravel/lumen --prefer-dist
</code></pre>

<h2>配置</h2>

<p>Lumen 默认使用 <code>.env</code> 作为配置文件。<code>.env.example</code> 是官方给出的例子，直接拷贝命名为 <code>.env</code>。</p>

<pre><code>bash</code><code>cd lumen
cp .env.example .env
</code></pre>

<h2>调试模式</h2>

<p>修改 <code>.env</code> 文件：</p>

<pre><code>bash</code><code>APP_DEBUG=true
</code></pre>

<p>如果发现还是没有效果，再修改 <code>lumen/bootstrap/app.php</code> 文件，将 <code>Dotenv::load</code> 的注释移除掉。</p>

<h2>疑问</h2>

<h3>1.为什么提示：not be found</h3>

<p>访问：<a rel="nofollow" href="http://127.0.0.1/lumen/public/">http://127.0.0.1/lumen/public/</a></p>

<p>显示：</p>

<pre><code>bash</code><code>Sorry, the page you are looking for could not be found.

NotFoundHttpException in Application.php line 1121:

in Application.php line 1121
at Application-&gt;handleDispatcherResponse(array('0')) in Application.php line 1091
at Application-&gt;dispatch(null) in Application.php line 1026
at Application-&gt;run() in index.php line 28
</code></pre>

<p>查看路由文件 <code>lumen/app/Http/routes.php</code>：</p>

<pre><code>php</code><code>$app-&gt;get('/', function() use ($app) {
    return $app-&gt;welcome();
});
</code></pre>

<p>感觉没有问题啊，和在 Laravel 中差不多的方式，那是哪里出了问题了？好的，先不管，尝试自己新定义一条路由规则试试看：</p>

<pre><code>php</code><code>$app-&gt;get('/test', function() use ($app) {
    return $app-&gt;welcome();
});
</code></pre>

<p>再访问：<a rel="nofollow" href="http://127.0.0.1/lumen/public/test">http://127.0.0.1/lumen/public/test</a></p>

<p>结果和刚才一样。</p>

<h3>2.为什么会跳转</h3>

<p>再尝试访问一下：<a rel="nofollow" href="http://127.0.0.1/lumen/public/test/">http://127.0.0.1/lumen/public/test/</a><br>
结果跳转到：<a rel="nofollow" href="http://127.0.0.1/test">http://127.0.0.1/test</a></p>

<h2>解惑</h2>

<p>我先来解释一下第 2 个问题，因为这是一个很多 Laravel 新手也经常问的问题。</p>

<p>原因何在？请看 <code>lumen/public/.htaccess</code> 文件：</p>

<pre><code>bash</code><code>RewriteRule ^(.*)/$ /$1 [L,R=301]
</code></pre>

<p>这是一条 Apache 路由重写规则（mod_rewrite 开启的情况下才有效），当请求的 URI 带有 <code>/</code>，就会匹配出 <code>$1</code>， 永久重定向（HTTP 状态码是 301）到根目录下的 <code>$1</code>。上面的例子中，匹配到 test（就是$1），就跳转至 /test 了。</p>

<p>如何来规避上面这个问题？注释这条 RewriteRule 吗？不是的。一般来说，我们应该避免使用末尾带斜杠的 URI。为什么 URI 末尾不应该带有斜杠呢？从语义是来说， <code>test/</code> 表示目录，<code>test</code> 表示资源。还有，如果在 lumen/public 目录下真的有一个 test 目录，那么访问 <a rel="nofollow" href="http://127.0.0.1/lumen/public/test/">http://127.0.0.1/lumen/public/test/</a>，就会进入到 test 目录下面来，这不是我们想要的结果。（其实如果真的存在 test 目录并且不存在文件 test，那么，URI 末尾有没有斜杠都会进入到 test 目录中来，这是 Apache 决定的。因为它如果找不到文件，就会自动在末尾加个斜杠，尝试寻找目录下的 index.html 文件等等，具体是在 httpd.conf 中配置 DirectoryIndex。好吧，扯得太远了，拽回来）<br>
总之，我还是建议 URI 末尾不要带 <code>/</code>，如果你非不听，那就注释上面那句 RewriteRule 吧，这样就不会重定向了。</p>

<p>关于第 1 个问题，我们也来分析一下发生的原因，这样才能对症下药。<br>
根据错误提示，定位到文件 <code>lumen/vendor/laravel/lumen-framework/src/Application.php</code> 中：</p>

<pre><code>php</code><code>    /**
     * Dispatch the incoming request.
     *
     * @param  SymfonyRequest|null  $request
     * @return Response
     */
    public function dispatch($request = null)
    {
        if ($request) {
            $this-&gt;instance('Illuminate\Http\Request', $request);
            $this-&gt;ranServiceBinders['registerRequestBindings'] = true;

            $method = $request-&gt;getMethod();
            $pathInfo = $request-&gt;getPathInfo();
        } else {
            $method = $this-&gt;getMethod();
            $pathInfo = $this-&gt;getPathInfo();
        }        

        try {
            if (isset($this-&gt;routes[$method.$pathInfo])) {
                return $this-&gt;handleFoundRoute([true, $this-&gt;routes[$method.$pathInfo]['action'], []]);
            }

            return $this-&gt;handleDispatcherResponse(
                $this-&gt;createDispatcher()-&gt;dispatch($method, $pathInfo)
            );
        } catch (Exception $e) {
            return $this-&gt;sendExceptionToHandler($e);
        }
    }

</code></pre>

<p>匹配不到 route 的原因就在以上代码中。假设访问：<a rel="nofollow" href="http://127.0.0.1/lumen/public">http://127.0.0.1/lumen/public</a>，那么 :</p>

<pre><code>php</code><code>var_dump($method);  // string(3) "GET"
var_dump($pathInfo);  // string(14) "/lumen/public/"
</code></pre>

<p>根据 lumen/app/Http/routes.php 中的定义，生成 <code>$this-&gt;routes</code>：</p>

<pre><code>php</code><code>var_dump(array_keys($this-&gt;routes));  // array(2) { [0]=&gt; string(4) "GET/" [1]=&gt; string(8) "GET/test" }
</code></pre>

<p>由上可知， <code>isset($this-&gt;routes[$method.$pathInfo])</code> 的结果就是 <code>false</code>，所以提示 <code>not be found</code> 了。<br>
既然已经知道了原因，那问题就好解决了。解决的前提是<strong>不要改动框架的源代码</strong>，不然日后升级框架会多么蛋疼，你都把框架代码都修改，万一出了问题你咋办？你自己拆手机，官方是不保修的哦！当然，如果你是框架开发组的，你提交代码能被大家接受并被官方合并到主干代码中了，那你就改吧。</p>

<h3>方案1：修改 DocumentRoot</h3>

<p>修改 Apache 的配置文件 <code>httpd.conf</code>，将 <code>DocumentRoot</code> 指向 <code>lumen/public</code>：</p>

<pre><code>bash</code><code>DocumentRoot "/sites/lumen/public"
</code></pre>

<p>重启 Apache。</p>

<p>但是，如果我还有其他站点也在这个 Apache 下面，改 DocumentRoot 就会导致其他的站点不能访问了。怎么办？请看<strong>方案 2</strong>。</p>

<h3>方案2：配置 Apache 虚拟主机</h3>

<p>修改 <code>httpd.conf</code>，将下面这行的注释移除：</p>

<pre><code>bash</code><code>Include etc/extra/httpd-vhosts.conf
</code></pre>

<p>修改 <code>httpd-vhosts.conf</code>：</p>

<pre><code>bash</code><code>&lt;VirtualHost *:80&gt;
    DocumentRoot "/sites"
    ServerName 127.0.0.1
&lt;/VirtualHost&gt;
&lt;VirtualHost *:80&gt;
    DocumentRoot "/sites/lumen/public"
    ServerName lumen.app
&lt;/VirtualHost&gt;
</code></pre>

<p>重启 Apache。</p>

<p>修改主机的 <code>etc/hosts</code>，添加一行：</p>

<pre><code>bash</code><code>127.0.0.1 lumen.app
</code></pre>

<p>其中 127.0.0.1 应该换成你 lumen 应用存放的机器的 ip。</p>

<p>OK，这样就可以通过访问 <a rel="nofollow" href="http://lumen.app">http://lumen.app</a> 来访问该 lumen 站点，通过 <a rel="nofollow" href="http://127.0.0.1">http://127.0.0.1</a> 来访问其他站点。</p>

<p>但是，你压根不能修改 Apache 的配置，怎么办？请看<strong>方案 3</strong>。</p>

<h3>方案3.修改路由规则中的路径</h3>

<p>改不了配置，就改代码喽（再强调一下，不是修改框架的源代码）。</p>

<p>修改路由文件 <code>lumen/app/Http/routes.php</code>：</p>

<pre><code>php</code><code>define('ROUTE_BASE', 'lumen/public/')；

$app-&gt;get(ROUTE_BASE . '/index', function() use ($app) {
    return $app-&gt;welcome();
});
$app-&gt;get(ROUTE_BASE . '/test', function() use ($app) {
    return $app-&gt;welcome();
});
</code></pre>

<p>这样，如果以后有变化的话，你只需要修改 <code>define('ROUTE_BASE', 'lumen/public/')；</code>就可以了（当然，把这个写到应用配置项中是最合适的，部署时修改配置就可以了）。</p>

<p>至于想以 <code>'lumen/public/'</code> 作为首页 URI 显然是不可以的，建议使用 <code>'lumen/pulbic/index'</code> 作为首页。如同上面代码定义的路由规则那样。</p>

<p>因为，无论你在路由规则的字符串末尾加了多少个斜杠， <code>$this-&gt;routes</code> 的键是不会带有斜杠的，最终还是不能匹配的。原因在框架源代码中 <code>lumen/vendor/laravel/lumen-framework/src/Application.php</code>：</p>

<pre><code>php</code><code>    /**
     * Add a route to the collection.
     *
     * @param  string  $method
     * @param  string  $uri
     * @param  mixed  $action
     */
    protected function addRoute($method, $uri, $action)
    {
        $action = $this-&gt;parseAction($action);

        $uri = $uri === '/' ? $uri : '/'.trim($uri, '/');

        if (isset($action['as'])) {
            $this-&gt;namedRoutes[$action['as']] = $uri;
        }

        if (isset($this-&gt;groupAttributes)) {
            if (isset($this-&gt;groupAttributes['prefix'])) {
                $uri = rtrim('/'.trim($this-&gt;groupAttributes['prefix'], '/').$uri, '/');
            }

            $action = $this-&gt;mergeGroupAttributes($action);
        }

        $this-&gt;routes[$method.$uri] = ['method' =&gt; $method, 'uri' =&gt; $uri, 'action' =&gt; $action];
    }
</code></pre>

<p>对，就是它：<code>$uri = $uri === '/' ? $uri : '/'.trim($uri, '/');</code>。<br>
所有，URI 末尾还是不带斜杠的好。</p>

2015年五月3日下午 1:07:20
求大神帮助！！！
<div class="markdown-text"><p><img src="//dn-cnode.qbox.me/FhGHAl_QvtvT4bEN1X7AXAZj9SxE" alt="Screen Shot 2015-05-03 at 1.00.20 PM.png"></p>
<p>代码：
<img src="//dn-cnode.qbox.me/FkwfMd12ADPzqCJKH9waykSCKy1G" alt="Screen Shot 2015-05-03 at 1.00.41 PM.png"></p>
<p>非常感谢</p>
</div>

2015年五月3日中午 12:25:25
node express4.0 遇到一个偶发的问题，post有时会得到404 not found报错
<div class="markdown-text"><p>在我编程OA系统中出现了一个偶发的问题，让我头痛。一个简单的数据update功能，在大多数情况下工作正常，偶尔会发生提交post数据不成功，浏览器报404 Not Found, 但nodejs没有报错，log里也没有记录。为此，我升级了mongodb到3.0， 也升级express到4.12.3，但这个问题还是存在。请各位高手帮忙诊断一下：</p>
<p>以下是Chrome控制台的记录404 Not Found信息：</p>
<pre class="prettyprint"><code>Headers
General
Remote Address:123.56.132.188:2000
Request URL:http://ff.yinova.cn:2000/kafapiaoDetail
Request Method:POST
Status Code:404 Not Found

Response Headers
Connection:keep-alive
Content-Length:28
Content-Type:text/html; charset=utf-8
Date:Sun, 03 May 2015 03:07:38 GMT
ETag:W/&quot;vXOLRVt8K03ixCcpAP5ICQ==&quot;
X-Content-Type-Options:nosniff
X-Powered-By:Express

Request Headers
POST /kafapiaoDetail HTTP/1.1
Host: ff.yinova.cn:2000
Connection: keep-alive
Content-Length: 588
Cache-Control: max-age=0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
Origin: http://ff.yinova.cn:2000
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2272.101 Safari/537.36
Content-Type: application/x-www-form-urlencoded
Referer: http://ff.yinova.cn:2000/k/554203dba9e620351d690c70
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.6
Cookie: connect.sid=s%3AJqC8e7eTZtAFxqRmX5juQ5t0.KkHhy5TSbYJF1stJm8zZGpP6sfyP2J92t2MN7a7u2tY

Form Data
item:XXXX投资有限公司
unit:会议费
price:343177
client:XX
address:北京市朝阳区XXXXXXXXXXXXXXX层
remark:发票备注
company:1
status:5
bank:1
</code></pre><hr>
<p>过了一分钟，我再次提交这个数据，就成功了。 以下是Chrome控制台的记录信息：</p>
<pre class="prettyprint"><code>Headers

General
Remote Address:123.56.132.188:2000
Request URL:http://ff.yinova.cn:2000/kafapiaoDetail
Request Method:POST
Status Code:302 Moved Temporarily

Response Headers
Connection:keep-alive
Content-Length:68
Content-Type:text/html; charset=utf-8
Date:Sun, 03 May 2015 03:24:28 GMT
Location:/kList
Vary:Accept
X-Powered-By:Express

Request Headers
Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
Accept-Encoding:gzip, deflate
Accept-Language:zh-CN,zh;q=0.8,zh-TW;q=0.6
Cache-Control:max-age=0
Connection:keep-alive
Content-Length:588
Content-Type:application/x-www-form-urlencoded
Cookie:connect.sid=s%3AJqC8e7eTZtAFxqRmX5juQ5t0.KkHhy5TSbYJF1stJm8zZGpP6sfyP2J92t2MN7a7u2tY
Host:ff.yinova.cn:2000
Origin:http://ff.yinova.cn:2000
Referer:http://ff.yinova.cn:2000/k/554203dba9e620351d690c70
User-Agent:Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2272.101 Safari/537.36

Form Data
item:XXXX投资有限公司
unit:会议费
price:343177
client:XX
address:北京市朝阳区XXXXXXXXXXXXXXX层
remark:发票备注
company:1
status:5
bank:1
oid:554203dba9e620351d690c70
</code></pre><hr>
<p>router.js 的post代码：</p>
<pre class="prettyprint"><code>router.post(&quot;/kafapiaoDetail&quot;,function(req,res) {
  var currentUser = req.session.user;
  var t = new Date();
  var y = t.getFullYear();
  var m = t.getMonth()+1;
  var d = t.getDate();
  var h = t.getHours();
  if (h &lt; 10) {h = &#x27;0&#x27;+h;}
  var minute = t.getMinutes();
  if (minute&lt;10) { min = &#x27;0&#x27;+min;}
  var insert_time = y + &#x27;-&#x27; + m + &#x27;-&#x27; +d +&#x27; &#x27;+ h +&#x27;:&#x27;+minute;
  var status = req.body.status;
  var auditor = null;
  var auditor_time = null;
  var accountant = null;
  var accountant_time = null;
  if(currentUser.type === &#x27;3&#x27;) {
    auditor = currentUser.username;
    auditor_time = insert_time;
  }
  if(currentUser.type === &#x27;2&#x27;) {
    accountant = currentUser.username;
    accountant_time = insert_time;
  }
  var newAccount = {};
  newAccount.oid = req.body.oid;
  newAccount.item = req.body.item;
  newAccount.price = req.body.price;
  newAccount.unit = req.body.unit;
  newAccount.company = req.body.company;
  newAccount.status = status;
  newAccount.remark = req.body.remark;
  newAccount.address = req.body.address;
  newAccount.mobile = req.body.mobile;
  newAccount.client = req.body.client;
  newAccount.username = currentUser.username;
  newAccount.auditor = auditor;
  newAccount.auditor_time = auditor_time;
  newAccount.accountant = accountant;
  newAccount.accountant_time = accountant_time;
  newAccount.bank =req.body.bank;
  console.log(&#x27;kafapiaoDetail Update:&#x27;);  
  console.log(newAccount); 
  Accounting.update(newAccount.oid, newAccount, function(err, result) {
      console.log(&#x27;update result:&#x27;);
      if (err) {
        req.flash(&#x27;error&#x27;, err);
        return res.redirect(&#x27;/k/&#x27;+newAccount.oid); 
      }
      if (result) {
        req.flash(&#x27;success&#x27;,&#x27;数据已更新！&#x27;);
        return res.redirect(&#x27;/kList&#x27;);
      }
      req.flash(&#x27;error&#x27;, &#x27;数据更新失败，请稍后再试！&#x27;);
      res.redirect(&#x27;/k/&#x27;+newAccount.oid); 
  });   
});
</code></pre><hr>
<p>以下是jade页面代码：</p>
<pre class="prettyprint"><code>extends bloglayout
block bcontent
  include narbar.jade
  include alert.jade
  form(method=&#x27;post&#x27; role=&#x27;form&#x27; action=&#x27;/kafapiaoDetail&#x27;)
    h2.form-signin-heading 发票审批
    - if(account.length&gt;0||typeof(account) != &#x27;undefined&#x27;)
      - for(var i=0; i&lt;account.length; i++)
        div.input-group  
          span.input-group-addon 抬头
          input(id=&#x27;item&#x27; name=&#x27;item&#x27; type=&#x27;text&#x27; class=&#x27;form-control&#x27; value=account[i].item)
        div.input-group  
          span.input-group-addon 项目
          input(id=&#x27;unit&#x27; name=&#x27;unit&#x27; type=&#x27;text&#x27; class=&#x27;form-control&#x27; value=account[i].unit)
        div.input-group  
          span.input-group-addon 金额
          input(id=&#x27;price&#x27; name=&#x27;price&#x27; type=&#x27;text&#x27; class=&#x27;form-control&#x27; value=account[i].price)
        div.input-group  
          span.input-group-addon 收件人
          input(id=&#x27;client&#x27; name=&#x27;client&#x27; type=&#x27;text&#x27; class=&#x27;form-control&#x27; value=account[i].client)
        div.input-group  
          span.input-group-addon 手机
          input(id=&#x27;mobile&#x27; name=&#x27;mobile&#x27; type=&#x27;text&#x27; class=&#x27;form-control&#x27; value=account[i].mobile)
        div.input-group  
          span.input-group-addon 地址
          input(id=&#x27;address&#x27; name=&#x27;address&#x27; type=&#x27;text&#x27; class=&#x27;form-control&#x27; value=account[i].address)
        div.input-group  
          span.input-group-addon 备注
          input(id=&#x27;remark&#x27; name=&#x27;remark&#x27; type=&#x27;text&#x27; class=&#x27;form-control&#x27; value=account[i].remark)
        div.input-group  
          span.input-group-addon 公司
          select(id=&#x27;company&#x27; name=&#x27;company&#x27; class=&#x27;form-control&#x27;)
            - if(account[i].company === &#x27;1&#x27;)
              option(value=&#x27;0&#x27;) 请选择
              option(value=&#x27;1&#x27;  selected=&#x27;selected&#x27;) 云动
              option(value=&#x27;2&#x27;) 会贰
              option(value=&#x27;3&#x27;) 会小二
              option(value=&#x27;4&#x27;) 会万
            - else if(account[i].company === &#x27;2&#x27;)
              option(value=&#x27;0&#x27;) 请选择
              option(value=&#x27;1&#x27;) 云动
              option(value=&#x27;2&#x27;  selected=&#x27;selected&#x27;) 会贰
              option(value=&#x27;3&#x27;) 会小二
              option(value=&#x27;4&#x27;) 会万
            - else if(account[i].company === &#x27;3&#x27;)
              option(value=&#x27;0&#x27;) 请选择
              option(value=&#x27;1&#x27;) 云动
              option(value=&#x27;2&#x27;) 会贰
              option(value=&#x27;3&#x27; selected=&#x27;selected&#x27;) 会小二
              option(value=&#x27;4&#x27;) 会万
            - else if(account[i].company === &#x27;4&#x27;)
              option(value=&#x27;0&#x27;) 请选择
              option(value=&#x27;1&#x27;) 云动
              option(value=&#x27;2&#x27;) 会贰
              option(value=&#x27;3&#x27;) 会小二
              option(value=&#x27;4&#x27; selected=&#x27;selected&#x27;) 会万
            - else
              option(value=&#x27;0&#x27; selected=&#x27;selected&#x27;) 请选择
              option(value=&#x27;1&#x27;) 云动
              option(value=&#x27;2&#x27;) 会贰
              option(value=&#x27;3&#x27;) 会小二
              option(value=&#x27;4&#x27;) 会万
        div.input-group  
          span.input-group-addon 状态
          select(id=&#x27;status&#x27; name=&#x27;status&#x27; class=&#x27;form-control&#x27;)
            - if(account[i].status === &#x27;1&#x27;)
              option(value=&#x27;0&#x27;) 未开票取消
              option(value=&#x27;2&#x27;) 已开票
              option(value=&#x27;3&#x27;) 当月退票
              option(value=&#x27;4&#x27;) 跨月退票
              //- if(user.type === &#x27;3&#x27;)
              option(value=&#x27;1&#x27; selected=&#x27;selected&#x27;) 新建申请
              option(value=&#x27;5&#x27;) 已审批
            - if(account[i].status === &#x27;5&#x27;)
              option(value=&#x27;0&#x27;) 未开票取消
              option(value=&#x27;2&#x27;) 已开票
              option(value=&#x27;3&#x27;) 当月退票
              option(value=&#x27;4&#x27;) 跨月退票
              //- if(user.type === &#x27;3&#x27;)
              option(value=&#x27;1&#x27;) 新建申请
              option(value=&#x27;5&#x27; selected=&#x27;selected&#x27;) 已审批
            - if(account[i].status === &#x27;2&#x27;)
              option(value=&#x27;0&#x27;) 未开票取消
              option(value=&#x27;2&#x27; selected=&#x27;selected&#x27;) 已开票
              option(value=&#x27;3&#x27;) 当月退票
              option(value=&#x27;4&#x27;) 跨月退票
              //- if(user.type === &#x27;3&#x27;)
              option(value=&#x27;1&#x27;) 新建申请
              option(value=&#x27;5&#x27;) 已审批       
            - if(account[i].status === &#x27;3&#x27;)
              option(value=&#x27;0&#x27;) 未开票取消
              option(value=&#x27;2&#x27;) 已开票
              option(value=&#x27;3&#x27; selected=&#x27;selected&#x27;) 当月退票
              option(value=&#x27;4&#x27;) 跨月退票
              //- if(user.type === &#x27;3&#x27;)
              option(value=&#x27;1&#x27;) 新建申请
              option(value=&#x27;5&#x27;) 已审批
            - if(account[i].status === &#x27;4&#x27;)
              option(value=&#x27;0&#x27;) 未开票取消
              option(value=&#x27;2&#x27;) 已开票
              option(value=&#x27;3&#x27;) 当月退票
              option(value=&#x27;4&#x27; selected=&#x27;selected&#x27;) 跨月退票
              //- if(user.type === &#x27;3&#x27;)
              option(value=&#x27;1&#x27;) 新建申请
              option(value=&#x27;5&#x27;) 已审批            
            - if(account[i].status === &#x27;0&#x27;)
              option(value=&#x27;0&#x27; selected=&#x27;selected&#x27;) 未开票取消
              option(value=&#x27;2&#x27;) 已开票
              option(value=&#x27;3&#x27;) 当月退票
              option(value=&#x27;4&#x27;) 跨月退票
              //- if(user.type === &#x27;3&#x27;)
              option(value=&#x27;1&#x27;) 新建申请
              option(value=&#x27;5&#x27;) 已审批     
        div.input-group  
          span.input-group-addon 类型
          select(id=&#x27;bank&#x27; name=&#x27;bank&#x27; class=&#x27;form-control&#x27;)
            - if(account[i].bank === &#x27;2&#x27;)
              option(value=&#x27;1&#x27;) 增值税普票
              option(value=&#x27;2&#x27; selected=&#x27;selected&#x27;) 增值税专票
            - else
              option(value=&#x27;1&#x27; selected=&#x27;selected&#x27;) 增值税普票
              option(value=&#x27;2&#x27;) 增值税专票
        input(type=&#x27;text&#x27; class=&#x27;input_hide&#x27; id=&#x27;oid&#x27; name=&#x27;oid&#x27; value=account[i]._id readonly hidden)
        button(class=&#x27;btn btn-lg btn-primary&#x27; type=&#x27;submit&#x27;) 修改
        a(href=&#x27;/kList&#x27; class=&#x27;btn btn-default&#x27; type=&#x27;button&#x27;) 返回
</code></pre></div>

2015年五月3日中午 12:01:09
关于rsyslog和loganalyzer使用
<p>系统日志太多太分散的话就需要整合，并且分析，所以就有了这样一套东西，这样就大大的减轻了系统管理员的压力，不过现在这篇只是小试牛刀，很多应用功能还是没有用到，例如自定义日志收集过滤， 日志分析图表，等等，不过原理大致都基本如下，是可以举一反三的。</p>

<p>关于rsyslog和loganalyzer的配置简略架构流程图<br><img src="http://source1.godblessyuan.com/blog_rsyslog_loganalyzer_20150502.jpg" alt=""></p>

<h1>一、rsyslog</h1>

<h2>【客户端】rsyslog配置</h2>

<h3>1.安装rsyslog</h3>

<pre><code>yum -y install rsyslog
</code></pre>

<h3>2.配置rsyslog</h3>

<pre><code>/etc/rsyslog.conf
</code></pre>

<p>配置很多，但是只需要注意几个</p>

<pre><code># rsyslog v5 configuration file

# For more information see /usr/share/doc/rsyslog-*/rsyslog_conf.html
# If you experience problems, see http://www.rsyslog.com/doc/troubleshoot.html

#### MODULES ####

$ModLoad imuxsock # provides support for local system logging (e.g. via logger command)  
$ModLoad imklog   # provides kernel logging support (previously done by rklogd)  
#$ModLoad immark  # provides --MARK-- message capability

# Provides UDP syslog reception
$ModLoad imudp  --注意这个
$UDPServerRun 514   --注意这个

# Provides TCP syslog reception
#$ModLoad imtcp
#$InputTCPServerRun 514


#### GLOBAL DIRECTIVES ####

# Use default timestamp format
$ActionFileDefaultTemplate RSYSLOG_TraditionalFileFormat

# File syncing capability is disabled by default. This feature is usually not required,
# not useful and an extreme performance hit
#$ActionFileEnableSync on

# Include all config files in /etc/rsyslog.d/
$IncludeConfig /etc/rsyslog.d/*.conf


#### RULES ####

# Log all kernel messages to the console.
# Logging much else clutters up the screen.
#kern.*                                                 /dev/console

# Log anything (except mail) of level info or higher.
# Don't log private authentication messages!
#*.info;mail.none;authpriv.none;cron.none                /var/log/messages
*.*                                                      @主rsyslog服务器ip或者host   --注意这个

# The authpriv file has restricted access.
authpriv.*                                              /var/log/secure

# Log all the mail messages in one place.
mail.*                                                  -/var/log/maillog


# Log cron stuff
cron.*                                                  /var/log/cron

# Everybody gets emergency messages
*.emerg                                                 *

# Save news errors of level crit and higher in a special file.
uucp,news.crit                                          /var/log/spooler

# Save boot messages also to boot.log
local7.*                                                /var/log/boot.log


# ### begin forwarding rule ###
# The statement between the begin ... end define a SINGLE forwarding
# rule. They belong together, do NOT split them. If you create multiple
# forwarding rules, duplicate the whole block!
# Remote Logging (we use TCP for reliable delivery)
#
# An on-disk queue is created for this action. If the remote host is
# down, messages are spooled to disk and sent when it is up again.
#$WorkDirectory /var/lib/rsyslog # where to place spool files
#$ActionQueueFileName fwdRule1 # unique name prefix for spool files
#$ActionQueueMaxDiskSpace 1g   # 1gb space limit (use as much as possible)
#$ActionQueueSaveOnShutdown on # save messages to disk on shutdown
#$ActionQueueType LinkedList   # run asynchronously
#$ActionResumeRetryCount -1    # infinite retries if host is down
# remote host is: name/ip:port, e.g. 192.168.0.1:514, port optional
#*.* @@remote-host:514
# ### end of the forwarding rule ###
</code></pre>

<blockquote>
  <p>1.$ModLoad imudp和$UDPServerRun 514 开启rsyslog的日志远程传输，使用udp模式，当然也可以使用tcp模式，而且tcp也比udp更可靠，防止日志在传输过程丢失，只是需要建立稳定连接，消耗资源，各有所长，各有所需。</p>
  
  <p>2.#<em>.info;mail.none;authpriv.none;cron.none                /var/log/messages 注释掉这个语句，改为</em>.*                                                         @主rsyslog服务器ip或者host，这是为了配置rsyslog日志传输的目标，另外rsyslog的格式是分为2个方面的，一个是facitlity一个是priority，这个需要一点篇幅来说明，详细可以参阅科普时间或者官网，目前现在这个配置的意思是将所有级别的日志都传输到某个服务器。</p>
  
  <p>3.客户端的rsyslog只需要配置这样就足够了。需要注意的是，如果开启了防火墙的话，那么记得514端口是rsyslog的传输端口，也要放开访问。</p>
</blockquote>

<h3>3.重启rsyslog服务</h3>

<pre><code>service rsyslog restart
</code></pre>

<h2>【服务端】rsyslog配置</h2>

<h3>1.安装rsyslog</h3>

<pre><code>yum -y install rsyslog
</code></pre>

<h3>2.配置rsyslog存储数据库（数据库的安装在下面那里一起写了）</h3>

<pre><code>yum -y install rsyslog-mysql 
</code></pre>

<h2>导入创库sql</h2>

<pre><code>cd /usr/share/doc/rsyslog-mysql-5.8.10/
[root@localhost rsyslog-mysql-5.8.10]# ls
createDB.sql
[root@localhost rsyslog-mysql-5.8.10]# mysql -u root -p &lt; createDB.sql 
</code></pre>

<p>这个sql会自动帮你创建rsyslog存储在mysql中的数据的表，等下可以直接被loganalyzer读取数据，然后使用。</p>

<h2>连接数据库检查</h2>

<pre><code>mysql -u root -p
Enter password: 
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 7
Server version: 5.1.73 Source distribution

Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

mysql&gt; show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| Syslog             |
| mysql              |
| test               |
+--------------------+
4 rows in set (0.00 sec)


mysql&gt; use Syslog
Reading table information for completion of table and column names
You can turn off this feature to get a quicker startup with -A

Database changed
mysql&gt; show tables;
+------------------------+
| Tables_in_Syslog       |
+------------------------+
| SystemEvents           |
| SystemEventsProperties |
+------------------------+
2 rows in set (0.00 sec)
</code></pre>

<h2>配置rsyslog连接mysql账号和密码和授权</h2>

<pre><code>mysql&gt; grant all on Syslog.* to 'rsysloga'@'localhost' identified by 'rsyslogp';  #设置用户访问数据库服务器中Syslog数据库的用户名和密码，因为rsyslog服务端和mysql数据库是在同一台机器上，所以只允许本机访问就可以了
Query OK, 0 rows affected (0.00 sec)

flush privileges;  #刷新权限，及时生效
</code></pre>

<h3>3.配置服务端的rsyslog.conf（数据库的安装在下面那里一起写了）</h3>

<pre><code>cat /etc/rsyslog.conf 
# rsyslog v5 configuration file

# For more information see /usr/share/doc/rsyslog-*/rsyslog_conf.html
# If you experience problems, see http://www.rsyslog.com/doc/troubleshoot.html

#### MODULES ####

$ModLoad imuxsock # provides support for local system logging (e.g. via logger command)
$ModLoad imklog   # provides kernel logging support (previously done by rklogd)
#$ModLoad immark  # provides --MARK-- message capability
$ModLoad ommysql    --注意这个

# Provides UDP syslog reception
$ModLoad imudp      --注意这个
$UDPServerRun 514   --注意这个

# Provides TCP syslog reception
#$ModLoad imtcp
#$InputTCPServerRun 514


#### GLOBAL DIRECTIVES ####

# Use default timestamp format
$ActionFileDefaultTemplate RSYSLOG_TraditionalFileFormat

# File syncing capability is disabled by default. This feature is usually not required,
# not useful and an extreme performance hit
#$ActionFileEnableSync on

# Include all config files in /etc/rsyslog.d/
$IncludeConfig /etc/rsyslog.d/*.conf


#### RULES ####

# Log all kernel messages to the console.
# Logging much else clutters up the screen.
#kern.*                                                 /dev/console

# Log anything (except mail) of level info or higher.
# Don't log private authentication messages!
#*.info;mail.none;authpriv.none;cron.none                /var/log/messages      
*.*                                                     :ommysql:127.0.0.1,Syslog,rsysaloga,rsyslogp        --注意这个 

# The authpriv file has restricted access.
authpriv.*                                              /var/log/secure

# Log all the mail messages in one place.
mail.*                                                  -/var/log/maillog


# Log cron stuff
cron.*                                                  /var/log/cron

# Everybody gets emergency messages
*.emerg                                                 *

# Save news errors of level crit and higher in a special file.
uucp,news.crit                                          /var/log/spooler

# Save boot messages also to boot.log
local7.*                                                /var/log/boot.log


# ### begin forwarding rule ###
# The statement between the begin ... end define a SINGLE forwarding
# rule. They belong together, do NOT split them. If you create multiple
# forwarding rules, duplicate the whole block!
# Remote Logging (we use TCP for reliable delivery)
#
# An on-disk queue is created for this action. If the remote host is
# down, messages are spooled to disk and sent when it is up again.
#$WorkDirectory /var/lib/rsyslog # where to place spool files
#$ActionQueueFileName fwdRule1 # unique name prefix for spool files
#$ActionQueueMaxDiskSpace 1g   # 1gb space limit (use as much as possible)
#$ActionQueueSaveOnShutdown on # save messages to disk on shutdown
#$ActionQueueType LinkedList   # run asynchronously
#$ActionResumeRetryCount -1    # infinite retries if host is down
# remote host is: name/ip:port, e.g. 192.168.0.1:514, port optional
#*.* @@remote-host:514
# ### end of the forwarding rule ###
</code></pre>

<blockquote>
  <p>1.增加了$ModLoad ommysql这个模块，这个就是rsyslog连接mysql使用的模块</p>
  
  <p>2.<em>.</em>                                                     :ommysql:127.0.0.1,Syslog,rsysaloga,rsyslogp 这里意思是说使用某个可以连接mysql的账号和密码，连接mysql，将数据传输到mysql数据库里面去。</p>
  
  <p>3.udp传输配置依然要开启，那是因为rsyslog客户端会将日志以udp的方式传输到rsyslog服务端，所以双方都要开启同样的传输方式才可以完成传输。</p>
  
  <p>4.需要注意的是，如果开启了防火墙的话，那么记得514端口是rsyslog的传输端口，也要放开访问。</p>
</blockquote>

<h3>4.重启rsyslog服务</h3>

<pre><code>service rsyslog restart
</code></pre>

<p>至此，rsyslog部分已经完成配置，若要检查是否配置成功，可以检查数据库里是否有数据即可。</p>

<pre><code>mysql&gt; select * from SystemEvents;
</code></pre>

<h1>二、loganalyzer</h1>

<p>可以理解为loganalyzer其实就是一个web平台来展现日志数据的而已。</p>

<h3>1.下载并安装http+php+mysql套件</h3>

<pre><code>yum -y install httpd php php-mysql php-gd mysql mysql-server

httpd用来提供web服务
php使apache支持php，因为loganalyzer是用php编写
php-mysql用于loganalyzer连接数据库
php-gd用于绘图
mysql 是loganalyzer存储数据的地方
</code></pre>

<blockquote>
  <p>设置MySQL的root用户设置密码，因为MySQL被安装时，它的root用户时没有设置密码的，所以可以直接连或者设置一个，但是不影响我们这次配置任务。mysql需要启动，这个需要注意。</p>
</blockquote>

<h3>2.配置apache+php，并启动apache和mysql</h3>

<p>因为yum安装的关系，所有一切都已经配置好了</p>

<pre><code>如：grep -E 'Document|Listen' /etc/httpd/conf/httpd.conf |grep -v '^#'  
Listen 80
DocumentRoot "/var/www/html"

如：grep -v '^#' /etc/httpd/conf.d/php.conf 
&lt;IfModule prefork.c&gt;
  LoadModule php5_module modules/libphp5.so
&lt;/IfModule&gt;
&lt;IfModule worker.c&gt;
  LoadModule php5_module modules/libphp5-zts.so
&lt;/IfModule&gt;

AddHandler php5-script .php
AddType text/html .php

DirectoryIndex index.php    
</code></pre>

<p>启动httpd</p>

<pre><code>service httpd start
</code></pre>

<p>启动mysql</p>

<pre><code>service mysqld start
</code></pre>

<h3>3.下载loganalyzer</h3>

<p>下载地址：<a rel="nofollow" href="http://download.adiscon.com/loganalyzer/loganalyzer-3.6.6.tar.gz"></a><a rel="nofollow" href="http://download.adiscon.com/loganalyzer/loganalyzer-3.6.6.tar.gz">http://download.adiscon.com/loganalyzer/loganalyzer-3.6.6.tar.gz</a></p>

<p>将其放置到配置好的apache的web目录里面/var/www/html</p>

<pre><code>tar -zxpf loganalyzer-3.6.6.tar.gz -C /var/www/html 

cd /var/www/html/
[root@localhost html]# ls
loganalyzer-3.6.6
</code></pre>

<p>授权目录</p>

<pre><code>chown -R apache.apache /var/www/html/loganalyzer-3.6.6/
</code></pre>

<h3>4.配置loganalyzer</h3>

<p>创建loganalyzer数据库和访问账号密码和授权</p>

<pre><code>mysql&gt; create database loganalyzer;
Query OK, 1 row affected (0.04 sec)
mysql&gt; grant all on loganalyzer.* to loga@'localhost' identified by 'logp';
Query OK, 0 rows affected (0.00 sec)
mysql&gt; flush privileges;
Query OK, 0 rows affected (0.00 sec)
</code></pre>

<p>生成config.php</p>

<pre><code>cd /var/www/html/loganalyzer-3.6.6/contrib

chmod +x *

./configure.sh 
</code></pre>

<p>在当前目录会生成config.php文件，然后将其放置到src目录去</p>

<pre><code>cp config.php /var/www/html/loganalyzer-3.6.6/src/
</code></pre>

<p>在浏览器访问这台主机的80端口</p>

<p><a rel="nofollow" href="http://%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84ip/loganalyzer-3.6.6/src/install.php">http://服务端的ip/loganalyzer-3.6.6/src/install.php</a></p>

<p><img src="http://source1.godblessyuan.com/blog_logrotate_20150501.jpg" alt=""></p>

<p>备注：</p>

<pre><code>1.step 2 会检查config.php的写入权限，如果没有请授权一下， chmod +w config.php
2.step 3 选择enable user database，使用自定义数据库，然后填写数据库访问信息，这里的数据库是指loganalyzer的用户数据库，而不是rsyslog日志存储的数据库，这里是需要注意的。并且选取require user to be login。
3.step 5 会将loganalyzer的相关用户表写入到数据库，可以检查loganalyzer的数据库就可以看到了。
4.step 6 配置loganalyzer的管理员账号，登录loganalyzer界面使用的。
5.step 7 是配置rsyslog的日志存储数据库的访问方法，在source type选择 mysql native，然后填写mysql的访问信息，记住，这里是rsyslog的日志存储数据库，不是loganalyzer的用户数据库。
6.完成后会自动跳转提示登录，登陆后就可以看到数据了。
</code></pre>

<h1>三、科普时间</h1>

<h3>1.关于rsyslog的日志规则facitlity和priority</h3>

<pre><code>###rsyslog.conf中日志规则的定义的格式
facitlity.priority          Target
#facility: 日志设备(可以理解为日志类型):
==============================================================
auth         #pam产生的日志，认证日志
authpriv     #ssh,ftp等登录信息的验证信息，认证授权认证
cron         #时间任务相关
kern         #内核
lpr          #打印
mail         #邮件
mark(syslog) #rsyslog服务内部的信息,时间标识
news         #新闻组
user         #用户程序产生的相关信息
uucp         #unix to unix copy, unix主机之间相关的通讯
local 1~7    #自定义的日志设备
===============================================================
#priority: 级别日志级别:
=====================================================================
debug           #有调式信息的，日志信息最多
info            #一般信息的日志，最常用
notice          #最具有重要性的普通条件的信息
warning, warn   #警告级别
err, error      #错误级别，阻止某个功能或者模块不能正常工作的信息
crit            #严重级别，阻止整个系统或者整个软件不能正常工作的信息
alert           #需要立刻修改的信息
emerg, panic    #内核崩溃等严重信息
###从上到下，级别从低到高，记录的信息越来越少，如果设置的日志内性为err，则日志不会记录比err级别低的日志，只会记录比err更高级别的日志，也包括err本身的日志。
=====================================================================
Target：
  #文件, 如/var/log/messages
  #用户， root，*（表示所有用户）
  #日志服务器，@172.16.22.1
  #管道        | COMMAND
</code></pre>

<h3>2.如果日志数量太大，内容太多，可以进行过滤记录日志</h3>

<p>简单的方法可以在rsyslog客户端上的配置</p>

<pre><code>:msg, !contains, "informational"  
*.*                 @主rsyslog服务器ip或者host
</code></pre>

<p>在传输配置的上一行增加一个过滤配置，格式是严格的，一定要在上一行增加过滤配置，这里的意思是日志内容出现informational的就不记录。详细的过滤方式在官网上有说，需要的话就要慢慢按照他的方式来使用。</p>

<hr>
<p>参考文档：</p>

<p>1.<a rel="nofollow" href="http://litaotao.blog.51cto.com/6224470/1283871"></a><a rel="nofollow" href="http://litaotao.blog.51cto.com/6224470/1283871">http://litaotao.blog.51cto.com/6224470/1283871</a></p>

<p>2.<a rel="nofollow" href="http://ftp.ics.uci.edu/pub/centos0/ics-custom-build/BUILD/rsyslog-3.19.7/doc/rsyslog_conf.html"></a><a rel="nofollow" href="http://ftp.ics.uci.edu/pub/centos0/ics-custom-build/BUILD/rsyslog-3.19.7/doc/rsyslog_conf.html">http://ftp.ics.uci.edu/pub/centos0/ics-custom-build/BUILD/rsyslog-3.19...</a></p>

<p>3.<a rel="nofollow" href="http://www.cnblogs.com/tobeseeker/archive/2013/03/10/2953250.html"></a><a rel="nofollow" href="http://www.cnblogs.com/tobeseeker/archive/2013/03/10/2953250.html">http://www.cnblogs.com/tobeseeker/archive/2013/03/10/2953250.html</a></p>

<hr>
<p>原文链接：<br><a rel="nofollow" href="http://www.godblessyuan.com/2015/05/02/rsyslog_loganalyzer_setting/">http://www.godblessyuan.com/2015/05/02/rsyslog_loganalyzer_setting/</a></p>

2015年五月3日凌晨 1:14:59
【译】编写更好的CSS必备的40个工具
<p>众所周知，CSS是非常棒的，它使网站看起来很漂亮，可以为网站添加动画，并让呈现和内容分离。去了解CSS的一切是非常难做到的，它只会变得更加困难,因为我们想让我们的代码跨浏览器兼容。<br>
这里介绍了很多第三方工具，从简化工作流程到生成真正的CSS，这些工具都提供了我们需要的代码，并且比我们自己写出的代码运行的更快。</p>

<h3>Pure</h3>

<p><a rel="nofollow" href="http://purecss.io/">Pure</a>并不是一个框架。相反，它只是集成一些已经应用到模块中的CSS代码，方便我们使用。只需要为你的项目抓取你想要的那部分CSS代码。当然，所有组件都是可用的。Pure中包含了网格系统、按钮、表格、表单和菜单，这些都是建立在normalize.css上的。</p>

<h3>Magic Animations CSS3</h3>

<p>Magic Animations CSS3集成了 <a rel="nofollow" href="http://www.minimamente.com/example/magic_animations/">CSS3 Animations</a>，可以被应用在任何元素上，包含元素替换、滑出、变形和消褪等效果</p>

<h3>Jeet Grid System</h3>

<p><a rel="nofollow" href="http://jeet.gs/">Jeet</a>和semantic.gs有点类似，是以SASS为基础的网格系统。你可以在CSS中定义列（有时定义行），而不是为标记元素添加Class。Jeet使响应式布局更加容易，并进一步分离了内容和呈现。</p>

<h3>10 Pure CSS Flat Mobile Devices</h3>

<p>一个叫Oleg的人用纯CSS重绘并模拟了<a rel="nofollow" href="http://marvelapp.github.io/devices.css/">10种不同的移动设备</a>（包括iPhone 6, iPad Mini, Nexus 5, and Lumia 920）</p>

<h3>CodyHouse</h3>

<p>可以给你的网站添加不相关的、独立组件的<a rel="nofollow" href="http://codyhouse.co/">一个库</a>。CodyHouse是用HTML、CSS和JavaScript建立的，你可以选择各种各样的导航、视差效果、分页、模态窗口、页面布局等等，每一个组件独有让你快速使用的教程。</p>

<h3>Ratchet</h3>

<p>如果你使用HTML、CSS和JavaScript是移动APP，<a rel="nofollow" href="http://goratchet.com/">Ratchet</a>应该是一个不错的框架。每一个UI组件都是针对移动设备定制的，并且它有很多你在传统的HTML/CSS框架中看不到的功能。组件的默认效果都是非常棒的。</p>

<h3>Animo.JS</h3>

<p><a rel="nofollow" href="http://labs.bigroomstudios.com/libraries/animo-js">Animo</a>基于JQuery，能帮你更好的触发CSS动画。你可以叠加动画,或者第一次完成后触发第二个动画,并能同时利用CSS动画提供的硬件加速优点。</p>

<h3>Adobe Extract</h3>

<p>将一个Photoshop图层样式文件转换为CSS是一件很痛苦的事。幸运的是,Adobe做了一个<a rel="nofollow" href="http://www.adobe.com/go/extract_tryitnow_en">工具</a>(运行在浏览器中),允许你选择某个图层,将其属性转换为CSS代码。您也可以选择任何在线网站在PSD文件中使用的文本。</p>

<h3>Sculpt</h3>

<p><a rel="nofollow" href="https://www.heartinternet.uk/sculpt">Sculpt</a>基于SASS，是一个很好的框架。与其他已经发布的框架相比，Sculpt支持被遗弃的低版本浏览器。如果你用SASS开发移动优先的网站，并想要网站正常运行在低版本的IE上，可以考虑Sculpt。</p>

<h3>CSS3 Generator</h3>

<p>一个简单通用的<a rel="nofollow" href="http://css3generator.com/">CSS3属性</a>生成器。它不是很新，但是当你忘了一些精确的语法时，它是非常有用的。</p>

<h3>Bourbon Neat</h3>

<p>SASS的最爱了，<a rel="nofollow" href="http://neat.bourbon.io/">Bourbon Neat</a>是一个简单的语义网格系统，可以单独使用，但它的设计是用 <a rel="nofollow" href="http://bourbon.io/">Bourbon</a> mixin库。</p>

<h3>Enjoy CSS</h3>

<p><a rel="nofollow" href="http://enjoycss.com/">Enjoy CSS</a>也是一个CSS3生成器，但有趣的是，它不仅仅是生成CSS3-related代码,你还可以选择你想要应用的元素:一个div,文本输入,一个按钮,等等，用一种简单可视的方式得到你想要的确切效果。</p>

<h3>Keyframer</h3>

<p>从这里开始创建你的<a rel="nofollow" href="http://alexberg.in/keyframer/">keyframe-based CSS animations</a>。只需要去这个网站学习一些教程。</p>

<h3>Gumby</h3>

<p><a rel="nofollow" href="http://gumbyframework.com/">Gumby</a>是一个HTML/CSS框架，为那些喜欢在Ruby环境中工作的人设计的。你可以单独下载它,当然,但也打包为一个Ruby gem,Ruby gem是由那些这种技术的人创建的。</p>

<h3>CSShake</h3>

<p>这有更多的<a rel="nofollow" href="http://despreneur.com/20-fresh-css-tutorials-and-tools-to-try/">CSS动画</a>,重点是做出一些改变（知道我说什么吗?），但是，他们在炫耀他们的在线赚钱艺术（我不能容忍！）。</p>

<h3>Bounce.JS</h3>

<p><a rel="nofollow" href="http://bouncejs.com/">Bounce.JS</a>结合了可视化（用于设计CSS3 动画）和JS库（用于实现），对于那些喜欢视觉设计的人来说，它的使用是非常简单的。</p>

<h3>GridLover</h3>

<p>需要一个简单、可视化的方式去调整字体大小吗？<a rel="nofollow" href="http://www.gridlover.net/">GridLover</a>提供了一种简单的方式来预览排版、设置匀称的垂直和抓取CSS。你可以抓取CSS中字体的像素值、EMs, or REMs, 这些值会被格式成普通的CSS, SASS, LESS或其他代码风格。</p>

<h3>ExtractCSS</h3>

<p>想要快速设置CSS文件？一种方式是首先写HTML，然后设置ID、class等，将HTML代码粘贴到<a rel="nofollow" href="http://extractcss.com/">ExtractCSS</a>,Web APP会列出所有的选择器，最后将它们放入CSS文件就行就可以了。</p>

<h3>Kite</h3>

<p><a rel="nofollow" href="http://hiloki.github.io/kitecss/">Kite</a>是一个用于布局的CSS库，其设计用到了CSS Flex模块，但并不是完全使用Flex。Kite兼容IE8+。</p>

<h3>Pesticide</h3>

<p>需要确切地找出你的布局发生了什么?添加<a rel="nofollow" href="http://pesticide.io/">Pesticide</a>CSS文件。它将给页面上的每个元素添加边框,当元素作为子层次结构时，会巧妙地改变边框颜色。简单,但让人印象深刻。</p>

<h3>Pleeease</h3>

<p>疲惫的寻找不同的工具来对CSS进行预处理,添加特定的前缀,包括IE过滤器?不介意使用命令行吗?<a rel="nofollow" href="http://pleeease.io/">这是</a>给你的。兼容SASS,LESS和Stylus</p>

<h3>CSS Colours</h3>

<p><a rel="nofollow" href="http://colours.neilorangepeel.com/category/green/">CSS友好的颜色</a>名称列表，包含了十六进制和rgba格式。</p>

<h3>CSS Vocabulary</h3>

<p>一个小应用程序,提供了一个方便的<a rel="nofollow" href="http://apps.workflower.fi/vocabs/">css相关</a>的术语列表。选择其中一个,它将通过高亮一些示例代码来说明这个术语。</p>

<h3>Tridiv</h3>

<p>用纯CSS建立复杂的<a rel="nofollow" href="http://tridiv.com/">三维模型</a>。</p>

<h3>Buttons</h3>

<p>用SASS和Compass建立<a rel="nofollow" href="http://unicorn-ui.com/buttons/builder/">CSS按钮库</a></p>

<h3>CSS Menu Maker</h3>

<p><a rel="nofollow" href="http://cssmenumaker.com/">CSS Menu Maker</a>能帮助你建立简单、响应式的导航</p>

<h3>One% CSS Grid</h3>

<p><a rel="nofollow" href="http://onepcssgrid.mattimling.com/">One% CSS Grid</a>是一个12列的流布局网格系统，它是为构建更快、成本更低的响应式布局而设计的。</p>

<h3>Simptip</h3>

<p><a rel="nofollow" href="http://arashm.net/lab/simptip/">Simptip</a>是由SASS制作的CSS提示框工具。不仅可以设置提示框的方向（上、右、下、左），还可以设置不同的颜色，例如成功色、信息色、警告色和危险色。</p>

<h3>Myth</h3>

<p><a rel="nofollow" href="http://www.myth.io/">Myth</a>是一个CSS预处理器，这样你只需要写CSS，不用去担心低版本浏览器的支持，甚至低版本规范的改进。</p>

<h3>Hover CSS</h3>

<p>集成了<a rel="nofollow" href="http://ianlunn.github.io/Hover/">CSS悬浮效果</a>的代码，可被用在链接、按钮、logos、SVG和特色图片等等。</p>

<h3>CSS Animation Cheat Sheet</h3>

<p><a rel="nofollow" href="http://www.justinaguilar.com/animations/scrolling.html">CSS Animation Cheat Sheet</a>是一组预设、即插即用的动画CSS库.你只需要将样式表导入到你的网站，然后给你想要添加动画的元素添加类就行。</p>

<h3>Spinkit</h3>

<p><a rel="nofollow" href="http://tobiasahlin.com/spinkit/">Spinkit</a>包含了一些简单但非常棒的CSS动画加载效果</p>

<h3>Typebase.CSS</h3>

<p><a rel="nofollow" href="http://devinhunt.github.io/typebase.css/">Typebase.CSS</a>是一个很小的、可定制的排版样式表。它同时又less和sass版本,因此可以很容易地修改和合并到现代web项目。</p>

<h3>SpriteBox</h3>

<p>使你的<a rel="nofollow" href="http://www.spritebox.net/">CSS imager sprites</a>变成可拖放的编辑器，并让它为你写代码。</p>

<h3>CSS Ratiocinator</h3>

<p><a rel="nofollow" href="https://github.com/begriffs/css-ratiocinator">CSS Ratiocinator</a>是一个命令行工具，通过检查实际的呈现效果，会清除掉没用的CSS代码。它非常适合应用在一些CSS文件已经超出控制的大项目。</p>

<h3>CSS Beautifier</h3>

<p><a rel="nofollow" href="http://html.fwpolice.com/css/">美化CSS</a>，如果你已经得到了一个缩小的文件但不能找到原始(或你只是有点混乱的代码)文件时,代码的美化可以通过适当的格式化和缩进修复。</p>

<h3>CSScomb</h3>

<p>在使用CSS Beautifier让你的代码变得可读之后，你可以使用<a rel="nofollow" href="http://csscomb.com/">CSScomb</a>运行代码，确保所有的属性都按照字母表有规则的排序。记住，不是选择器，而是属性，例如宽度总是在字体声明之后等等</p>

<h3>Anima</h3>

<p>一个<a rel="nofollow" href="http://lvivski.com/anima/">动画库</a>,为了扩展CSS动画的功能而设计的，并且能同时为100个元素设置动画。</p>

<h3>Recess</h3>

<p><a rel="nofollow" href="http://twitter.github.io/recess/">Recess</a>是一个剥绒机程序,也可以作为一个编译器运行，目的是确保你的CSS符合一组规则并保持精简。每个规则可以单独禁以满足你的编码风格。</p>

<h3>Bonus: A to Z CSS</h3>

<p>Bonus: A to Z CSS不是一个工具，但是对于初学者来说是一个很好的资源。在<a rel="nofollow" href="http://www.atozcss.com/">A to Z</a>，Guy Routledge为每一个CSS基本规则，如盒子模型及最常用的CSS属性，提供了坚实的课程。</p>

<p>译文出处：<a rel="nofollow" href="http://www.ido321.com/1545.html"></a><a rel="nofollow" href="http://www.ido321.com/1545.html">http://www.ido321.com/1545.html</a><br>
英文原文：<a rel="nofollow" href="http://www.developerdrive.com/2015/03/40-tools-for-writing-better-css">40 tools for writing better CSS</a></p>

2015年五月2日晚上 11:36:15
Lua 学习笔记（下）
<p>前面的部分见 <a rel="nofollow" href="http://segmentfault.com/a/1190000002723417">Lua 学习笔记（上）</a></p>

<h1> 4 辅助库</h1>

<p>辅助库为我们用 Lua 与 C 的通信提供了一些方便的函数。基础 API 提供 Lua 与 C 交互的所有原始函数。辅助库作为更高层次的函数来解决一些通用的问题。</p>

<p>辅助库的所有函数定义在头文件 <code>luaxlib.h</code> 中，函数带有前缀 <code>luaL_</code> 。</p>

<p>辅助库函数是建立在基础库之上的，所以基础库做不了的事情辅助库也做不了。</p>

<p>有一些函数是用来检查函数参数的，这些函数都有这样的前缀 <code>luaL_check</code> 或者 <code>luaL_opt</code>。这些函数在检查出问题后会抛出错误。由于抛出的错误消息表明是参数错误（例如，“bad argument #1”），因此不要把这些函数用在参数以外的 Lua 值上。</p>

<h1> 5 标准库</h1>

<p>标准 Lua 库提供了许多有用的函数，这些函数都是直接用 C API 实现的。有一些函数提供了 Lua 语言本身所必要的服务（例如，<code>type</code> 和 <code>getmetatable</code>）；有一些提供了通向“外部”的服务（例如，I/O）；还有一些函数，可以由 Lua 进行实现，但是由于相当有用或者有重要的性能需求需要由 C 实现（例如 <code>sort</code>）。</p>

<p>所有的库都以 C 模块的形式分开提供。5.1中，Lua有以下几种标准库：</p>

<pre><code>- 基础库
- 包库
- 字符串操作库
- 表操作库
- 数学功能库
- 输入输出库
- 操作系统工具库
- 调试工具库
</code></pre>

<p>除了基础库和包库，其他库都是作为<strong>全局表的域</strong>或者<strong>对象的方法</strong>提供。</p>

<p>[待补充]</p>

<h2>  5.1 基础库函数</h2>

<p>基础库为 Lua 提供了一些核心函数。如果没有包含这个库，那么就可能需要自己来实现一些 Lua 语言特性了。</p>

<h3> assert (v [, message])</h3>

<p>如果其参数 <code>v</code> 的值为假（<code>nil</code> 或 <code>false</code>）， 它就调用 <code>error</code>； 否则，返回所有的参数。 在错误情况时， <code>message</code>  指那个错误对象； 如果不提供这个参数，参数默认为 "assertion failed!" 。</p>

<h4>例子</h4>

<pre><code>assert(5==4,"Number Not Equal!")    --&gt; 报错 Number Not Equal!
</code></pre>

<pre><code>assert(nil)                         --&gt; 报错 assertion failed!
</code></pre>

<h3> collectgarbage (opt [, arg])</h3>

<p>控制垃圾回收器的参数有两个，pause 和 step multipier。</p>

<p>参数 pause 控制了收集器在开始一个新的收集周期之前要等待多久。 随着数字的增大就导致收集器工作工作的不那么主动。 小于 1 的值意味着收集器在新的周期开始时不再等待。 当值为 2 的时候意味着在总使用内存数量达到原来的两倍时再开启新的周期。</p>

<p>参数 step multiplier 控制了收集器相对内存分配的速度。 更大的数字将导致收集器工作的更主动的同时，也使每步收集的尺寸增加。 小于 1 的值会使收集器工作的非常慢，可能导致收集器永远都结束不了当前周期。 缺省值为 2 ，这意味着收集器将以内存分配器的两倍速运行。</p>

<p>该函数是垃圾回收器的通用接口，根据 <code>opt</code> 参数的不同实现不同的功能。</p>

<ul>
<li>"stop": 停止垃圾回收。</li>
<li>"restart": 重启垃圾回收。</li>
<li>"collect": 执行垃圾回收的完整循环。</li>
<li>"count": 返回 Lua 当前使用的总内存（单位为 Kb）。</li>
<li>"step": 执行一步（一步可由多步组成）垃圾回收。步数可由参数 <code>arg</code> 控制（值越大，步数越多，0 表示执行一步（指最小的一步））。如果执行后完成了回收循环，返回 <code>true</code>。</li>
<li>"setpause": 把 arg/100 作为垃圾回收参数 pause 的新值。</li>
<li>"setstepmul": 把 arg/100 作为垃圾回收参数 step mutiplier 的新值。</li>
</ul>
<h4>例子</h4>

<p>进行垃圾回收前后的内存占用情况：</p>

<pre><code>x = collectgarbage("count")
print(x)            --&gt; 27.5615234375
collectgarbage("collect")
x = collectgarbage("count")
print(x)            --&gt; 26.7490234375
</code></pre>

<h3> dofile (filename)</h3>

<p>打开该名字的文件，并执行文件中的 Lua 代码块。 不带参数调用时， dofile 执行标准输入的内容（stdin）。 返回该代码块的所有返回值。 对于有错误的情况，dofile 将错误反馈给调用者 （即，dofile 没有运行在保护模式下）。</p>

<h4>例子</h4>

<p>同一目录下新建两个 Lua 文件，代码及输出：</p>

<pre><code>-- another.lua
return "Message from another file!"

-- sample.lua
x = dofile("./another.lua")
print(x)    --&gt; Message from another file!
</code></pre>

<p>dofile 在这里等价于</p>

<pre><code>function dofile()
    function func()
        return "Message from another file!"
    end

    return func()
end
</code></pre>

<p>于是等价的输出为</p>

<pre><code>print(dofile()) --&gt; Message from another file!
</code></pre>

<h3> error (message [, level])</h3>

<p>终止所保护的函数，抛出 message 消息，不再返回。</p>

<p>通常这个函数会在抛出的消息前面加上发生错误的地址信息。堆栈等级决定添加哪个地址。如果堆栈等级为 0 ，不返回地址信息；如果为 1，返回 error 语句所在位置；如果为 2，返回调用 error所在函数的位置；依此类推。</p>

<h4>定义</h4>

<pre><code>error([报错消息],[堆栈等级]=1)
</code></pre>

<h4>例子</h4>

<pre><code>function division(a,b)
    if b == 0 then error("Divisor cannot be 0!",2) end      -- level 值为 1 时，错误信息指向这里
    return a / b
end

print(division(5,1))
print(division(5,0))        -- level 值为 2 时，错误信息指向这里
</code></pre>

<h3> <code>_G</code>
</h3>

<p><code>_G</code> 持有全局环境的变量，Lua 本身用不到这个变量，更改变量不会影响到全局环境；反过来也一样。</p>

<h3> getfenv (f)</h3>

<p>返回函数的环境。 f 可以是一个 Lua 函数，也可以是函数在堆栈中的等级。等级 1 代表调用 getfenv() 的那个函数。如果传入的函数不是 Lua 函数，或者 f 是 0，那么 getfenv 返回 全局环境。</p>

<p>~~[待补充]不是太明白，没能给出合适的代码~~<br>
参考 <a rel="nofollow" href="http://www.jellythink.com/archives/882">Lua中的环境概念</a></p>

<h4>定义</h4>

<pre><code>getfenv([目标函数]=1)
</code></pre>

<h4>例子</h4>

<p>获取全局环境：</p>

<pre><code>for k,v in pairs(_G) do
print(k,v)
end

--string            table: 0x7ff200f02330
--xpcall            function: 0x7ff200d03cc0
--package           table: 0x7ff200e00000
--tostring          function: 0x7ff200d04560
--print             function: 0x7ff200d046a0
--os                table: 0x7ff200f01cb0
--unpack            function: 0x7ff200d04610
--require           function: 0x7ff200f006f0
--getfenv           function: 0x7ff200d042f0
--setmetatable      function: 0x7ff200d044a0
--next              function: 0x7ff200d04260
--assert            function: 0x7ff200d03fc0
--tonumber          function: 0x7ff200d04500
--io                table: 0x7ff200f014a0
--rawequal          function: 0x7ff200d046f0
--collectgarbage    function: 0x7ff200d04010
--arg               table: 0x7ff200e01360
--getmetatable      function: 0x7ff200d04340
--module            function: 0x7ff200f006a0
--rawset            function: 0x7ff200d047a0
--math              table: 0x7ff200e00040
--debug             table: 0x7ff200e00a00
--pcall             function: 0x7ff200d042b0
--table             table: 0x7ff200f00790
--newproxy          function: 0x7ff200d04820
--type              function: 0x7ff200d045c0
--coroutine         table: 0x7ff200d048c0
--_G                table: 0x7ff200d02fc0
--select            function: 0x7ff200d04400
--gcinfo            function: 0x7ff200d03000
--pairs             function: 0x7ff200d03e00
--rawget            function: 0x7ff200d04750
--loadstring        function: 0x7ff200d04200
--ipairs            function: 0x7ff200d03d70
--_VERSION          Lua 5.1
--dofile            function: 0x7ff200d04110
--setfenv           function: 0x7ff200d04450
--load              function: 0x7ff200d041b0
--error             function: 0x7ff200d04160
--loadfile          function: 0x7ff200d043a0
</code></pre>

<h3> getmetatable (object)</h3>

<p>如果对象没有元表，返回空；如果对象有 <code>__metatable</code> 域，返回对应的值；否则，返回对象的元表。</p>

<h4>例子</h4>

<p>对象有 <code>__metatable</code> 域的情况：</p>

<pre><code>t = {num = "a table"}

mt = {__index = {x = 1,y = 2},__metatable = {__index = {x = 5,y = 6}}}
setmetatable(t, mt)

print(getmetatable(t).__index.x)  --&gt; 5
print(t.x)                        --&gt; 1
</code></pre>

<p>~~进行操作时的元表依旧是与值直接关联的那个元表，不知道这样子处理有什么作用？~~</p>

<h3> ipairs (t)</h3>

<p>返回三个值：迭代器、传入的表 t、值 0 。迭代器能够根据传入的表 t 和索引 i 得到 i+1 和 t[i+1] 的值。</p>

<p>其实现形式类似于这样：</p>

<pre><code>function ipairs(t)

    function iterator(t,i)
        i = i + 1
        i = t[i] and i      -- 如果 t[i] == nil 则 i = nil；否则 i = i
        return i,t[i]
    end

    return iterator,t,0

end
</code></pre>

<h4>例子</h4>

<p>使用 ipairs 对表进行遍历，会从键值为 1 开始依次向后遍历，直到值为 nil。</p>

<pre><code>t = {"1","2",nil,[4]="4"}
-- t = {"1","2",[4]="4"}   -- 使用该表会得到相同的输出

for i,v in ipairs(t) do
    print(i,v)
end

--&gt; 1   1
--&gt; 2   2
</code></pre>

<h3> load (func [, chunkname])</h3>

<p>通过传入函数 func 的返回值获取代码块片段。func 函数的后一次调用返回的字符串应当能与前一次调用返回的字符串衔接在一起，最终得到完整的代码块。函数返回 nil 或无返回值时表示代码块结束。</p>

<p>load 函数会将得到的代码块作为函数返回。返回函数的环境为全局环境。如果出现错误，load 会返回 nil 和 错误信息。</p>

<p>chunkname 作为该代码块的名称，用在错误信息与调试信息中。</p>

<h4>例子</h4>

<p>[待补充]</p>

<h3> loadfile ([filename])</h3>

<p>使用方式与 dofile 类似，函数内容与 load 类似。从文件中获取代码块，如果没有指定文件，则从标准输入中获取。</p>

<p>loadfile 把文件代码编译为中间码，以文件代码作为一个代码块（chunk）,并返回包含此代码块的函数。<br>
编译代码成中间码，并返回编译后的chunk作为一个函数。 如果出现错误，则返回 nil 以及错误信息。</p>

<p>使用 loadfile，可以一次编译多次运行；而每次使用 dofile，都会执行一次编译。</p>

<h4>例子</h4>

<p>同一目录下新建两个 Lua 文件，代码及输出：</p>

<pre><code>-- sample.lua
f = loadfile("./sample.lua")
print(f())
--&gt; Message from another file!
--&gt; 0

-- another.lua
function fun()
 print("Message from another file!")
 return 0
end
res = fun()
return res
</code></pre>

<p>loadfile 在这里等价于</p>

<pre><code>function loadfile()
    function fun()
     print("Message from another file!")
     return 0
    end
    res = fun()
    return res
end
</code></pre>

<h3> loadstring (string [, chunkname])</h3>

<p>与 load 类似，只不过是从字符串中获取代码块。</p>

<p>要想加载并运行所给的字符串，使用如下惯用形式：</p>

<pre><code>assert(loadingstring(s))()
</code></pre>

<h3> next (table [, index])</h3>

<p>返回传入的表中下一个键值对。</p>

<h4>定义</h4>

<pre><code>next([表],[键]=nil)
</code></pre>

<p>第一个参数是要操作的表，第二个参数是表中的某个键。如果传入的键值为 nil ，则函数返回第一个键值对。如果传入一个有效的键值，则输出下一对键值对。如果没有下一个键值对，返回 nil。</p>

<p><strong>根据定义，可以使用 next 来判断一个表是否为空表。</strong></p>

<p><strong>注意：</strong></p>

<p>键值对的遍历顺序是不一定的，即使是对数字索引也是如此。如果想要按照数字索引的顺序获取键值对，参见 <a rel="nofollow">ipairs (t)</a> 函数。</p>

<h4>例子</h4>

<pre><code>t = {"table",["a"] = 5, ["c"] = 6}

-- index 为 nil
print(next(t, nil))         --&gt; 1   table

-- index 为 无效键
print(next(t,"d"))          --&gt; 编译错误

-- index 为 数字索引
print(next(t,1))            --&gt; a   5

-- index 为 一般键
print(next(t, "a"))         --&gt; c   6

-- index 为 最后一个键
print(next(t,"c"))          --&gt; nil
</code></pre>

<p>遍历顺序与定义顺序不一致的例子：</p>

<pre><code>t = {[1]="table",b = 4,["a"] = 5, ["c"] = 6, func}

t.func = function (...)
    return true
end

for k,v in pairs(t) do
    print(k,v)
end
--&gt; a   5
--&gt; func    function: 0x7f7f63c0ad50
--&gt; c   6
--&gt; b   4
</code></pre>

<p>而且从上面的例子中可以看出 <code>name = exp</code> 的键值对形式会占用</p>

<h3> pairs (t)</h3>

<p>返回三个值：next 函数，表 t，nil。通常用来遍历表中的所有键值对。<br>
如果 t 有元方法 __pairs ，将 t 作为参数 传入该函数并返回前三个返回值。</p>

<p>在使用 pairs 函数遍历表的过程中，可以删除域或者修改已有的域，但是如果添加新的域，可能出现无法预期的问题。</p>

<h4>例子</h4>

<pre><code>t = {"table",["a"] = 5, ["c"] = 6}
for k,v in pairs(t) do
    print(k,v)
end
--&gt; 1   table
--&gt; a   5
--&gt; c   6
</code></pre>

<p>在遍历表的过程中添加新的域导致问题出现的情况：</p>

<pre><code>t = {"table",["a"] = 5, ["c"] = 6}

for k,v in pairs(t) do
    -- 添加一个新的域
    if k == 'a' then
        t[2] = 8
    end
    print(k,v)
end
--&gt; 1   table
--&gt; a   5
</code></pre>

<h3> pcall (f [, arg1, ...])</h3>

<p>以保护模式调用传入的函数，也就是说不会抛出错误。如果捕获到抛出的错误，第一个参数返回 false，第二个参数返回错误信息；如果没有出现错误，第一个参数返回 ture，后面的参数返回传入函数的返回值。</p>

<h4>#</h4>

<pre><code>function fun(a,b)

    assert(not(b == 0), "divisor can't be 0 !")

    return a / b    
end

success, res = pcall(fun,5,0) --&gt; false .../sample.lua:3: divisor can't be 0 !
success, res = pcall(fun,5,1) --&gt; true  5
</code></pre>

<h3> print (...)</h3>

<p>仅作为快速查看某个值的工具，不用做格式化输出。正式的格式化输出见 string.format 与 io.write。</p>

<h3> rawequal (v1, v2)</h3>

<p>以 <code>raw</code> 作为前缀的函数均表示该方法在不触发任何元方法的情况下调用。</p>

<p>rawequal 检查 v1 是否与 v2 相等，返回比较结果。</p>

<h4>例子</h4>

<pre><code>t = {"value"}
s = "value"
s2 = "value"
print(rawequal(t, s))     --&gt; false
print(rawequal(s, s2))    --&gt; true
</code></pre>

<h3> rawget (table, index)</h3>

<p>获取 table 中键 index 的关联值，table 参数必须是一个表，找不到返回 nil 。</p>

<h4>例子</h4>

<pre><code>t = {"value",x = 5}

print(rawget(t, 1))     --&gt; value
print(rawget(t, "x"))   --&gt; 5
print(rawget(t, 2))     --&gt; nil
print(rawget("value",1))--&gt; bad argument #1 to 'rawget' (table expected, got string)
</code></pre>

<h3> rawset (table, index, value)</h3>

<p>将 table[index] 的值设置为 value 。table 必须是一张表，index 不能是 nil 或 NaN 。value 可以是任何值。返回修改后的 table 。</p>

<h4>例子</h4>

<pre><code>t = {"value",x = 5}
t2 = {"sub table"}
rawset(t, 1,"new value")
rawset(t, "y", 6)
rawset(t, t2,"sub table")
rawset(t,NaN,"NaN")         --&gt; table index is nil

print(t[1])                 --&gt; new value
print(t.y)                  --&gt; 6
print(t[t2])                --&gt; sub table
</code></pre>

<h3> select (index, ...)</h3>

<p>index 可以是数字或者字符 '#' 。当 index 为数字时，返回第 index + 1 个参数及后面的参数（支持负数形式的 index）；当 index 为 '#' 时，返回参数的个数（不包括第一个参数）。</p>

<h4>例子</h4>

<pre><code>t = {"table",x = 5}
t2 = {"table2"}

print(select(  1, 1, t, t2))    --&gt; 1  table: 0x7fad7bc0a830 table: 0x7fad7bc0ac20
print(select( -3, 1, t, t2))    --&gt; 1  table: 0x7fad7bc0a830 table: 0x7fad7bc0ac20
print(select("#", 1, t, t2))    --&gt; 3
</code></pre>

<h3> setfenv (f, table)</h3>

<p>设置函数 f 的环境表为 table 。f 可以是一个函数，或者是代表栈层级的数字。栈层级为 1 的函数是那个调用 setfenv 的函数，栈层级为 2 的函数就是更上一层的函数。 setfenv 返回 f。</p>

<p>特别的，如果 f 为 0，那么 setfenv 会把全局环境设置为 table 。并且不做任何返回。</p>

<p><em>Lua 的之后版本中去掉了 setfenv 和 getfenv 函数。</em></p>

<h4>例子</h4>

<p>使用栈层级操作 setfenv 的例子：</p>

<pre><code>function foobar(...)

    -- 设置 foobar 的环境
    t = {}
    setmetatable(t, {__index = _G })
    setfenv(1,t)
    a = 1
    b = 2

    -- 输出 foobar 的环境
    for k,v in pairs(getfenv(1)) do
        print(k,v)
    end
    print()

    function foo(...)
        -- 设置 foo 的环境，继承 foobar 的环境
        local t = {}
        setmetatable(t, {__index = _G})
        setfenv(1,t)
        x = 3
        y = 4

        -- 输出 foo 的环境
        for k,v in pairs(getfenv(1)) do
            print(k,v)
        end
        print()

        -- 再次设置 foobar 的环境
        setfenv(2, t)
    end


    foo()

    -- 再次输出 foobar 的环境
    for k,v in pairs(getfenv(1)) do
        print(k,v)
    end
end

foobar()

--&gt; a   1
--&gt; b   2
--&gt; 
--&gt; y   4
--&gt; x   3
--&gt; 
--&gt; y   4
--&gt; x   3
</code></pre>

<p>将 setfenv 用于模块加载：</p>

<pre><code>-- sample.lua 文件
local FuncEnv={}    -- 作为环境
setmetatable(FuncEnv, {__index = _G}) -- 为了能够访问原本全局环境的值，将全局环境表（_G）放在元表中

local func=loadfile("other.lua")    -- 返回一个函数，函数以 other 文件内容作为代码块
setfenv(func,FuncEnv)
func()                              -- 执行代码块，得到定义的 message 函数，该函数会存在环境中
FuncEnv.message()                   --通过环境调用函数，FuncEnv 此时就相当于一个独立模块
</code></pre>

<pre><code>-- other.lua 文件
function message()
    print("Message from another file!")
end
</code></pre>

<p>本小节参考了 <strong>斯芬克斯</strong> 的 <a rel="nofollow" href="http://www.cnblogs.com/sifenkesi/p/3843348.html">设置函数环境——setfenv</a> ，<strong>icyday</strong> 的 <a rel="nofollow" href="http://blog.csdn.net/icyday/article/details/8116818">lua5.1中的setfenv使用</a> 两篇博客。</p>

<h3> setmetatable (table, metatable)</h3>

<p>给 table 关联元表 metatable 。返回参数 table 。</p>

<p>如果元表定义了 <code>__metatable</code> 域，会抛出错误。</p>

<p>metatable 参数为 nil 表示解除已经关联的元表。</p>

<h4>例子</h4>

<pre><code>-- 关联一个定义了加法操作的元表
t = setmetatable({}, {__add = function(a,b)
    if type(a) == "table" and type(b) == "table" then
        return a.num + b.num
    end
end})

t.num = 5
t2 = {num = 6}
print(t+t2)         --&gt; 11      -- 只要有一个表进行了关联就能够进行运算

setmetatable(t, nil)            

-- 解除关联后再进行加法运算会报错
print(t+t2)         --&gt; attempt to perform arithmetic on global 't' (a table value)

</code></pre>

<h3> tonumber (e [, base])</h3>

<pre><code>tonumber([值],[基数]=10)
</code></pre>

<p>尝试把 e 转换为十进制数值并返回。如果无法转换返回 nil 。</p>

<p>base 表示传入参数的进制，默认为 10 进制。base 的可输入范围 [2,36]。高于 10 的数字用字母表示，A-Z 分别表示 11-35 。</p>

<h4>例子</h4>

<pre><code>print(tonumber(123))            --&gt; 123
print(tonumber("123"))          --&gt; 123
print(tonumber("abc"))          --&gt; nil
print(tonumber("abc", 20))      --&gt; 4232
print(tonumber("ABC", 20))      --&gt; 4232
</code></pre>

<h3> tostring (e)</h3>

<p>能将任意类型的值转换为合适的字符串形式返回。要控制数字转换为字符串的方式，使用 <a rel="nofollow">string.format(formatstring,...)</a> 。</p>

<p>如果值所关联的元表有 <code>__tostring</code> 域，则使用该域的元方法获取字符串。</p>

<h4>例子</h4>

<pre><code>function func()
    print("this is a function")
end
t = {name = "table"}

print(tostring(123))        --&gt; 123
print(tostring("abc"))      --&gt; abc
print(tostring(func))       --&gt; function: 0x7f86348013b0
print(tostring(t))          --&gt; table: 0x7f86348013e0
</code></pre>

<h3> type (v)</h3>

<p>返回 v 的类型，类型以字符串形式返回。 有以下八种返回值： "nil" ， "number"， "string"， "boolean"， "table"， "function"， "thread"， "userdata"。</p>

<h4>例子</h4>

<pre><code>type(nil)                   --&gt; "nil"
type(false)                 --&gt; "boolean"
type(123)                   --&gt; "number"
type("abc")                 --&gt; "string"

print(type(nil) == "nil")   --&gt; true
</code></pre>

<h3> unpack (list [, i [, j]])</h3>

<pre><code>unpack([列表],[起始位置]=1,[返回个数]=[列表长度])
</code></pre>

<p>返回表中的各个域的值，等价于返回</p>

<pre><code>return list[i], list[i+1], ···, list[j]
</code></pre>

<h4>例子</h4>

<pre><code>t = {1,2,3,a = 4,b = 5}

print(unpack(t, 1, 4))      --&gt; 1   2   3   nil
</code></pre>

<h3> _VERSION</h3>

<p>包含有当前解释器版本号的全局变量，当前版本的值为 "Lua 5.1"。</p>

<h3> xpcall (f, err [, arg1, ...]</h3>

<p>与 <a rel="nofollow">pcall (f, arg1, ...)</a> 类似。不同的是，如果 f 函数抛出了错误，那么 xpcall 不会返回从 f 抛出的错误信息，而是使用 err 函数返回的错误信息。</p>

<h4>例子</h4>

<pre><code>function fun(a,b)   -- 这里的参数没什么实际作用，就是展示下用法
    error("something wrong !!", 1)
end

-- pcall 
local success, res = pcall(fun,1,2)
print(success,res)      --&gt; false   .../sample.lua:2: something wrong !!

-- xpcall
local success, res = xpcall(fun,function()
    return "an error occured !!"
end,1,2)
print(success,res)      --&gt; false   an error occured !!
</code></pre>

<h2>   5.4 字符串操作</h2>

<h3>   5.4.1 模式</h3>

<h4>字符类</h4>

<p>字符类代表一组字符。可以用下列组合来表示一个字符类。</p>

<table>
<thead><tr>
<th>组合</th>
  <th>代表字母</th>
  <th>代表字符类型</th>
</tr></thead>
<tbody>
<tr>
<td>x</td>
  <td>（变量 x）</td>
  <td>
<code>^$()%.[]*+-?</code>以外的任一字符</td>
</tr>
<tr>
<td>.</td>
  <td>（dot）</td>
  <td>任意字符</td>
</tr>
<tr>
<td>%a</td>
  <td>（alphabet）</td>
  <td>字母</td>
</tr>
<tr>
<td>%b</td>
  <td>（bracket）</td>
  <td>对称字符以及字符间的内容</td>
</tr>
<tr>
<td>%c</td>
  <td>（control）</td>
  <td>控制字符（即各类转义符）</td>
</tr>
<tr>
<td>%d</td>
  <td>（digits）</td>
  <td>数字</td>
</tr>
<tr>
<td>%l</td>
  <td>（lowercase）</td>
  <td>小写字母</td>
</tr>
<tr>
<td>%p</td>
  <td>（punctuation）</td>
  <td>标点符号</td>
</tr>
<tr>
<td>%s</td>
  <td>（space）</td>
  <td>空格</td>
</tr>
<tr>
<td>%u</td>
  <td>（uppercase）</td>
  <td>大写字母</td>
</tr>
<tr>
<td>%w</td>
  <td>（word）</td>
  <td>字母和数字</td>
</tr>
<tr>
<td>%x</td>
  <td>（hexadecimal）</td>
  <td>十六进制字符</td>
</tr>
<tr>
<td>%z</td>
  <td>（zero）</td>
  <td>值为 0 的字符，即 '\0'</td>
</tr>
<tr>
<td>%x</td>
  <td>（变量 x）</td>
  <td>字母和数字以外的任一字符</td>
</tr>
</tbody>
</table>
<p>如果组合中的字符写成大写形式（例如将 '%a' 写成 '%A'），相当于对原来所代表的字符类型取<strong>补集</strong>。</p>

<p><strong>例子：</strong></p>

<p>前两行的数字标出每个字符的下标。find函数返回找出第一个符合查找条件的字符的下标。</p>

<pre><code>-----------------00000000001111111112 222222222333333333344444444445555 5
-----------------12345678901234567890 123456789012345678901234567890123 4
x = string.find("Tutu is a young man.\n His student number is 20230001.\0","i")
    --&gt; 6
x = string.find("Tutu is a young man.\n His student number is 20230001.\0",".")
    --&gt; 1
x = string.find("Tutu is a young man.\n His student number is 20230001.\0","%a")    --&gt; 1   
x = string.find("Tutu is a young man.\n His student number is 20230001.\0","%c")    --&gt; 21 
x = string.find("Tutu is a young man.\n His student number is 20230001.\0","%d")    --&gt; 45 
x = string.find("Tutu is a young man.\n His student number is 20230001.\0","%l")    --&gt; 2   
x = string.find("Tutu is a young man.\n His student number is 20230001.\0","%p")    --&gt; 20 
x = string.find("Tutu is a young man.\n His student number is 20230001.\0","%s")    --&gt; 5   
x = string.find("Tutu is a young man.\n His student number is 20230001.\0","%u")    --&gt; 1   
x = string.find("Tutu is a young man.\n His student number is 20230001.\0","%w")    --&gt; 1   
x = string.find("Tutu is a young man.\n His student number is 20230001.\0","%x")    --&gt; 9   
x = string.find("Tutu is a young man.\n His student number is 20230001.\0","%z")    --&gt; 54 
</code></pre>

<p>加 <code>()</code> 表示捕捉，find的第三个参数返回被捕捉到的字符串,在这里即返回找到的那个字符。</p>

<pre><code>x,y,z = string.find("%()~!@#$%^&amp;*():\";\'?&lt;&gt;._[]","(%%)")   --&gt; 1   1   %
x,y,z = string.find("%()~!@#$%^&amp;*():\";\'?&lt;&gt;._[]","(%#)")   --&gt; 7   7   #
x,y,z = string.find("%()~!@#$%^&amp;*():\";\'?&lt;&gt;._[]","(%\")")  --&gt; 16  16  "
</code></pre>

<p>下句中的 <code>+</code> 表示取一个或多个满足条件的连续字符。</p>

<pre><code>                 --1 2 3 4 5 6 7 8
x,y = string.find("\a\b\f\n\r\t\v\0","%c+")     --&gt; 1   7
</code></pre>

<p>上句基本列出了所有控制字符，并不是所有转义符都是控制字符，例如 <code>\\</code> 和 <code>\xff</code> 不属于控制字符。</p>

<p><code>match</code> 函数返回符合匹配条件的字符子串。</p>

<pre><code>x = string.match("0123456789ABCDEFabcdefg","%x+")   --&gt; 0123456789ABCDEFabcdef
</code></pre>

<p>输出的符号即为 <code>%x</code> 所支持的所有字符。</p>

<p><code>%b</code> 的使用方法与前面的组合形式略有不同，其形式为 <code>%bxy</code>，使用示例如下：</p>

<pre><code>---------------------00000000001111111112 22222222233333333334444444444555555 5
---------------------12345678901234567890 12345678901234567890123456789012345 6
x,y,z = string.find("Tutu is a young man.\n His student number is [20230001].\0","(%b[])")  --&gt; 45  54  [20230001]
x,y,z = string.find("Tutu is a young man.\n His student number is _20230001_.\0","(%b__)")  --&gt; 45  54  _20230001_
x,y,z = string.find("Tutu is a young man.\n His student number is _20230001_.\0","(%b21)")  --&gt; 48  53  230001
</code></pre>

<h4>
<code>[]</code> 字符集</h4>

<p>字符集操作是对<strong>字符类</strong>中<strong>组合</strong>的一个扩展。可以通过 <code>[]</code> 制定出用户所需的一套字符选取范围。</p>

<pre><code>---------------------0000000001111111111222222222
---------------------1234567890123456789012345678
x,y,z = string.find("[Email]: tangyikejun@163.com","([123])")           --&gt; 22  22  1
x,y,z = string.find("[Email]: tangyikejun@163.com","([l]])")            --&gt; 6   7   l]
x,y,z = string.find("[Email]: tangyikejun@163.com","([1-3])")           --&gt; 22  22  1
x,y,z = string.find("[Email]: tangyikejun@163.com","([^1-3])")          --&gt; 1   1   [
x,y,z = string.find("[Email]: tangyikejun@163.com","([^%d])")           --&gt; 1   1   [
x,y,z = string.find("[Email]: tangyikejun@163.com","([0-9][%d][%d])")   --&gt; 22  24  163
x,y,z = string.find("[Email]: tangyikejun@163.com","([0-9]+)")          --&gt; 22  24  163
</code></pre>

<p><strong>使用特点：</strong></p>

<ol>
<li>每个字符集仅限定一个字符的范围。</li>
<li>连字符 <code>-</code> 用于限定字符的范围，值域根据字符在ASCII码中对应的值得出，例如 <code>[0-7]</code> 代表字符范围为 0-7。<br><code>x,y,z = string.find("!\"#$%&amp;0123","([$-1]+)")          --&gt; 4   8   $%&amp;01</code>
</li>
<li>添加 <code>^</code> 表示对指定的字符范围取补集。<code>[^%d]</code> 等价于 <code>[%D]</code>。</li>
</ol>
<h4>模式项</h4>

<table>
<thead><tr>
<th>模式项</th>
  <th>作用</th>
</tr></thead>
<tbody>
<tr>
<td>+</td>
  <td>匹配1个或多个字符，尽可能多地匹配</td>
</tr>
<tr>
<td>-</td>
  <td>匹配0个或多个字符，尽可能少地匹配</td>
</tr>
<tr>
<td>*</td>
  <td>匹配0个或多个字符，尽可能多地匹配</td>
</tr>
<tr>
<td>？</td>
  <td>匹配0个或1个字符，尽可能多地匹配</td>
</tr>
</tbody>
</table>
<p><strong>使用特点：</strong></p>

<ol>
<li>模式项都是针对前一个字符而言的。例如 <code>abc-</code> 作用于字符 <code>c</code>。</li>
</ol>
<pre><code>---------------------0000000001
---------------------1234567890
x,y,z = string.find("aaaabbbccc","(%a+)")       --&gt; 1   10  aaaabbbccc
x,y,z = string.find("bbbccc","(a+)")            --&gt; nil nil nil
x,y,z = string.find("aaaabbbccc","(ab-c)")      --&gt; 4   8   abbbc
-- x,y,z = string.find("aaaaccc","(ab-c)")      --&gt; 4   5   ac
-- x,y,z = string.find("aaaaccc","(ab*c)")      --&gt; 4   5   ac
-- x,y,z = string.find("aaaabccc","(ab?c)")     --&gt; 4   6   abc
-- x,y,z = string.find("aaaabccc","(ba?c)")     --&gt; 5   6   bc
</code></pre>

<pre><code>---------------------000000000111 111111122
---------------------123456789012 345678901
x,y,z = string.find("tangyikejun\0 163.com","(%z%s%w+)")    --&gt; 12  16  
x,y,z = string.find("tangyikejun\0163.com","(%z%d%w+)")     --&gt; nil nil     nil 
</code></pre>

<p><strong>注意：</strong> <code>\0</code> 后面不能跟数字。而且用 find 返回的匹配字符串无法输出 <code>\0</code> 之后的部分。</p>

<h4>模式</h4>

<p>多个模式项组合形成<strong>模式</strong>。</p>

<ul>
<li>模式的前面添加 <code>^</code> 表示匹配从目标字符串的起始位置开始。</li>
<li>模式的末尾添加 <code>$</code> 表示匹配目标字符串的末尾子串。</li>
<li>其他位置的 <code>^</code> 和 <code>$</code> 作为普通字符处理。</li>
</ul>
<pre><code>---------------------0000000001111111111222222222
---------------------1234567890123456789012345678
x,y,z = string.find("[Email]: tangyikejun@163.com","^(.%a+)")   --&gt;1    6   [Email
x,y,z = string.find("[Email]: tangyikejun@163.com","(%a+)$")    --&gt;26   28  com
</code></pre>

<h4>
<code>()</code>捕捉</h4>

<p>捕捉是指将括号内的组合匹配结果保存起来，每个括号保存一个结果。<br>
保存的数据的顺序按照<strong>左括号的顺序</strong>排列。</p>

<pre><code>x,y,z,h,l = string.find("Tutu is a young man.\n His student number is _20230001_.\0","((%a+%s)(%a+%s)%b__)")    --&gt; 35  54  number is _20230001_    number  is 
</code></pre>

<p>字符串模式匹配可参考<a rel="nofollow" href="http://www.cnblogs.com/whiteyun/archive/2009/09/02/1541043.html">Lua模式匹配</a>。</p>

<h3> 5.4.2 库函数</h3>

<ul>
<li>字符串的下标从1开始。正数下标表示正向下标，负数表示反向下标（例如 -1 表示字符串最后一个字符）。</li>
<li>函数均默认支持模式匹配。</li>
<li>返回的匹配字符串无法输出 <code>\0</code> 之后的部分。</li>
</ul>
<h3> string.find(s,pattern[,init[,plain]])</h3>

<p>查找字符串的子串，如果找到，返回子串的起始位置、结束位置；找不到返回 nil。<br>
如果使用捕获（即对模式串用括号包裹起来）,则一并返回匹配得到的字符串。</p>

<h4>定义</h4>

<pre><code>string.find([字符串],[待查找字符串],[查找起始位置]=1,[禁用模式匹配]=false)
</code></pre>

<p>只有显式指定了 init 参数才能控制 plain 参数。</p>

<h4>例子</h4>

<pre><code>x,y,z = string.find("1001 is a Robot", "Robot")
print(x,y,z)                                --&gt; 11 15   nil
x,y,z = string.find("1001 is a Robot","1%d",1,true)
print(x,y,z)                                --&gt; nil nil nil
x,y,z = string.find("1001 is a Robot","(%d+)",1,false)
print(x,y,z)                                --&gt; 1   2   1001
</code></pre>

<h3> string.match(s,pattern[,init])</h3>

<p>与 <code>string.find</code> 类似，返回值不一样。<code>string.match</code> 查找字符串的子串，如果找到，返回子串；找不到返回 nil。</p>

<p>支持模式匹配。</p>

<h4>定义</h4>

<p>略</p>

<h4>例子</h4>

<pre><code>x = string.match("1001 is a Robot","001")
print(x)                --&gt; 001                             
x = string.match("1001 is a Robot","%d%d")
print(x)                --&gt; 10      
</code></pre>

<h3> string.gmatch(s,pattern)</h3>

<p>返回一个迭代函数，该函数每执行一次，就返回下一个捕捉到的匹配（如果没有使用捕捉，就返回整个匹配结果）。</p>

<h4>例子</h4>

<pre><code>for s in string.gmatch("I have a Dream.","%a+") do
    print(s)
end
--&gt; I
--&gt; have
--&gt; a
--&gt; Dream
</code></pre>

<pre><code>t = {}
s = "name=tangyikejun, number=20250001"

-- 将捕获的两个子串分别作为键和值放到表t中
for k, v in string.gmatch(s, "(%w+)=(%w+)") do
    t[k] = v
end

-- 输出表t
for k,v in pairs(t) do
    print(k,v)
end

--&gt; name    tangyikejun
--&gt; number  20250001
</code></pre>

<h3> string.format(formatstring,...)</h3>

<p>返回格式化之后的字符串。</p>

<h4>定义</h4>

<p>略</p>

<h4>例子</h4>

<pre><code>string.format("My name is %s", "tangyikejun")   --&gt; My name is tangyikejun
</code></pre>

<h3> string.len(s)</h3>

<p>返回字符串长度</p>

<h3> string.lower(s)</h3>

<p>返回小写字母的字符串</p>

<h3> string.upper(s)</h3>

<p>返回大写字母的字符串</p>

<h3> string.rep(s,n)</h3>

<p>对字符串进行重复</p>

<h4>定义</h4>

<pre><code>string.rep([字符串],[重复次数])
</code></pre>

<h4>例子</h4>

<pre><code>string.rep("Hello",4)   -- HelloHelloHelloHello
</code></pre>

<h3> string.reverse(s)</h3>

<p>返回反转后的字符串。</p>

<h3> string.sub(s,i[,j])</h3>

<p>返回子字符串。</p>

<h4>定义</h4>

<pre><code>string.sub([字符串],[开始字符下标],[结束字符下标]=-1)
</code></pre>

<h4>例子</h4>

<pre><code>x = string.sub("tangyikejun",7)
print(x)                --&gt; kejun
x = string.sub("tangyikejun",1,-6)
print(x)                --&gt; tangyi
</code></pre>

<h3> string.gsub(s,pattern,repl[,n])</h3>

<p>根据模式匹配对字符串中每一个匹配部分都做替换处理，返回替换后的字符串。</p>

<h4>定义</h4>

<pre><code>string.gsub([字符串],[模式匹配],[替换字符],[最大替换次数] = 无限制)
</code></pre>

<p>repl 参数（<code>[替换字符]</code>）支持 字符串、表、函数。</p>

<p>如果 repl 是字符串，那么该字符串就是用于替换的字符串。同时支持 <code>%n</code> 转义符操作，n 的范围是 0-9。n 范围为 [1,9] 时表示第 n 个捕获的匹配字符串，<code>%0</code> 表示整个匹配的字符串，<code>%%</code> 表示替换为一个 <code>%</code>。</p>

<p>如果 repl 是表，那么将捕获的第一个字符串作为键值（Key）进行查询（没有定义捕捉则以整个匹配的字符串为键值），查到的值作为替换的字符串。</p>

<p>如果 repl 是函数，那么每次匹配成功都会调用该函数，并以按序以所有捕捉作为参数传入函数。没有捕捉则以整个匹配的字符作为参数。</p>

<p>如果从表或函数得到是字符串或者是数字，就将其用于替换；如果得到的是 false 或 nil，那么匹配部分将不会发生变化。</p>

<h4>例子</h4>

<p>repl 为字符串</p>

<pre><code>s = "Never say die."
x = string.gsub(s,"die","never")            --&gt; Never say never.
x = string.gsub(s,"die","'%0'")             --&gt; Never say 'die'.
x = string.gsub(s,"(%a+)%s%a+%s(%a+)","%2") --&gt; die.
</code></pre>

<p>限制最大替换次数</p>

<pre><code>s = "never say never."
x = string.gsub(s,"never","Never",1)    --&gt; Never say never.
</code></pre>

<p>repl 是表</p>

<pre><code>t = {name="Lua",version="5.1"}
x = string.gsub("$name-$version.tar.gz","$(%a+)",t) --&gt; Lua-5.1.tar.gz
</code></pre>

<p>repl是函数</p>

<pre><code>x = string.gsub("4+5 = $return 4+5$","%$(.-)%$",function(s)return loadstring(s)() end)  --&gt; 4+5 = 9
x = string.gsub("23+45=$result", "((%d+)%+(%d+)=)%$%a+", function (s,a,b)
    sum = a+b
    return s..sum
end)    --&gt; 23+45=68
</code></pre>

<p>~~<strong>注意：</strong>似乎只支持匿名函数。~~</p>

<p>从表或函数返回的是 false 或 nil</p>

<pre><code>x = string.gsub("4+5 = $return 4+5$","%$(.-)%$",function(s)return nil end)  --&gt; 4+5 = $return 4+5$
t = {name="Lua",version=false}
x = string.gsub("$name-$version.tar.gz","$(%a+)",t) --&gt; Lua-$version.tar.gz
</code></pre>

<h3> string.byte(s[,i[,j]])</h3>

<p>返回字符的 ASCII 码值。</p>

<h4>定义</h4>

<pre><code>string.byte([字符串],[起始下标]=1,[结束下标]=[起始下标])
</code></pre>

<h4>例子</h4>

<pre><code>x,y,z = string.byte("abc",2)    --&gt; 98  nil nil
x,y,z = string.byte("abc",1,3)  --&gt; 97  98  99
</code></pre>

<h3> string.char(...)</h3>

<p>根据传入的 ASCII 编码值（[0-255]）得到对应的字符，传入多少编码值就返回多长的字符串。</p>

<h4>例子</h4>

<pre><code>x = string.char(98,99,100)  --&gt; bcd
</code></pre>

<p>如果输入字符超限会编译报错。</p>

<h3> string.dump(function)</h3>

<p>返回函数的二进制表示（字符串形式），把这个返回值传给 loadingstring 可以获得函数的一份拷贝（传入的函数必须是没有<strong>上值</strong>的 Lua 函数）。</p>

<h4>例子</h4>

<pre><code>function sum(a,b)
    return a + b
end

s = string.dump(sum)
x = loadstring(s)(4,4) -- 8
</code></pre>

<hr>
<h1>参考链接</h1>

<p><a rel="nofollow" href="http://blog.163.com/chenglian_999@126/blog/static/760002792009752402332/">BNF范式简介 </a>（简要介绍 BNF）<br><a rel="nofollow" href="http://www.jellythink.com/archives/882">Lua入门系列-果冻想</a>（对Lua进行了较为全面的介绍）<br><a rel="nofollow" href="https://docs.google.com/presentation/d/1gBGwwnmhkI5i45C5k4OmKSnAfBeqe_-nBFudUafgqHg/edit#slide=id.i52">Lua快速入门</a>（介绍 Lua 中最为重要的几个概念，为 C/C++ 程序员准备）<br><a rel="nofollow" href="http://manual.luaer.cn/">Lua 5.1 中文手册</a>（全面的 Lua5.1 中文手册）<br><a rel="nofollow" href="http://cloudwu.github.io/lua53doc/contents.html">Lua 5.3 中文手册</a>（云风花了6天写的，天哪，我看都要看6天的节奏呀）<br><a rel="nofollow" href="http://www.cnblogs.com/stephen-liu74/archive/2012/06/20/2413799.html">Lua迭代器和泛型for</a>（介绍 Lua 迭代器的详细原理以及使用）<br><a rel="nofollow" href="http://stackoverflow.com/questions/111102/how-do-javascript-closures-work">How do JavaScript closures work?——StackOverflow</a>（详细介绍了 Javascript 中闭包的概念）<br><a rel="nofollow" href="http://www.cnblogs.com/whiteyun/archive/2009/09/02/1541043.html">Lua模式匹配</a>（参考了此文中对 <code>%b</code> 的使用）<br><a rel="nofollow" href="http://w3.impa.br/~diego/software/luasocket/home.html">LuaSocket</a>（LuaSocket 官方手册）<br><a rel="nofollow" href="http://blog.sina.com.cn/s/blog_6a99c8bc0101krl8.html">Lua loadfile的用法, 与其他函数的比较</a>（loadfile的介绍部分引用了此文）<br><a rel="nofollow" href="http://segmentfault.com/a/1190000000410274">Lua 的元表</a>（对元表的描述比较有条理，通俗易懂，本文元表部分参考了此文）<br><a rel="nofollow" href="http://www.cnblogs.com/sifenkesi/p/3843348.html">设置函数环境——setfenv</a>（解释了如何方便地设置函数的环境，以及为什么要那样设置）<br><a rel="nofollow" href="http://blog.csdn.net/icyday/article/details/8116818">lua5.1中的setfenv使用</a>（介绍了该环境的设置在实际中的一个应用）</p>

2015年五月2日晚上 11:27:33
Lua 学习笔记（四）—— 元表与元方法
<p>我们可以使用操作符对 Lua 的值进行运算，例如对数值类型的值进行加减乘除的运算操作以及对字符串的连接、取长操作等（在 <a rel="nofollow" href="http://segmentfault.com/a/1190000002723520">Lua 学习笔记（三）—— 表达式</a> 中介绍了许多类似的运算）。<strong>元表</strong>正是定义这些操作行为的地方。</p>

<p>元表本质上是一个普通 Lua 表。元表中的键用来指定操作，称为“事件名”；元表中键所关联的值称为“元方法”，定义操作的行为。</p>

<h1>1 事件名与元方法</h1>

<p>仅表（table）类型值对应的元表可由用户自行定义。其他类型的值所对应的元表仅能通过 Debug 库进行修改。</p>

<p>元表中的事件名均以两条下划线 <code>__</code> 作为前缀，元表支持的事件名有如下几个：</p>

<pre><code>__index     -- 'table[key]'，取下标操作，用于访问表中的域
__newindex  -- 'table[key] = value'，赋值操作，增改表中的域
__call      -- 'func(args)'，函数调用，（参见 《Lua 学习笔记（三）—— 表达式》中的函数部分介绍）

-- 数学运算操作符
__add       -- '+'
__sub       -- '-'
__mul       -- '*'
__div       -- '/'
__mod       -- '%'
__pow       -- '^'
__unm       -- '-'

-- 连接操作符
__concat    -- '..'

-- 取长操作符
__len       -- '#'

-- 比较操作符
__eq        -- '=='
__lt        -- '&lt;'      -- a &gt; b 等价于 b &lt; a
__le        -- '&lt;='     -- a &gt;= b 等价于 b &lt;= a 
</code></pre>

<p>还有一些其他的事件，例如 <code>__tostring</code> 和 <code>__gc</code> 等。</p>

<p>下面进行详细介绍。</p>

<h1>2 元表与值</h1>

<p>每个值都可以拥有一个元表。对 userdata 和 table 类型而言，其每个值都可以拥有独立的元表，也可以几个值共享一个元表。对于其他类型，一个类型的值共享一个元表。例如所有数值类型的值会共享一个元表。除了字符串类型，其他类型的值默认是没有元表的。</p>

<p>使用 getmetatable 函数可以获取任意值的元表。<br>
使用 setmetatable 函数可以设置<strong>表类型</strong>值的元表。（这两个函数将在[基础函数库]部分进行介绍）</p>

<h2>2.1 例子</h2>

<p>只有字符串类型的值默认拥有元表：</p>

<pre><code>a = "5"
b = 5
c = {5}
print(getmetatable(a))      --&gt; table: 0x7fe221e06890
print(getmetatable(b))      --&gt; nil
print(getmetatable(c))      --&gt; nil
</code></pre>

<h1>3 事件的具体介绍</h1>

<p>事先提醒 Lua 使用 <code>raw</code> 前缀的函数来操作元方法，避免元方法的循环调用。</p>

<p>例如 Lua 获取对象 obj 中元方法的过程如下：</p>

<pre><code>rawget(getmetatable(obj)or{}, "__"..event_name)
</code></pre>

<h2>3.1 元方法 index</h2>

<p>index 是元表中最常用的事件,用于值的下标访问 -- <code>table[key]</code>。</p>

<p>事件 index 的值可以是函数也可以是表。当使用表进行赋值时，元方法可能引发另一次元方法的调用，具体可见下面伪码介绍。<br>
当用户通过键值来访问表时，如果没有找到键对应的值，则会调用对应元表中的此事件。如果 index 使用表进行赋值，则在该表中查找传入键的对应值；如果 index 使用函数进行赋值，则调用该函数，并传入表和键。</p>

<p>Lua 对取下标操作的处理过程用伪码表示如下：</p>

<pre><code>function gettable_event (table, key)
    -- h 代表元表中 index 的值
    local h     
    if type(table) == "table" then

        -- 访问成功
        local v = rawget(table, key)
        if v ~= nil then return v end

        -- 访问不成功则尝试调用元表的 index
        h = metatable(table).__index

        -- 元表不存在返回 nil
        if h == nil then return nil end
    else

        -- 不是对表进行访问则直接尝试元表
        h = metatable(table).__index

        -- 无法处理导致出错
        if h == nil then
            error(···);
        end
    end

    -- 根据 index 的值类型处理
    if type(h) == "function" then
        return h(table, key)            -- 调用处理器
    else 
        return h[key]                   -- 或是重复上述操作
    end
end
</code></pre>

<h3>3.1.1 例子</h3>

<p>使用表赋值：</p>

<pre><code>t = {[1] = "cat",[2] = "dog"}
print(t[3])             --&gt; nil
setmetatable(t, {__index = {[3] = "pig", [4] = "cow", [5] = "duck"}})
print(t[3])             --&gt; pig
</code></pre>

<p>使用函数赋值：</p>

<pre><code>t = {[1] = "cat",[2] = "dog"}
print(t[3])             --&gt; nil
setmetatable(t, {__index = function (table,key)
    key = key % 2 + 1
    return table[key]
end})
print(t[3])             --&gt; dog
</code></pre>

<h2>3.2 元方法 newindex</h2>

<p>newindex 用于赋值操作 -- <code>talbe[key] = value</code>。</p>

<p>事件 newindex 的值可以是函数也可以是表。当使用表进行赋值时，元方法可能引发另一次元方法的调用，具体可见下面伪码介绍。</p>

<p>当操作类型不是表或者表中尚不存在传入的键时，会调用 newindex 的元方法。如果 newindex 关联的是一个函数类型以外的值，则再次对该值进行赋值操作。反之，直接调用函数。</p>

<p>~~不是太懂：一旦有了 "newindex" 元方法， Lua 就不再做最初的赋值操作。 （如果有必要，在元方法内部可以调用 rawset 来做赋值。）~~</p>

<p>Lua 进行赋值操作时的伪码如下：</p>

<pre><code>function settable_event (table, key, value)
    local h
    if type(table) == "table" then

        -- 修改表中的 key 对应的 value
        local v = rawget(table, key)
        if v ~= nil then rawset(table, key, value); return end

        -- 
        h = metatable(table).__newindex

        -- 不存在元表，则直接添加一个域
        if h == nil then rawset(table, key, value); return end
    else
        h = metatable(table).__newindex
        if h == nil then
            error(···);
        end
    end

    if type(h) == "function" then
        return h(table, key,value)    -- 调用处理器
    else 


        h[key] = value             -- 或是重复上述操作
    end
end
</code></pre>

<h3>3.2.1 例子</h3>

<p>元方法为表类型：</p>

<pre><code>t = {}
mt = {}

setmetatable(t, {__newindex = mt})
t.a = 5
print(t.a)      --&gt; nil
print(mt.a)     --&gt; 5
</code></pre>

<p>通过两次调用 newindex 元方法将新的域添加到了表 mt 。</p>

<p>+++</p>

<p>元方法为函数：</p>

<pre><code>-- 对不同类型的 key 使用不同的赋值方式
t = {}
setmetatable(t, {__newindex = function (table,key,value)
    if type(key) == "number" then
        rawset(table, key, value*value)
    else
        rawset(table, key, value)
    end
end})
t.name = "product"
t[1] = 5
print(t.name)       --&gt; product
print(t[1])         --&gt; 25
</code></pre>

<h2>3.3 元方法 call</h2>

<p>call 事件用于函数调用 -- <code>function(args)</code>。</p>

<p>Lua 进行函数调用操作时的伪代码：</p>

<pre><code>function function_event (func, ...)

  if type(func) == "function" then
      return func(...)   -- 原生的调用
  else
      -- 如果不是函数类型，则使用 call 元方法进行函数调用
      local h = metatable(func).__call

      if h then
        return h(func, ...)
      else
        error(···)
      end
  end
end
</code></pre>

<h3>3.3.1 例子</h3>

<p>由于用户只能为表类型的值绑定自定义元表，因此，我们可以对表进行函数调用，而不能把其他类型的值当函数使用。</p>

<pre><code>-- 把数据记录到表中，并返回数据处理结果
t = {}

setmetatable(t, {__call = function (t,a,b,factor)
  t.a = 1;t.b = 2;t.factor = factor
  return (a + b)*factor
end})

print(t(1,2,0.1))       --&gt; 0.3

print(t.a)              --&gt; 1
print(t.b)              --&gt; 2
print(t.factor)         --&gt; 0.1
</code></pre>

<h2>3.4 运算操作符相关元方法</h2>

<p>运算操作符相关元方法自然是用来定义运算的。</p>

<p>以 add 为例，Lua 在实现 add 操作时的伪码如下：</p>

<pre><code>function add_event (op1, op2)
  -- 参数可转化为数字时，tonumber 返回数字，否则返回 nil
  local o1, o2 = tonumber(op1), tonumber(op2)
  if o1 and o2 then  -- 两个操作数都是数字？
    return o1 + o2   -- 这里的 '+' 是原生的 'add'
  else  -- 至少一个操作数不是数字时
    local h = getbinhandler(op1, op2, "__add") -- 该函数的介绍在下面
    if h then
      -- 以两个操作数来调用处理器
      return h(op1, op2)
    else  -- 没有处理器：缺省行为
      error(···)
    end
  end
end
</code></pre>

<p>代码中的 getbinhandler 函数定义了 Lua 怎样选择一个处理器来作二元操作。 在该函数中，首先，Lua 尝试第一个操作数。如果这个操作数所属类型没有定义这个操作的处理器，然后 Lua 会尝试第二个操作数。</p>

<pre><code> function getbinhandler (op1, op2, event)
   return metatable(op1)[event] or metatable(op2)[event]
 end
</code></pre>

<p>+++</p>

<p>对于一元操作符，例如取负，Lua 在实现 unm 操作时的伪码：</p>

<pre><code>function unm_event (op)
  local o = tonumber(op)
  if o then  -- 操作数是数字？
    return -o  -- 这里的 '-' 是一个原生的 'unm'
  else  -- 操作数不是数字。
    -- 尝试从操作数中得到处理器
    local h = metatable(op).__unm
    if h then
      -- 以操作数为参数调用处理器
      return h(op)
    else  -- 没有处理器：缺省行为
      error(···)
    end
  end
end
</code></pre>

<h3>3.4.1 例子</h3>

<p>加法的例子：</p>

<pre><code>t = {}
setmetatable(t, {__add = function (a,b)
  if type(a) == "number" then
      return b.num + a
  elseif type(b) == "number" then
      return a.num + b
  else
      return a.num + b.num
  end
end})

t.num = 5

print(t + 3)  --&gt; 8
</code></pre>

<p>取负的例子：</p>

<pre><code>t = {}
setmetatable(t, {__unm = function (a)
  return -a.num
end})

t.num = 5

print(-t)  --&gt; -5
</code></pre>

<h2>3.5 元方法 tostring</h2>

<p>对于 tostring 操作，元方法定义了值的字符串表示方式。</p>

<p><strong>例子：</strong></p>

<pre><code>t = {num = "a table"}
print(t)              --&gt; table: 0x7f8e83c0a820

mt = {__tostring = function(t)
  return t.num
end}
setmetatable(t, mt)

print(tostring(t))    --&gt; a table
print(t)              --&gt; a table
</code></pre>

<h2>3.6 比较类元方法</h2>

<p>对于三种比较类操作，均需要满足两个操作数为同类型，且关联同一个元表时才能使用元方法。</p>

<p>对于 eq （等于）比较操作，如果操作数所属类型没有原生的等于比较，则调用元方法。</p>

<p>对于 lt （小于）与 le （小于等于）两种比较操作，如果两个操作数同为数值或者同为字符串，则直接进行比较，否则使用元方法。</p>

<p>对于 le 操作，如果元方法 "le" 没有提供，Lua 就尝试 "lt"，它假定 a &lt;= b 等价于 not (b &lt; a) 。</p>

<h3>3.6.1 例子</h3>

<p>等于比较操作：</p>

<pre><code>t = {name="number",1,2,3}
t2 = {name = "number",4,5,6}
mt = {__eq = function (a,b)
    return a.name == b.name
end}
setmetatable(t,mt)              -- 必须要关联同一个元表才能比较
setmetatable(t2,mt)

print(t==t2)   --&gt; true
</code></pre>

<h2>3.7 其他事件的元方法</h2>

<p>对于连接操作，当操作数中存在数值或字符串以外的类型时调用该元方法。</p>

<p>对于取长操作，如果操作数不是字符串类型，也不是表类型，则尝试使用元方法（这导致自定义的取长基本没有，在之后的版本中似乎做了改进）。</p>

<h3>3.7.1 例子</h3>

<p>取长操作：</p>

<pre><code>t = {1,2,3,"one","two","three"}
setmetatable(t, {__len = function (t)
  local cnt = 0
  for k,v in pairs(t) do
    if type(v) == "number" then 
      cnt = cnt + 1
      print(k,v)
    end
  end
  return cnt
end})

-- 结果是 6 而不是预期中的 3
print(#t)   --&gt; 6 
</code></pre>

2015年五月2日晚上 11:19:16
防止表单多次提交
<div class="markdown-text"><h2>Node.js CSRF protection middleware</h2>
<p>这是防止表单多次提交的，原理是利用cookie和session生产token，和java里的token都是一样的概念</p>
<p>官方提供的中间件，还不错</p>
<p><a href="https://github.com/expressjs/csurf">https://github.com/expressjs/csurf</a></p>
<h2>ajax提交</h2>
<p>如果是ajax提交，就disable button吧</p>
</div>

2015年五月2日晚上 11:11:03
Lua 学习笔记（三）—— 表达式
<h1>1 数学运算操作符</h1>

<h2>1.1 <code>%</code> 操作符</h2>

<p>Lua 中的 <code>%</code> 操作符与 C 语言中的操作符虽然都是取模的含义，但是取模的方式不一样。<br>
在 C 语言中，取模操作是将两个操作数的绝对值取模后，在添加上第一个操作数的符号。<br>
而在 Lua 中，仅仅是简单的对商相对负无穷向下取整后的余数。</p>

<p>+++</p>

<p>在 C 中，</p>

<pre><code>a1 = abs(a);
b1 = abs(b);
c = a1 % b1 = a1 - floor(a1/b1)*b1;

a % b = (a &gt;= 0) ? c : -c;
</code></pre>

<p>在 Lua 中，</p>

<pre><code>a % b == a - math.floor(a/b)*b
</code></pre>

<p>Lua 是直接根据取模定义进行运算。 C 则对取模运算做了一点处理。</p>

<p>+++</p>

<p><strong>举例：</strong></p>

<p>在 C 中</p>

<pre><code>int a = 5 % 6;
int b = 5 % -6;
int c = -5 % 6;
int d = -5 % -6;

printf("a,b,c,d");--5,5,-5,-5
</code></pre>

<p>在 Lua 中</p>

<pre><code>a = 5 % 6
b = 5 % -6
c = -5 % 6
d = -5 % -6

x = {a,b,c,d}

for i,v in ipairs(x) do
    print(i,v)
end


--&gt; 5
--&gt; -1
--&gt; 1
--&gt; -5
</code></pre>

<p>可以看到，仅当操作数同号时，两种语言的取模结果相同。异号时，取模结果的符号与数值均不相等。</p>

<p>在 Lua 中的取模运算总结为：a % b，如果 a，b 同号，结果取 a，b 绝对值的模；异号，结果取 b 绝对值与绝对值取模后的差。取模后值的符号与 b 相同。</p>

<h1>2 比较操作符</h1>

<p>比较操作的结果是 <code>boolean</code> 型的，非 <code>true</code> 即 <code>false</code>。</p>

<p>支持的操作符有：</p>

<pre><code>&lt; &lt;= ~= == &gt; &gt;=
</code></pre>

<p>不支持 <code>!</code> 操作符。</p>

<p>+++</p>

<p>对于 <code>==</code> 操作，运算时先比较两个操作数的类型，如果不一致则结果为 false。此时数值与字符串之间并不会自动转换。</p>

<p>比较两个对象是否相等时，仅当指向同一内存区域时，判定为 <code>true</code>。·</p>

<pre><code>a = 123
b = 233
c = "123"
d = "123"
e = {1,2,3}
f = e
g = {1,2,3}

print(a == b)       --&gt; false
print(a == c)       --&gt; false      -- 数字与字符串作为不同类型进行比较
print(c == d)       --&gt; true       
print(e == f)       --&gt; true       -- 引用指向相同的对象
print(e == g)       --&gt; false      -- 虽然内容相同，但是是不同的对象
print(false == nil) --&gt; false      -- false 是 boolean，nil 是 nil 型
</code></pre>

<p>方便标记，<code>--&gt;</code> 代表前面表达式的结果。</p>

<p>+++</p>

<p><code>userdata</code> 与 <code>table</code> 的比较方式可以通过元方法 <code>eq</code> 进行改变。</p>

<p>大小比较中，数字和字符串的比较与 C 语言一致。如果是其他类型的值，Lua会尝试调用元方法 <code>lt</code> 和 <code>le</code>。</p>

<h1>3 逻辑操作符</h1>

<p><code>and,or,not</code></p>

<p>仅认为 <code>false</code> 与 <code>nil</code> 为假。</p>

<h2>3.1 <code>not</code>
</h2>

<p>取反操作 <code>not</code> 的结果为 <code>boolean</code> 类型。(<code>and</code> 和 <code>or</code> 的结果则不一定为 <code>boolean</code>)</p>

<pre><code>b = not a           -- a 为 nil，b 为 true
c = not not a       -- c 为 false
</code></pre>

<h2>3.2 <code>and</code>
</h2>

<p><code>a and b</code>，如果 <code>a</code> 为假，返回 <code>a</code>，如果 <code>a</code> 为真， 返回 <code>b</code>。</p>

<p>注意，为什么 <code>a</code> 为假的时候要返回 <code>a</code> 呢？有什么意义？这是因为 <code>a</code> 可能是 <code>false</code> 或者 <code>nil</code>，这两个值虽然都为假，但是是有区别的。</p>

<h2>3.3 <code>or</code>
</h2>

<p><code>a or b</code>，如果 <code>a</code> 为假，返回 <code>b</code>，如果 <code>a</code> 为真， 返回 <code>a</code>。与 <code>and</code> 相反。</p>

<p>+++</p>

<p><strong>提示：</strong> 当逻辑操作符用于得出一个 <code>boolean</code> 型结果时，不需要考虑逻辑运算后返回谁的问题，因为逻辑操作符的操作结果符合原本的逻辑含义。</p>

<p>举例</p>

<pre><code>if (not (a &gt; min and a &lt; max)) then  -- 如果 a 不在范围内，则报错
    error() 
end
</code></pre>

<p>+++</p>

<h2>3.4 其他</h2>

<p><code>and</code> 与 <code>or</code> 遵循短路原则，第二个操作数仅在需要的时候会进行求值操作。</p>

<p>例子</p>

<pre><code><br>a = 5
x = a or jjjj() -- 虽然后面的函数并没有定义，但是由于不会执行，因此不会报错。


print(a)        --&gt;5
print(x)        --&gt;5
</code></pre>

<p>通过上面这个例子，我们应当对于逻辑操作有所警觉，因为这可能会引入一些未能及时预料到的错误。</p>

<h1>4 连接符</h1>

<p><code>..</code><br>
连接两个字符串（或者数字）成为新的字符串。对于其他类型，调用元方法 <code>concat</code>。</p>

<h1>5 取长度操作符</h1>

<p><code>#</code></p>

<p>对于字符串，长度为字符串的字符个数。</p>

<p>对于表，通过寻找满足t[n] 不是 nil 而 t[n+1] 为 nil 的下标 n 作为表的长度。</p>

<p>~~对于其他类型呢？~~</p>

<h2>5.1 例子</h2>

<pre><code>-- 字符串取长
print(#"abc\0")                         --&gt; 4
-- 表取长
print(#{[1]=1,[2]=2,[3]=3,x=5,y=6})     --&gt; 3
print(#{[1]=1,[2]=nil,[3]=3,x=5,y=6})   --&gt; 1
</code></pre>

<h1>6 优先级</h1>

<p>由低到高：</p>

<pre><code>or
and
 &lt;     &gt;     &lt;=    &gt;=    ~=    ==
 ..
 +     -
 *     /     %
 not   #     - (unary)
 ^
</code></pre>

<p><strong>幂运算&gt;单目运算&gt;四则运算&gt;连接符&gt;比较操作符&gt;and&gt;or</strong></p>

<h1>7 Table 构造</h1>

<p>Table 构造的 BNF 定义</p>

<pre><code>tableconstructor ::= `{´ [fieldlist] `}´
fieldlist ::= field {fieldsep field} [fieldsep]
field ::= `[´ exp `]´ `=´ exp | Name `=´ exp | exp
fieldsep ::= `,´ | `;´
</code></pre>

<p>BNF 定义参考 <a rel="nofollow" href="http://blog.163.com/chenglian_999@126/blog/static/760002792009752402332/">BNF范式简介 </a> 。</p>

<p>举例：</p>

<pre><code>a = {}
b = {["price"] = 5; cost = 4; 2+5}
c = { [1] = 2+5, [2] = 2, 8, price = "abc", ["cost"] = 4} -- b 和 c 构造的表是等价的


print(b["price"])   --&gt; 5
print(b.cost)       --&gt; 4
print(b[1])         --&gt; 7       -- 未给出键值的，按序分配下标，下标从 1 开始

print(c["price"])   --&gt; abc
print(c.cost)       --&gt; 4
print(c[1])         --&gt; 8       
print(c[2])         --&gt; 2       
</code></pre>

<p><strong>注意：</strong></p>

<ul>
<li>未给出键值的，按序分配下标，下标从 1 开始</li>
<li>如果表中有相同的键，那么以靠后的那个值作为键对应的值</li>
</ul>
<p>上面这两条的存在使得上面的例子中 c<a rel="nofollow" href="http://blog.163.com/chenglian_999@126/blog/static/760002792009752402332/">1</a> 的输出值为 8。</p>

<p>+++</p>

<p>如果表中有相同的键，那么以靠后的那个值作为键对应的值。</p>

<pre><code>a = {[1] = 5,[1] = 6} -- 那么 a[1] = 6
</code></pre>

<p>+++</p>

<p>如果表的最后一个域是表达式形式，并且是一个函数，那么这个函数的所有返回值都会加入到表中。</p>

<pre><code>a = 1
function order()
    a = a + 1
    return 1,2,3,4
end

b = {order(); a; order(); }

c = {order(); a; (order());}

print(b[1])                     --&gt; 1       
print(b[2])                     --&gt; 2       -- 表中的值并不是一次把表达式都计算结束后再赋值的
print(b[3])                     --&gt; 1       
print(b[4])                     --&gt; 2       -- 表达式形式的多返回值函数

print(#b)                       --&gt; 6       -- 表的长度为 6                 
print(#c)                       --&gt; 3       -- 函数添加括号后表的长度为 3
</code></pre>

<h1>8 函数</h1>

<p>函数是一个表达式，其值为 function 类型的对象。函数每次执行都会被实例化。</p>

<h2>8.1 函数定义</h2>

<p>Lua 中实现一个函数可以有以下三种形式。</p>

<pre><code>f = function() [block] end
local f; f = function() [block] end
a.f = function() [block] end
</code></pre>

<p>Lua 提供语法糖分别处理这三种函数定义。</p>

<pre><code>function f() [block] end
local function f() [block] end
function a.f() [block] end
</code></pre>

<p>+++</p>

<p>上面 <code>local</code> 函数的定义之所以不是 <code>local f = function() [block] end</code>，是为了避免如下错误：</p>

<pre><code>local f = function()
    print("local fun")
    if i==0 then 
        f()             -- 编译错误:attempt to call global 'f' (a nil value)
        i = i + 1
    end
end
</code></pre>

<h2>8.2 函数的参数</h2>

<p>形参会通过实参来初始化为局部变量。</p>

<p>参数列表的尾部添加 <code>...</code> 表示函数能接受不定长参数。如果尾部不添加，那么函数的参数列表长度是固定的。</p>

<pre><code>f(a,b)
g(a,b,...)
h(a,...,b)              -- 编译错误
</code></pre>

<pre><code>f(1)                    --&gt; a = 1, b = nil
f(1,2)                  --&gt; a = 1, b = 2
f(1,2,3)                --&gt; a = 1, b = 2

g(1,2)                  --&gt; a = 1, b = 2, (nothing)
g(1,2,3)                --&gt; a = 1, b = 2, (3)
g(1,f(4,5),3)           --&gt; a = 1, b = 4, (3)
g(1,f(4,5))             --&gt; a = 1, b = 4, (5)

</code></pre>

<p>+++</p>

<p>还有一种形参为self的函数的定义方式：</p>

<pre><code>a.f = function (self, params) [block] end
</code></pre>

<p>其语法糖形式为：</p>

<pre><code>function a:f(params) [block] end
</code></pre>

<p>使用举例：</p>

<pre><code>a = {name = "唐衣可俊"}
function a:f()
    print(self.name)
end
a:f()                       --&gt; 唐衣可俊   -- 如果这里使用 a.f()，那么 self.name 的地方会报错 attempt to index local 'self';此时应该写为 a.f(a)
</code></pre>

<p><code>:</code> 的作用在于函数定义与调用的时候可以少写一个 <code>self</code> 参数。这种形式是对<code>方法</code>的模拟</p>

<h2>8.3 函数调用</h2>

<p>Lua 中的函数调用的BNF语法如下：</p>

<pre><code>functioncall ::= prefixexp args
</code></pre>

<p>如果 prefixexp 的值的类型是 function， 那么这个函数就被用给出的参数调用。 否则 prefixexp 的元方法 "call" 就被调用， call 的第一个参数就是 prefixexp 的值，接下来的是 args 参数列表（参见 <a rel="nofollow">2.8 元表 | Metatable</a>）。</p>

<p>函数调用根据是否传入 <code>self</code> 参数分为 <code>.</code> 调用和 <code>:</code> 调用。<br>
函数调用根据传入参数的类型，可以分为<strong>参数列表调用、表调用、字符串调用</strong>。</p>

<p><strong>[待完善]</strong></p>

<h2>8.4 函数闭包</h2>

<p><strong>如果一个函数访问了它的外部变量，那么它就是一个闭包。</strong></p>

<p>由于函数内部的变量均为局部变量，外界无法对其进行访问。这时如果外界想要改变局部变量的值，那么就可以使用闭包来实现这一目的。<br>
具体的实现过程大致是这样，函数内部有能够改变局部变量的子函数，函数将这个子函数返回，那么外界就可以通过使用这个子函数来操作局部变量了。</p>

<p><strong>例子：</strong>利用闭包来实现对局部变量进行改变</p>

<pre><code>-- 实现一个迭代器

function begin(i)
    local cnt = i

    return function ()      -- 这是一个匿名函数，实现了自增的功能；同时它也是一个闭包，因为访问了外部变量 cnt
        cnt = cnt + 1
        return cnt
    end
end


iterator = begin(2)     -- 设置迭代器的初值为 2 ，返回一个迭代器函数

print(iterator())           -- 执行迭代
print(iterator())

</code></pre>

<p><strong>提示：</strong> 关于闭包的更多说明可参考<a rel="nofollow" href="http://stackoverflow.com/questions/111102/how-do-javascript-closures-work">JavaScript 闭包是如何工作的?——StackOverflow</a></p>

<hr>
<h4>参考链接</h4>

<p><a rel="nofollow" href="http://blog.163.com/chenglian_999@126/blog/static/760002792009752402332/">BNF范式简介 </a>（简要介绍 BNF）<br><a rel="nofollow" href="http://stackoverflow.com/questions/111102/how-do-javascript-closures-work">How do JavaScript closures work?——StackOverflow</a>（详细介绍了 Javascript 中闭包的概念）</p>

2015年五月2日晚上 10:43:06
求问本地异步读文件的效率问题？
<div class="markdown-text"><p>当用ajax发送多个post请求时，总时间取决于最慢的那个请求。 但当在本地异步读多个文件的时候，总时间还是取决于最慢的那个吗？ 我在想在底层异步读多个文件会导致时间增长，并不会比并行读文件效率高多少，不知道实际情况应该怎么分析？</p>
</div>

2015年五月2日晚上 10:41:34
详说 Cookie, LocalStorage 与 SessionStorage
<blockquote>
  <p>本文最初发布于我的个人博客：<a rel="nofollow" href="http://jerryzou.com/posts/cookie-and-web-storage/">咀嚼之味</a></p>
</blockquote>

<p>最近在找暑期实习，其中百度、网易游戏、阿里的面试都问到一些关于HTML5的东西，问题大多是这样开头的：“你用过什么HTML5的技术呀？” 而后，每次都能扯到 Cookie 和 localStorage 有啥差别。这篇文章就旨在详细地阐述这部分内容，而具体 Web Storage API 的使用可以参考<a rel="nofollow" href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API">MDN的文档</a>，就不在这篇文章中赘述了。</p>

<h2>基本概念</h2>

<h3>Cookie</h3>

<p>Cookie 是小甜饼的意思。顾名思义，cookie 确实非常小，它的大小限制为4KB左右，是网景公司的前雇员 Lou Montulli 在1993年3月的发明。它的主要用途有保存登录信息，比如你登录某个网站市场可以看到“记住密码”，这通常就是通过在 Cookie 中存入一段辨别用户身份的数据来实现的。</p>

<h3>localStorage</h3>

<p>localStorage 是 HTML5 标准中新加入的技术，它并不是什么划时代的新东西。早在 IE 6 时代，就有一个叫 userData 的东西用于本地存储，而当时考虑到浏览器兼容性，更通用的方案是使用 Flash。而如今，localStorage 被大多数浏览器所支持，如果你的网站需要支持 IE6+，那以 userData 作为你的 polyfill 的方案是种不错的选择。</p>

<table>
<thead><tr>
<th>特性</th>
  <th>Chrome</th>
  <th>Firefox (Gecko)</th>
  <th>Internet Explorer</th>
  <th>Opera</th>
  <th>Safari (WebKit)</th>
</tr></thead>
<tbody>
<tr>
<td>localStorage</td>
  <td>4</td>
  <td>3.5</td>
  <td>8</td>
  <td>10.50</td>
  <td>4</td>
</tr>
<tr>
<td>sessionStorage</td>
  <td>5</td>
  <td>2</td>
  <td>8</td>
  <td>10.50</td>
  <td>4</td>
</tr>
</tbody>
</table>
<h3>sessionStorage</h3>

<p>sessionStorage 与 localStorage 的接口类似，但保存数据的生命周期与 localStorage 不同。做过后端开发的同学应该知道 Session 这个词的意思，直译过来是“会话”。而 sessionStorage 是一个前端的概念，它只是可以将一部分数据在当前会话中保存下来，刷新页面数据依旧存在。但当页面关闭后，sessionStorage 中的数据就会被清空。</p>

<h2>三者的异同</h2>

<table>
<thead><tr>
<th>特性</th>
            <th>Cookie</th>
            <th>localStorage</th>
            <th>sessionStorage</th>
        </tr></thead>
<tbody>
<tr>
<td>数据的生命期</td>
            <td>可设置失效时间，默认是关闭浏览器后失效</td>
            <td>除非被清除，否则永久保存</td>
            <td>仅在当前会话下有效，关闭页面或浏览器后被清除</td>
        </tr>
<tr>
<td>存放数据大小</td>
            <td>4K左右</td>
            <td>一般为5MB</td>
<td>一般为5MB</td>
        </tr>
<tr>
<td>与服务器端通信</td>
            <td>每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题</td>
            <td>仅在客户端（即浏览器）中保存，不参与和服务器的通信</td>
<td>仅在客户端（即浏览器）中保存，不参与和服务器的通信</td>
        </tr>
<tr>
<td>易用性</td>
            <td>需要程序员自己封装，源生的Cookie接口不友好</td>
            <td>源生接口可以接受，亦可再次封装来对Object和Array有更好的支持</td>
<td>源生接口可以接受，亦可再次封装来对Object和Array有更好的支持</td>
        </tr>
</tbody>
</table>
<h3>应用场景</h3>

<p>有了对上面这些差别的直观理解，我们就可以讨论三者的应用场景了。</p>

<p>因为考虑到每个 HTTP 请求都会带着 Cookie 的信息，所以 Cookie 当然是能精简就精简啦，比较常用的一个应用场景就是判断用户是否登录。针对登录过的用户，服务器端会在他登录时往 Cookie 中插入一段加密过的唯一辨识单一用户的辨识码，下次只要读取这个值就可以判断当前用户是否登录啦。曾经还使用 Cookie 来保存用户在电商网站的购物车信息，如今有了 localStorage，似乎在这个方面也可以给 Cookie 放个假了~</p>

<p>而另一方面 localStorage 接替了 Cookie 管理购物车的工作，同时也能胜任其他一些工作。比如HTML5游戏通常会产生一些本地数据，localStorage 也是非常适用的。如果遇到一些内容特别多的表单，为了优化用户体验，我们可能要把表单页面拆分成多个子页面，然后按步骤引导用户填写。这时候 sessionStorage 的作用就发挥出来了。</p>

<h2>安全性的考虑</h2>

<p>需要注意的是，不是什么数据都适合放在 Cookie、localStorage 和 sessionStorage 中的。使用它们的时候，需要时刻注意是否有代码存在 XSS 注入的风险。因为只要打开控制台，你就随意修改它们的值，也就是说如果你的网站中有 XSS 的风险，它们就能对你的 localStorage 肆意妄为。所以千万不要用它们存储你系统中的敏感数据。</p>

<h2>参考资料</h2>

<ul>
<li><a rel="nofollow" href="http://stackoverflow.com/questions/19867599/what-is-the-difference-between-localstorage-sessionstorage-session-and-cookie">what is the difference between localStorage, sessionStorage, session and cookie?</a></li>
<li><a rel="nofollow" href="http://stackoverflow.com/questions/3718349/html5-localstorage-security">HTML5 localStorage security</a></li>
<li><a rel="nofollow" href="http://zh.wikipedia.org/wiki/Cookie">维基百科 - Cookie</a></li>
<li><a rel="nofollow" href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API">Web Storage API</a></li>
<li><a rel="nofollow" href="http://han.guokai.blog.163.com/blog/static/13671827120112694851799/">浏览器本地数据（sessionStorage、localStorage、cookie）与server端数据</a></li>
<li><a rel="nofollow" href="http://www.cnblogs.com/yuzhongwusan/archive/2011/12/19/2293347.html">HTMl5的sessionStorage和localStorage</a></li>
<li><a rel="nofollow" href="http://www.cnblogs.com/xiaowei0705/archive/2011/04/19/2021372.html">HTML5 LocalStorage 本地存储</a></li>
</ul>

2015年五月2日晚上 10:39:20
Lua 学习笔记（二）—— 语句
<p>Lua 中的语句支持赋值，控制结构，函数调用，还有变量声明。</p>

<p>不允许空的语句段，因此 <code>;;</code> 是非法的。</p>

<h2>1 语句组 | chuncks</h2>

<pre><code>chunck ::= {stat[';']}
</code></pre>

<p>(<code>[';']</code> 应该是表示语句组后面 <code>;</code> 是可选项。)</p>

<h2>2 语句块 | blocks</h2>

<pre><code>block ::= chunck
stat ::= do block end
</code></pre>

<p>可以将一个语句块显式地写成语句组，可以用于控制局部变量的作用范围。</p>

<h2>3 赋值 | assignment</h2>

<p>Lua 支持多重赋值。</p>

<p>多重赋值时，按序将右边的表达式的值赋值给左值。右值不足补 nil，右值多余舍弃。</p>

<pre><code>b = 1
a,b = 4 -- a = 4,b = nil 
</code></pre>

<p>+++</p>

<p>Lua 在进行赋值操作时，会一次性把右边的表达式都计算出来后进行赋值。</p>

<pre><code>i = 5
i,a[i] = i+1, 7 -- i = 6 ,a[5] = 7
</code></pre>

<p>特别地，有</p>

<pre><code>x,y = y,x -- 交换 x，y 的值
</code></pre>

<p>+++</p>

<p>对全局变量以及表的域的赋值操作含义可以在元表中更改。</p>

<h2>4 控制结构</h2>

<h3>4.1 条件语句</h3>

<pre><code>if [exp]
    [block]
elseif [exp]
    [block]
else
    [block]
end
</code></pre>

<h3>4.2 循环语句</h3>

<pre><code>while [exp]
    [block]
end
</code></pre>

<p>+++</p>

<pre><code>repeat
    [block]
until [exp]
</code></pre>

<p>注意，由于 <code>repeat</code> 语句到 <code>until</code> 还未结束，因此在 <strong><code>until</code> 之后的表达式中可以使用 <code>block</code> 中定义的局部变量。</strong></p>

<p>例如：</p>

<pre><code>a = 1
c = 5
repeat
    b = a + c
    c = c * 2
until b &gt; 20
print(c)            --&gt;     40
</code></pre>

<p>+++</p>

<h3>4.3 <code>break</code> 和 <code>return</code>
</h3>

<p><code>break</code> 和 <code>return</code> 只能写在语句块的最后一句，如果实在需要写在语句块中间，那么就在两个关键词外面包围 <code>do end</code> 语句块。</p>

<pre><code>do break end
</code></pre>

<h2>5 <code>For</code> 循环</h2>

<p><code>for</code> 循环的用法比较多，单独拎出来讲。</p>

<p><code>for</code> 中的表达式会在循环开始前一次性求值，在循环过程中不再更新。</p>

<h3>5.1 数字形式</h3>

<pre><code>for [Name] = [exp],[exp],[exp] do [block] end
</code></pre>

<p>三个 exp 分别代表<strong>初值，结束值，步进</strong>。exp 的值均需要是一个数字。<br>
第三个 exp 默认为 1，可以省略。</p>

<pre><code>a = 0

for i = 1,6,2 do
    a = a + i
end
</code></pre>

<p>等价于</p>

<pre><code>int a = 0;
for (int i = 1; i &lt;= 6;i += 2){ // 取到等号，如果步进是负的，那么会取 i &gt;= 6
    a += i;
}
</code></pre>

<h3>5.2 迭代器形式</h3>

<p>迭代器形式输出一个表时，如果表中有函数，则输出的顺序及个数不确定（笔者测试得出的结果，具体原因未知）。</p>

<p>迭代器形式的 for 循环的实质</p>

<pre><code>-- 依次返回 迭代器、状态表、迭代器初始值
function mypairs(t)

    function iterator(t,i)
        i = i + 1
        i = t[i] and i      -- 如果 t[i] == nil 则 i = nil；否则 i = i
        return i,t[i]
    end

    return iterator,t,0

end

-- 一个表
t = {[1]="1",[2]="2"}

-- 迭代形式 for 语句的 等价形式
do
local f, s, var = mypairs(t)
    while true do
        local var1, var2 = f(s, var)
        var = var1
        if var == nil then break end

        -- for 循环中添加的语句
        print(var1,var2)

    end
end

-- 迭代形式 for 语句
for var1,var2 in mypairs(t) do
    print(var1,var2)
end

--&gt; 1   1
--&gt; 2   2
--&gt; 1   1
--&gt; 2   2
</code></pre>

<h4>5.2.1 数组形式</h4>

<pre><code>ary = {[1]=1,[2]=2,[5]=5}
for i,v in ipairs(ary) do
    print(v)                    --&gt; 1 2
end
</code></pre>

<p>从1开始，直到数值型下标结束或者值为 nil 时结束。</p>

<h4>5.2.2 表遍历</h4>

<pre><code>table = {[1]=1,[2]=2,[5]=5}
for k,v in pairs(table) do
    print(v)                    --&gt; 1 2 5
end
</code></pre>

<p>遍历整个表的键值对。</p>

<p>关于迭代器的更多内容，可参考<a rel="nofollow" href="http://www.cnblogs.com/stephen-liu74/archive/2012/06/20/2413799.html">Lua 迭代器和泛型 for</a>。</p>

<hr>
<h4>参考链接</h4>

<p><a rel="nofollow" href="http://www.cnblogs.com/stephen-liu74/archive/2012/06/20/2413799.html">Lua迭代器和泛型for</a>（介绍 Lua 迭代器的详细原理以及使用）</p>

2015年五月2日晚上 10:29:56
Lua 学习笔记（一）—— 基本语法
<h2>1 简介</h2>

<p>由 clean C 实现。需要被宿主程序调用，可以注入 C 函数。</p>

<h2>2 语法约定</h2>

<p>Lua 的语法基于 BNF 的语法规则。</p>

<p>Lua 对大小写敏感。</p>

<h3>2.1 保留关键字</h3>

<p>C 语言中没有的关键字有：</p>

<p><code>and</code> <code>elseif</code> <code>function</code><br><code>in</code> <code>nil</code> <code>local</code> <code>not</code> <code>or</code><br><code>repeat</code> <code>then</code> <code>until</code></p>

<p><strong>规范：</strong>全局变量以下划线开头。</p>

<h3>2.2 操作符</h3>

<p>C 语言中没有的操作符：</p>

<pre><code>^ 
~= 
//  -- 向下取整
</code></pre>

<p>Lua 中没有的操作符：</p>

<pre><code>+=
-=
</code></pre>

<h3>2.3 字符串定义</h3>

<h4>采用转义符：通过转义符表示那些有歧义的字符</h4>

<p>字符表示</p>

<pre><code>a           -- 代表字符 a
\97         -- 代表字符 a
\049        -- 代表数字字符 1 
</code></pre>

<p>其他转义符表示</p>

<pre><code>\\n         -- 代表字符串 \n
\n          -- 代表换行
</code></pre>

<p><strong>注意</strong>数字字符必须是三位。其他字符则不能超过三位。</p>

<h4>采用长括号:长括号内的所有内容都作为普通字符处理。</h4>

<pre><code>[[]]        -- 0级长括号
[==[]==]    -- 2级长括号
</code></pre>

<h2>3 值与类型</h2>

<p>Lua 是动态语言，变量没有类型，值才有。值自身携带类型信息。</p>

<p>Lua 有八种基本数据类型：<code>nil, boolean, number, string, function, userdata, thread, table</code>。</p>

<p>仅 <code>nil</code> 和 <code>false</code> 导致条件为假，其他均为真。</p>

<p><code>userdata</code> 类型变量用于保存 C 数据。 Lua 只能对该类数据进行使用，而不能进行创建或修改，保证宿主程序完全掌握数据。</p>

<p><code>thread</code> 用于实现协程（coroutine）。</p>

<p><code>table</code> 用于实现关联数组。<code>table</code> 允许任何类型的数据做索引，也允许任何类型做 <code>table</code> 域中的值（前述<br><code>任何类型</code> 不包含 nil）。<code>table</code> 是 Lua 中唯一的数据结构。<br>
由于函数也是一种值，所以 <code>table</code> 中可以存放函数。</p>

<p><code>function, userdata, thread, table</code> <strong>这些类型的值都是对象</strong>。这些类型的变量都<strong>只是保存变量的引用</strong>，并且在进行赋值，参数传递，函数返回等操作时不会进行任何性质的拷贝。</p>

<p>库函数 <code>type()</code> 返回变量的类型描述信息。</p>

<h3>3.1 强制转换</h3>

<p>Lua 提供<strong>数字</strong>与<strong>字符串</strong>间的自动转换。<br>
可以使用 format 函数控制数字向字符串的转换。</p>

<h2>4 变量</h2>

<p>变量有三种类型：<strong>全局变量、局部变量、表中的域</strong>。</p>

<p><strong>函数外</strong>的变量默认为全局变量，除非用 local 显示声明。<strong>函数内</strong>变量与函数的参数默认为局部变量。</p>

<p>局部变量的作用域为从声明位置开始到所在语句块结束（或者是直到下一个同名局部变量的声明）。</p>

<p><strong>变量的默认值均为 nil。</strong></p>

<pre><code><br>a = 5               -- 全局变量
local b = 5     -- 局部变量

function joke()
    c = 5           -- 局部变量
    local d = 6 -- 局部变量
end

print(c,d)      --&gt; nil nil

do 
    local a = 6 -- 局部变量
    b = 6           -- 全局变量
    print(a,b); --&gt; 6 6
end

print(a,b)      --&gt; 5 6

</code></pre>

<p>方便标记，<code>--&gt;</code> 代表前面表达式的结果。</p>

<h3>4.1 索引</h3>

<p>对 table 的索引使用方括号 <code>[]</code>。Lua使用语法糖提供 <code>.</code> 操作。</p>

<pre><code>t[i]
t.i                 -- 当索引为字符串类型时的一种简化写法
gettable_event(t,i) -- 采用索引访问本质上是一个类似这样的函数调用
</code></pre>

<h3>4.2 环境表</h3>

<p>所有全局变量放在一个环境表里，该表的变量名为 <code>_env</code> 。对某个全局变量 <code>a</code> 的访问即 <code>_env.a</code> （<code>_env_</code> 只是为了方便说明）。</p>

<p>每个函数作为变量持有一个环境表的引用，里面包含该函数可调用的所有变量。<br>
子函数会从父函数继承环境表。<br>
可以通过函数 <code>getfenv / setfenv</code> 来读写环境表。</p>

2015年五月2日晚上 10:10:54
Lua 学习笔记（上）
<h1> 1 简介</h1>

<p>由 clean C 实现。需要被宿主程序调用，可以注入 C 函数。</p>

<h1> 2 语法</h1>

<p>采用基于 BNF 的语法规则。</p>

<h2>  2.1 语法约定</h2>

<p>Lua 对大小写敏感。</p>

<h3>   2.1.1 保留关键字</h3>

<p>C 语言中没有的关键字有：</p>

<p><code>and</code> <code>elseif</code> <code>function</code><br><code>in</code> <code>nil</code> <code>local</code> <code>not</code> <code>or</code><br><code>repeat</code> <code>then</code> <code>until</code></p>

<p><strong>规范：</strong>全局变量以下划线开头。</p>

<h3>   2.1.2 操作符</h3>

<p>C 语言中没有的操作符：</p>

<pre><code>^ 
~= 
//  -- 向下取整
</code></pre>

<p>Lua 中没有的操作符：</p>

<pre><code>+=
-=
</code></pre>

<h3>   2.1.3 字符串定义</h3>

<h4>采用转义符：通过转义符表示那些有歧义的字符</h4>

<p>字符表示</p>

<pre><code>a           -- 代表字符 a
\97         -- 代表字符 a
\049        -- 代表数字字符 1 
</code></pre>

<p>其他转义符表示</p>

<pre><code>\\n         -- 代表字符串 \n
\n          -- 代表换行
</code></pre>

<p><strong>注意</strong>数字字符必须是三位。其他字符则不能超过三位。</p>

<h4>采用长括号:长括号内的所有内容都作为普通字符处理。</h4>

<pre><code>[[]]        -- 0级长括号
[==[]==]    -- 2级长括号
</code></pre>

<h2>    2.2 值与类型</h2>

<p>Lua 是动态语言，变量没有类型，值才有。值自身携带类型信息。</p>

<p>Lua 有八种基本数据类型：<code>nil, boolean, number, string, function, userdata, thread, table</code>。</p>

<p>仅 <code>nil</code> 和 <code>false</code> 导致条件为假，其他均为真。</p>

<p><code>userdata</code> 类型变量用于保存 C 数据。 Lua 只能对该类数据进行使用，而不能进行创建或修改，保证宿主程序完全掌握数据。</p>

<p><code>thread</code> 用于实现协程（coroutine）。</p>

<p><code>table</code> 用于实现关联数组。<code>table</code> 允许任何类型的数据做索引，也允许任何类型做 <code>table</code> 域中的值（前述<br><code>任何类型</code> 不包含 nil）。<code>table</code> 是 Lua 中唯一的数据结构。<br>
由于函数也是一种值，所以 <code>table</code> 中可以存放函数。</p>

<p><code>function, userdata, thread, table</code> <strong>这些类型的值都是对象</strong>。这些类型的变量都<strong>只是保存变量的引用</strong>，并且在进行赋值，参数传递，函数返回等操作时不会进行任何性质的拷贝。</p>

<p>库函数 <code>type()</code> 返回变量的类型描述信息。</p>

<h3>   2.2.1 强制转换</h3>

<p>Lua 提供<strong>数字</strong>与<strong>字符串</strong>间的自动转换。<br>
可以使用 format 函数控制数字向字符串的转换。</p>

<h2>    2.3 变量</h2>

<p>变量有三种类型：<strong>全局变量、局部变量、表中的域</strong>。</p>

<p><strong>函数外</strong>的变量默认为全局变量，除非用 local 显示声明。<strong>函数内</strong>变量与函数的参数默认为局部变量。</p>

<p>局部变量的作用域为从声明位置开始到所在语句块结束（或者是直到下一个同名局部变量的声明）。</p>

<p><strong>变量的默认值均为 nil。</strong></p>

<pre><code><br>a = 5               -- 全局变量
local b = 5     -- 局部变量

function joke()
    c = 5           -- 局部变量
    local d = 6 -- 局部变量
end

print(c,d)      --&gt; nil nil

do 
    local a = 6 -- 局部变量
    b = 6           -- 全局变量
    print(a,b); --&gt; 6 6
end

print(a,b)      --&gt; 5 6

</code></pre>

<p>方便标记，<code>--&gt;</code> 代表前面表达式的结果。</p>

<h3>   2.3.1 索引</h3>

<p>对 table 的索引使用方括号 <code>[]</code>。Lua使用语法糖提供 <code>.</code> 操作。</p>

<pre><code>t[i]
t.i                 -- 当索引为字符串类型时的一种简化写法
gettable_event(t,i) -- 采用索引访问本质上是一个类似这样的函数调用
</code></pre>

<h3>   2.3.2 环境表</h3>

<p>所有全局变量放在一个环境表里，该表的变量名为 <code>_env</code> 。对某个全局变量 <code>a</code> 的访问即 <code>_env.a</code> （<code>_env_</code> 只是为了方便说明）。</p>

<p>每个函数作为变量持有一个环境表的引用，里面包含该函数可调用的所有变量。<br>
子函数会从父函数继承环境表。<br>
可以通过函数 <code>getfenv / setfenv</code> 来读写环境表。</p>

<h2>    2.4 语句 | statement</h2>

<p>支持赋值，控制结构，函数调用，还有变量声明。</p>

<p>不允许空的语句段，因此 <code>;;</code> 是非法的。</p>

<h3>    2.4.1 语句组 | chuncks</h3>

<pre><code>chunck ::= {stat[';']}
</code></pre>

<p>(<code>[';']</code> 应该是表示语句组后面 <code>;</code> 是可选项。)</p>

<h3>    2.4.2 语句块 | blocks</h3>

<pre><code>block ::= chunck
stat ::= do block end
</code></pre>

<p>可以将一个语句块显式地写成语句组，可以用于控制局部变量的作用范围。</p>

<h3>    2.4.3 赋值 | assignment</h3>

<p>Lua 支持多重赋值。</p>

<p>多重赋值时，按序将右边的表达式的值赋值给左值。右值不足补 nil，右值多余舍弃。</p>

<pre><code>b = 1
a,b = 4 -- a = 4,b = nil 
</code></pre>

<p>+++</p>

<p>Lua 在进行赋值操作时，会一次性把右边的表达式都计算出来后进行赋值。</p>

<pre><code>i = 5
i,a[i] = i+1, 7 -- i = 6 ,a[5] = 7
</code></pre>

<p>特别地，有</p>

<pre><code>x,y = y,x -- 交换 x，y 的值
</code></pre>

<p>+++</p>

<p>对全局变量以及表的域的赋值操作含义可以在元表中更改。</p>

<h3>    2.4.4 控制结构</h3>

<h4>条件语句</h4>

<pre><code>if [exp]
    [block]
elseif [exp]
    [block]
else
    [block]
end
</code></pre>

<h4>循环语句</h4>

<pre><code>while [exp]
    [block]
end
</code></pre>

<p>+++</p>

<pre><code>repeat
    [block]
until [exp]
</code></pre>

<p>注意，由于 <code>repeat</code> 语句到 <code>until</code> 还未结束，因此在 <strong><code>until</code> 之后的表达式中可以使用 <code>block</code> 中定义的局部变量。</strong></p>

<p>例如：</p>

<pre><code>a = 1
c = 5
repeat
    b = a + c
    c = c * 2
until b &gt; 20
print(c)            --&gt;     40
</code></pre>

<p>+++</p>

<h4>
<code>break</code> 和 <code>return</code>
</h4>

<p><code>break</code> 和 <code>return</code> 只能写在语句块的最后一句，如果实在需要写在语句块中间，那么就在两个关键词外面包围 <code>do end</code> 语句块。</p>

<pre><code>do break end
</code></pre>

<h3>    2.4.5 <code>For</code> 循环</h3>

<p><code>for</code> 循环的用法比较多，单独拎出来讲。</p>

<p><code>for</code> 中的表达式会在循环开始前一次性求值，在循环过程中不再更新。</p>

<h4>数字形式</h4>

<pre><code>for [Name] = [exp],[exp],[exp] do [block] end
</code></pre>

<p>三个 exp 分别代表<strong>初值，结束值，步进</strong>。exp 的值均需要是一个数字。<br>
第三个 exp 默认为 1，可以省略。</p>

<pre><code>a = 0

for i = 1,6,2 do
    a = a + i
end
</code></pre>

<p>等价于</p>

<pre><code>int a = 0;
for (int i = 1; i &lt;= 6;i += 2){ // 取到等号，如果步进是负的，那么会取 i &gt;= 6
    a += i;
}
</code></pre>

<h4>迭代器形式</h4>

<p>迭代器形式输出一个表时，如果表中有函数，则输出的顺序及个数不确定（笔者测试得出的结果，具体原因未知）。</p>

<p>迭代器形式的 for 循环的实质</p>

<pre><code>-- 依次返回 迭代器、状态表、迭代器初始值
function mypairs(t)

    function iterator(t,i)
        i = i + 1
        i = t[i] and i      -- 如果 t[i] == nil 则 i = nil；否则 i = i
        return i,t[i]
    end

    return iterator,t,0

end

-- 一个表
t = {[1]="1",[2]="2"}

-- 迭代形式 for 语句的 等价形式
do
local f, s, var = mypairs(t)
    while true do
        local var1, var2 = f(s, var)
        var = var1
        if var == nil then break end

        -- for 循环中添加的语句
        print(var1,var2)

    end
end

-- 迭代形式 for 语句
for var1,var2 in mypairs(t) do
    print(var1,var2)
end

--&gt; 1   1
--&gt; 2   2
--&gt; 1   1
--&gt; 2   2
</code></pre>

<h5>数组形式</h5>

<pre><code>ary = {[1]=1,[2]=2,[5]=5}
for i,v in ipairs(ary) do
    print(v)                    --&gt; 1 2
end
</code></pre>

<p>从1开始，直到数值型下标结束或者值为 nil 时结束。</p>

<h5>表遍历</h5>

<pre><code>table = {[1]=1,[2]=2,[5]=5}
for k,v in pairs(table) do
    print(v)                    --&gt; 1 2 5
end
</code></pre>

<p>遍历整个表的键值对。</p>

<p>关于迭代器的更多内容，可参考<a rel="nofollow" href="http://www.cnblogs.com/stephen-liu74/archive/2012/06/20/2413799.html">Lua 迭代器和泛型 for</a>。</p>

<h2> 2.5 表达式</h2>

<h3> 2.5.1 数学运算操作符</h3>

<h4>
<code>%</code> 操作符</h4>

<p>Lua 中的 <code>%</code> 操作符与 C 语言中的操作符虽然都是取模的含义，但是取模的方式不一样。<br>
在 C 语言中，取模操作是将两个操作数的绝对值取模后，在添加上第一个操作数的符号。<br>
而在 Lua 中，仅仅是简单的对商相对负无穷向下取整后的余数。</p>

<p>+++</p>

<p>在 C 中，</p>

<pre><code>a1 = abs(a);
b1 = abs(b);
c = a1 % b1 = a1 - floor(a1/b1)*b1;

a % b = (a &gt;= 0) ? c : -c;
</code></pre>

<p>在 Lua 中，</p>

<pre><code>a % b == a - math.floor(a/b)*b
</code></pre>

<p>Lua 是直接根据取模定义进行运算。 C 则对取模运算做了一点处理。</p>

<p>+++</p>

<p><strong>举例：</strong></p>

<p>在 C 中</p>

<pre><code>int a = 5 % 6;
int b = 5 % -6;
int c = -5 % 6;
int d = -5 % -6;

printf("a,b,c,d");--5,5,-5,-5
</code></pre>

<p>在 Lua 中</p>

<pre><code>a = 5 % 6
b = 5 % -6
c = -5 % 6
d = -5 % -6

x = {a,b,c,d}

for i,v in ipairs(x) do
    print(i,v)
end


--&gt; 5
--&gt; -1
--&gt; 1
--&gt; -5
</code></pre>

<p>可以看到，仅当操作数同号时，两种语言的取模结果相同。异号时，取模结果的符号与数值均不相等。</p>

<p>在 Lua 中的取模运算总结为：a % b，如果 a，b 同号，结果取 a，b 绝对值的模；异号，结果取 b 绝对值与绝对值取模后的差。取模后值的符号与 b 相同。</p>

<h3> 2.5.2 比较操作符</h3>

<p>比较操作的结果是 <code>boolean</code> 型的，非 <code>true</code> 即 <code>false</code>。</p>

<p>支持的操作符有：</p>

<pre><code>&lt; &lt;= ~= == &gt; &gt;=
</code></pre>

<p>不支持 <code>!</code> 操作符。</p>

<p>+++</p>

<p>对于 <code>==</code> 操作，运算时先比较两个操作数的类型，如果不一致则结果为 false。此时数值与字符串之间并不会自动转换。</p>

<p>比较两个对象是否相等时，仅当指向同一内存区域时，判定为 <code>true</code>。·</p>

<pre><code>a = 123
b = 233
c = "123"
d = "123"
e = {1,2,3}
f = e
g = {1,2,3}

print(a == b)       --&gt; false
print(a == c)       --&gt; false      -- 数字与字符串作为不同类型进行比较
print(c == d)       --&gt; true       
print(e == f)       --&gt; true       -- 引用指向相同的对象
print(e == g)       --&gt; false      -- 虽然内容相同，但是是不同的对象
print(false == nil) --&gt; false      -- false 是 boolean，nil 是 nil 型
</code></pre>

<p>方便标记，<code>--&gt;</code> 代表前面表达式的结果。</p>

<p>+++</p>

<p><code>userdata</code> 与 <code>table</code> 的比较方式可以通过元方法 <code>eq</code> 进行改变。</p>

<p>大小比较中，数字和字符串的比较与 C 语言一致。如果是其他类型的值，Lua会尝试调用元方法 <code>lt</code> 和 <code>le</code>。</p>

<h3>    2.5.3 逻辑操作符</h3>

<p><code>and,or,not</code></p>

<p>仅认为 <code>false</code> 与 <code>nil</code> 为假。</p>

<h4><code>not</code></h4>

<p>取反操作 <code>not</code> 的结果为 <code>boolean</code> 类型。(<code>and</code> 和 <code>or</code> 的结果则不一定为 <code>boolean</code>)</p>

<pre><code>b = not a           -- a 为 nil，b 为 true
c = not not a       -- c 为 false
</code></pre>

<h4><code>and</code></h4>

<p><code>a and b</code>，如果 <code>a</code> 为假，返回 <code>a</code>，如果 <code>a</code> 为真， 返回 <code>b</code>。</p>

<p>注意，为什么 <code>a</code> 为假的时候要返回 <code>a</code> 呢？有什么意义？这是因为 <code>a</code> 可能是 <code>false</code> 或者 <code>nil</code>，这两个值虽然都为假，但是是有区别的。</p>

<h4><code>or</code></h4>

<p><code>a or b</code>，如果 <code>a</code> 为假，返回 <code>b</code>，如果 <code>a</code> 为真， 返回 <code>a</code>。与 <code>and</code> 相反。</p>

<p>+++</p>

<p><strong>提示：</strong> 当逻辑操作符用于得出一个 <code>boolean</code> 型结果时，不需要考虑逻辑运算后返回谁的问题，因为逻辑操作符的操作结果符合原本的逻辑含义。</p>

<p>举例</p>

<pre><code>if (not (a &gt; min and a &lt; max)) then  -- 如果 a 不在范围内，则报错
    error() 
end
</code></pre>

<p>+++</p>

<h4>其他</h4>

<p><code>and</code> 与 <code>or</code> 遵循短路原则，第二个操作数仅在需要的时候会进行求值操作。</p>

<p>例子</p>

<pre><code><br>a = 5
x = a or jjjj() -- 虽然后面的函数并没有定义，但是由于不会执行，因此不会报错。


print(a)        --&gt;5
print(x)        --&gt;5
</code></pre>

<p>通过上面这个例子，我们应当对于逻辑操作有所警觉，因为这可能会引入一些未能及时预料到的错误。</p>

<h3>    2.5.4 连接符</h3>

<p><code>..</code><br>
连接两个字符串（或者数字）成为新的字符串。对于其他类型，调用元方法 <code>concat</code>。</p>

<h3>    2.5.5 取长度操作符</h3>

<p><code>#</code></p>

<p>对于字符串，长度为字符串的字符个数。</p>

<p>对于表，通过寻找满足t[n] 不是 nil 而 t[n+1] 为 nil 的下标 n 作为表的长度。</p>

<p>~~对于其他类型呢？~~</p>

<h4>例子</h4>

<pre><code>-- 字符串取长
print(#"abc\0")                         --&gt; 4
-- 表取长
print(#{[1]=1,[2]=2,[3]=3,x=5,y=6})     --&gt; 3
print(#{[1]=1,[2]=nil,[3]=3,x=5,y=6})   --&gt; 1
</code></pre>

<h3>    2.5.6 优先级</h3>

<p>由低到高：</p>

<pre><code>or
and
 &lt;     &gt;     &lt;=    &gt;=    ~=    ==
 ..
 +     -
 *     /     %
 not   #     - (unary)
 ^
</code></pre>

<p><strong>幂运算&gt;单目运算&gt;四则运算&gt;连接符&gt;比较操作符&gt;and&gt;or</strong></p>

<h3>    2.5.7 Table 构造</h3>

<p>Table 构造的 BNF 定义</p>

<pre><code>tableconstructor ::= `{´ [fieldlist] `}´
fieldlist ::= field {fieldsep field} [fieldsep]
field ::= `[´ exp `]´ `=´ exp | Name `=´ exp | exp
fieldsep ::= `,´ | `;´
</code></pre>

<p>举例：</p>

<pre><code>a = {}
b = {["price"] = 5; cost = 4; 2+5}
c = { [1] = 2+5, [2] = 2, 8, price = "abc", ["cost"] = 4} -- b 和 c 构造的表是等价的


print(b["price"])   --&gt; 5
print(b.cost)       --&gt; 4
print(b[1])         --&gt; 7       -- 未给出键值的，按序分配下标，下标从 1 开始

print(c["price"])   --&gt; abc
print(c.cost)       --&gt; 4
print(c[1])         --&gt; 8       
print(c[2])         --&gt; 2       
</code></pre>

<p><strong>注意：</strong></p>

<ul>
<li>未给出键值的，按序分配下标，下标从 1 开始</li>
<li>如果表中有相同的键，那么以靠后的那个值作为键对应的值</li>
</ul>
<p>上面这两条的存在使得上面的例子中 c<a rel="nofollow" href="http://blog.163.com/chenglian_999@126/blog/static/760002792009752402332/">1</a> 的输出值为 8。</p>

<p>+++</p>

<p>如果表中有相同的键，那么以靠后的那个值作为键对应的值。</p>

<pre><code>a = {[1] = 5,[1] = 6} -- 那么 a[1] = 6
</code></pre>

<p>+++</p>

<p>如果表的最后一个域是表达式形式，并且是一个函数，那么这个函数的所有返回值都会加入到表中。</p>

<pre><code>a = 1
function order()
    a = a + 1
    return 1,2,3,4
end

b = {order(); a; order(); }

c = {order(); a; (order());}

print(b[1])                     --&gt; 1       
print(b[2])                     --&gt; 2       -- 表中的值并不是一次把表达式都计算结束后再赋值的
print(b[3])                     --&gt; 1       
print(b[4])                     --&gt; 2       -- 表达式形式的多返回值函数

print(#b)                       --&gt; 6       -- 表的长度为 6                 
print(#c)                       --&gt; 3       -- 函数添加括号后表的长度为 3
</code></pre>

<h3>    2.5.8 函数定义</h3>

<p>函数是一个表达式，其值为 function 类型的对象。函数每次执行都会被实例化。</p>

<p>Lua 中实现一个函数可以有以下三种形式。</p>

<pre><code>f = function() [block] end
local f; f = function() [block] end
a.f = function() [block] end
</code></pre>

<p>Lua 提供语法糖分别处理这三种函数定义。</p>

<pre><code>function f() [block] end
local function f() [block] end
function a.f() [block] end
</code></pre>

<p>+++</p>

<p>上面 <code>local</code> 函数的定义之所以不是 <code>local f = function() [block] end</code>，是为了避免如下错误：</p>

<pre><code>local f = function()
    print("local fun")
    if i==0 then 
        f()             -- 编译错误:attempt to call global 'f' (a nil value)
        i = i + 1
    end
end
</code></pre>

<h4>函数的参数</h4>

<p>形参会通过实参来初始化为局部变量。</p>

<p>参数列表的尾部添加 <code>...</code> 表示函数能接受不定长参数。如果尾部不添加，那么函数的参数列表长度是固定的。</p>

<pre><code>f(a,b)
g(a,b,...)
h(a,...,b)              -- 编译错误
</code></pre>

<pre><code>f(1)                    --&gt; a = 1, b = nil
f(1,2)                  --&gt; a = 1, b = 2
f(1,2,3)                --&gt; a = 1, b = 2

g(1,2)                  --&gt; a = 1, b = 2, (nothing)
g(1,2,3)                --&gt; a = 1, b = 2, (3)
g(1,f(4,5),3)           --&gt; a = 1, b = 4, (3)
g(1,f(4,5))             --&gt; a = 1, b = 4, (5)

</code></pre>

<p>+++</p>

<p>还有一种形参为self的函数的定义方式：</p>

<pre><code>a.f = function (self, params) [block] end
</code></pre>

<p>其语法糖形式为：</p>

<pre><code>function a:f(params) [block] end
</code></pre>

<p>使用举例：</p>

<pre><code>a = {name = "唐衣可俊"}
function a:f()
    print(self.name)
end
a:f()                       --&gt; 唐衣可俊   -- 如果这里使用 a.f()，那么 self.name 的地方会报错 attempt to index local 'self';此时应该写为 a.f(a)
</code></pre>

<p><code>:</code> 的作用在于函数定义与调用的时候可以少写一个 <code>self</code> 参数。这种形式是对<code>方法</code>的模拟</p>

<h3>    2.5.9 函数调用</h3>

<p>Lua 中的函数调用的BNF语法如下：</p>

<pre><code>functioncall ::= prefixexp args
</code></pre>

<p>如果 prefixexp 的值的类型是 function， 那么这个函数就被用给出的参数调用。 否则 prefixexp 的元方法 "call" 就被调用， call 的第一个参数就是 prefixexp 的值，接下来的是 args 参数列表（参见 <a rel="nofollow">2.8 元表 | Metatable</a>）。</p>

<p>函数调用根据是否传入 <code>self</code> 参数分为 <code>.</code> 调用和 <code>:</code> 调用。<br>
函数调用根据传入参数的类型，可以分为<strong>参数列表调用、表调用、字符串调用</strong>。</p>

<p><strong>[待完善]</strong></p>

<h3>    2.5.10 函数闭包</h3>

<p><strong>如果一个函数访问了它的外部变量，那么它就是一个闭包。</strong></p>

<p>由于函数内部的变量均为局部变量，外界无法对其进行访问。这时如果外界想要改变局部变量的值，那么就可以使用闭包来实现这一目的。<br>
具体的实现过程大致是这样，函数内部有能够改变局部变量的子函数，函数将这个子函数返回，那么外界就可以通过使用这个子函数来操作局部变量了。</p>

<p><strong>例子：</strong>利用闭包来实现对局部变量进行改变</p>

<pre><code>-- 实现一个迭代器

function begin(i)
    local cnt = i

    return function ()      -- 这是一个匿名函数，实现了自增的功能；同时它也是一个闭包，因为访问了外部变量 cnt
        cnt = cnt + 1
        return cnt
    end
end


iterator = begin(2)     -- 设置迭代器的初值为 2 ，返回一个迭代器函数

print(iterator())           -- 执行迭代
print(iterator())

</code></pre>

<p><strong>提示：</strong> 关于闭包的更多说明可参考<a rel="nofollow" href="http://stackoverflow.com/questions/111102/how-do-javascript-closures-work">JavaScript 闭包是如何工作的?——StackOverflow</a></p>

<h2>  2.6 可视规则</h2>

<p>即变量的作用域，见 <a rel="nofollow">2.3 变量</a> 部分。</p>

<h2>   2.7 错误处理</h2>

<p>[待补充]</p>

<h2>   2.8 元表 | Metatable</h2>

<p>我们可以使用操作符对 Lua 的值进行运算，例如对数值类型的值进行加减乘除的运算操作以及对字符串的连接、取长操作等（在 <a rel="nofollow">2.5 表达式</a> 这一节中介绍了许多类似的运算）。元表正是定义这些操作行为的地方。</p>

<p>元表本质上是一个普通 Lua 表。元表中的键用来指定操作，称为“事件名”；元表中键所关联的值称为“元方法”，定义操作的行为。</p>

<h3> 2.8.1 事件名与元方法</h3>

<p>仅表（table）类型值对应的元表可由用户自行定义。其他类型的值所对应的元表仅能通过 Debug 库进行修改。</p>

<p>元表中的事件名均以两条下划线 <code>__</code> 作为前缀，元表支持的事件名有如下几个：</p>

<pre><code>__index     -- 'table[key]'，取下标操作，用于访问表中的域
__newindex  -- 'table[key] = value'，赋值操作，增改表中的域
__call      -- 'func(args)'，函数调用，参见 [2.5.9 函数调用](#2-5-9)

-- 数学运算操作符
__add       -- '+'
__sub       -- '-'
__mul       -- '*'
__div       -- '/'
__mod       -- '%'
__pow       -- '^'
__unm       -- '-'

-- 连接操作符
__concat    -- '..'

-- 取长操作符
__len       -- '#'

-- 比较操作符
__eq        -- '=='
__lt        -- '&lt;'      -- a &gt; b 等价于 b &lt; a
__le        -- '&lt;='     -- a &gt;= b 等价于 b &lt;= a 
</code></pre>

<p>还有一些其他的事件，例如 <code>__tostring</code> 和 <code>__gc</code> 等。</p>

<p>下面进行详细介绍。</p>

<h3> 2.8.2 元表与值</h3>

<p>每个值都可以拥有一个元表。对 userdata 和 table 类型而言，其每个值都可以拥有独立的元表，也可以几个值共享一个元表。对于其他类型，一个类型的值共享一个元表。例如所有数值类型的值会共享一个元表。除了字符串类型，其他类型的值默认是没有元表的。</p>

<p>使用 getmetatable 函数可以获取任意值的元表。<a rel="nofollow">getmetatable (object)</a><br>
使用 setmetatable 函数可以设置<strong>表类型</strong>值的元表。<a rel="nofollow">setmetatable (table, metatable)</a></p>

<h4>例子</h4>

<p>只有字符串类型的值默认拥有元表：</p>

<pre><code>a = "5"
b = 5
c = {5}
print(getmetatable(a))      --&gt; table: 0x7fe221e06890
print(getmetatable(b))      --&gt; nil
print(getmetatable(c))      --&gt; nil
</code></pre>

<h3> 2.8.3 事件的具体介绍</h3>

<p>事先提醒 Lua 使用 <code>raw</code> 前缀的函数来操作元方法，避免元方法的循环调用。</p>

<p>例如 Lua 获取对象 obj 中元方法的过程如下：</p>

<pre><code>rawget(getmetatable(obj)or{}, "__"..event_name)
</code></pre>

<h4>元方法 index</h4>

<p>index 是元表中最常用的事件,用于值的下标访问 -- <code>table[key]</code>。</p>

<p>事件 index 的值可以是函数也可以是表。当使用表进行赋值时，元方法可能引发另一次元方法的调用，具体可见下面伪码介绍。<br>
当用户通过键值来访问表时，如果没有找到键对应的值，则会调用对应元表中的此事件。如果 index 使用表进行赋值，则在该表中查找传入键的对应值；如果 index 使用函数进行赋值，则调用该函数，并传入表和键。</p>

<p>Lua 对取下标操作的处理过程用伪码表示如下：</p>

<pre><code>function gettable_event (table, key)
    -- h 代表元表中 index 的值
    local h     
    if type(table) == "table" then

        -- 访问成功
        local v = rawget(table, key)
        if v ~= nil then return v end

        -- 访问不成功则尝试调用元表的 index
        h = metatable(table).__index

        -- 元表不存在返回 nil
        if h == nil then return nil end
    else

        -- 不是对表进行访问则直接尝试元表
        h = metatable(table).__index

        -- 无法处理导致出错
        if h == nil then
            error(···);
        end
    end

    -- 根据 index 的值类型处理
    if type(h) == "function" then
        return h(table, key)            -- 调用处理器
    else 
        return h[key]                   -- 或是重复上述操作
    end
end
</code></pre>

<p><strong>例子：</strong></p>

<p>使用表赋值：</p>

<pre><code>t = {[1] = "cat",[2] = "dog"}
print(t[3])             --&gt; nil
setmetatable(t, {__index = {[3] = "pig", [4] = "cow", [5] = "duck"}})
print(t[3])             --&gt; pig
</code></pre>

<p>使用函数赋值：</p>

<pre><code>t = {[1] = "cat",[2] = "dog"}
print(t[3])             --&gt; nil
setmetatable(t, {__index = function (table,key)
    key = key % 2 + 1
    return table[key]
end})
print(t[3])             --&gt; dog
</code></pre>

<h4>元方法 newindex</h4>

<p>newindex 用于赋值操作 -- <code>talbe[key] = value</code>。</p>

<p>事件 newindex 的值可以是函数也可以是表。当使用表进行赋值时，元方法可能引发另一次元方法的调用，具体可见下面伪码介绍。</p>

<p>当操作类型不是表或者表中尚不存在传入的键时，会调用 newindex 的元方法。如果 newindex 关联的是一个函数类型以外的值，则再次对该值进行赋值操作。反之，直接调用函数。</p>

<p>~~不是太懂：一旦有了 "newindex" 元方法， Lua 就不再做最初的赋值操作。 （如果有必要，在元方法内部可以调用 rawset 来做赋值。）~~</p>

<p>Lua 进行赋值操作时的伪码如下：</p>

<pre><code>function settable_event (table, key, value)
    local h
    if type(table) == "table" then

        -- 修改表中的 key 对应的 value
        local v = rawget(table, key)
        if v ~= nil then rawset(table, key, value); return end

        -- 
        h = metatable(table).__newindex

        -- 不存在元表，则直接添加一个域
        if h == nil then rawset(table, key, value); return end
    else
        h = metatable(table).__newindex
        if h == nil then
            error(···);
        end
    end

    if type(h) == "function" then
        return h(table, key,value)    -- 调用处理器
    else 


        h[key] = value             -- 或是重复上述操作
    end
end
</code></pre>

<p><strong>例子：</strong></p>

<p>元方法为表类型：</p>

<pre><code>t = {}
mt = {}

setmetatable(t, {__newindex = mt})
t.a = 5
print(t.a)      --&gt; nil
print(mt.a)     --&gt; 5
</code></pre>

<p>通过两次调用 newindex 元方法将新的域添加到了表 mt 。</p>

<p>+++</p>

<p>元方法为函数：</p>

<pre><code>-- 对不同类型的 key 使用不同的赋值方式
t = {}
setmetatable(t, {__newindex = function (table,key,value)
    if type(key) == "number" then
        rawset(table, key, value*value)
    else
        rawset(table, key, value)
    end
end})
t.name = "product"
t[1] = 5
print(t.name)       --&gt; product
print(t[1])         --&gt; 25
</code></pre>

<h4>元方法 call</h4>

<p>call 事件用于函数调用 -- <code>function(args)</code>。</p>

<p>Lua 进行函数调用操作时的伪代码：</p>

<pre><code>function function_event (func, ...)

  if type(func) == "function" then
      return func(...)   -- 原生的调用
  else
      -- 如果不是函数类型，则使用 call 元方法进行函数调用
      local h = metatable(func).__call

      if h then
        return h(func, ...)
      else
        error(···)
      end
  end
end
</code></pre>

<p><strong>例子：</strong></p>

<p>由于用户只能为表类型的值绑定自定义元表，因此，我们可以对表进行函数调用，而不能把其他类型的值当函数使用。</p>

<pre><code>-- 把数据记录到表中，并返回数据处理结果
t = {}

setmetatable(t, {__call = function (t,a,b,factor)
  t.a = 1;t.b = 2;t.factor = factor
  return (a + b)*factor
end})

print(t(1,2,0.1))       --&gt; 0.3

print(t.a)              --&gt; 1
print(t.b)              --&gt; 2
print(t.factor)         --&gt; 0.1
</code></pre>

<h4>运算操作符相关元方法</h4>

<p>运算操作符相关元方法自然是用来定义运算的。</p>

<p>以 add 为例，Lua 在实现 add 操作时的伪码如下：</p>

<pre><code>function add_event (op1, op2)
  -- 参数可转化为数字时，tonumber 返回数字，否则返回 nil
  local o1, o2 = tonumber(op1), tonumber(op2)
  if o1 and o2 then  -- 两个操作数都是数字？
    return o1 + o2   -- 这里的 '+' 是原生的 'add'
  else  -- 至少一个操作数不是数字时
    local h = getbinhandler(op1, op2, "__add") -- 该函数的介绍在下面
    if h then
      -- 以两个操作数来调用处理器
      return h(op1, op2)
    else  -- 没有处理器：缺省行为
      error(···)
    end
  end
end
</code></pre>

<p>代码中的 getbinhandler 函数定义了 Lua 怎样选择一个处理器来作二元操作。 在该函数中，首先，Lua 尝试第一个操作数。如果这个操作数所属类型没有定义这个操作的处理器，然后 Lua 会尝试第二个操作数。</p>

<pre><code> function getbinhandler (op1, op2, event)
   return metatable(op1)[event] or metatable(op2)[event]
 end
</code></pre>

<p>+++</p>

<p>对于一元操作符，例如取负，Lua 在实现 unm 操作时的伪码：</p>

<pre><code>function unm_event (op)
  local o = tonumber(op)
  if o then  -- 操作数是数字？
    return -o  -- 这里的 '-' 是一个原生的 'unm'
  else  -- 操作数不是数字。
    -- 尝试从操作数中得到处理器
    local h = metatable(op).__unm
    if h then
      -- 以操作数为参数调用处理器
      return h(op)
    else  -- 没有处理器：缺省行为
      error(···)
    end
  end
end
</code></pre>

<p><strong>例子：</strong></p>

<p>加法的例子：</p>

<pre><code>t = {}
setmetatable(t, {__add = function (a,b)
  if type(a) == "number" then
      return b.num + a
  elseif type(b) == "number" then
      return a.num + b
  else
      return a.num + b.num
  end
end})

t.num = 5

print(t + 3)  --&gt; 8
</code></pre>

<p>取负的例子：</p>

<pre><code>t = {}
setmetatable(t, {__unm = function (a)
  return -a.num
end})

t.num = 5

print(-t)  --&gt; -5
</code></pre>

<h4>其他事件的元方法</h4>

<p>对于连接操作，当操作数中存在数值或字符串以外的类型时调用该元方法。</p>

<p>对于取长操作，如果操作数不是字符串类型，也不是表类型，则尝试使用元方法（这导致自定义的取长基本没有，在之后的版本中似乎做了改进）。</p>

<p>对于三种比较类操作，均需要满足两个操作数为同类型，且关联同一个元表时才能使用元方法。</p>

<p>对于 eq （等于）比较操作，如果操作数所属类型没有原生的等于比较，则调用元方法。</p>

<p>对于 lt （小于）与 le （小于等于）两种比较操作，如果两个操作数同为数值或者同为字符串，则直接进行比较，否则使用元方法。</p>

<p>对于 le 操作，如果元方法 "le" 没有提供，Lua 就尝试 "lt"，它假定 a &lt;= b 等价于 not (b &lt; a) 。</p>

<p>对于 tostring 操作，元方法定义了值的字符串表示方式。</p>

<p><strong>例子：</strong></p>

<p>取长操作：</p>

<pre><code>t = {1,2,3,"one","two","three"}
setmetatable(t, {__len = function (t)
  local cnt = 0
  for k,v in pairs(t) do
    if type(v) == "number" then 
      cnt = cnt + 1
      print(k,v)
    end
  end
  return cnt
end})

-- 结果是 6 而不是预期中的 3
print(#t)   --&gt; 6 
</code></pre>

<p>等于比较操作：</p>

<pre><code>t = {name="number",1,2,3}
t2 = {name = "number",4,5,6}
mt = {__eq = function (a,b)
    return a.name == b.name
end}
setmetatable(t,mt)              -- 必须要关联同一个元表才能比较
setmetatable(t2,mt)

print(t==t2)   --&gt; true
</code></pre>

<p>tostring 操作：</p>

<pre><code>t = {num = "a table"}
print(t)              --&gt; table: 0x7f8e83c0a820

mt = {__tostring = function(t)
  return t.num
end}
setmetatable(t, mt)

print(tostring(t))    --&gt; a table
print(t)              --&gt; a table
</code></pre>

<h2>   2.9 环境表</h2>

<p>类型 <code>thread</code>、<code>function</code> 和 <code>userdata</code> 的对象除了能与元表建立关联外，还能关联一个环境表。</p>

<p>关联在线程上的环境表称为全局环境。<br>
全局环境作为子线程及子函数的默认环境。<br>
全局环境能够直接被 C 调用。</p>

<p>关联在 Lua 函数上的环境表接管函数对全局变量的所有访问。并且作为子函数的默认环境。</p>

<p>关联在 C 函数上的环境能直接被 C 调用。</p>

<p>关联在 <code>userdata</code> 上的环境没有实际的用途，只是为了方便程序员把一个表关联到 <code>userdata</code> 上。</p>

<h2>   2.10 垃圾回收</h2>

<h3>  2.10.1 垃圾收集的元方法</h3>

<p>[待补充]</p>

<h3>  2.10.2 弱表</h3>

<p>弱表是包含弱引用的表。</p>

<p>弱表的弱引用方式有三种。<strong>键弱引用，值弱引用，键和值均弱引用</strong>。</p>

<p>可以通过元表中的 <code>__mode</code> 域来设置一个表是否有弱引用，以及弱引用的方式。</p>

<pre><code>a = {}
b = { __mode = "k"}  -- 引号中添加 k 表示 key 弱引用，v 表示 value 弱引用， kv 表示均弱引用。
setmetable(a,b)     -- b 是 a 的元表，绑定后就不能在更改 __mode 的值。
</code></pre>

<p>垃圾回收机制会把弱引用的部分回收。但是不论是哪种弱引用，回收机制都会把整个键值对从弱表中移除。</p>

<h1> 3 程序接口 （API）</h1>

<p>这部分描述 Lua 的 C API，即用来与 Lua 进行通信的 C 函数，所有的函数和常量都定义在 <code>lua.h</code> 头文件里面。</p>

<p>有一部分 C 函数是用宏来实现的。~~<strong>为什么？：</strong>由于所有的宏只会使用他们的参数一次（除了第一个参数，即 <strong>Lua 状态机</strong>），所以不必担心宏展开带来的副作用。~~</p>

<p>默认情况下 Lua 在进行函数调用时不会检查函数的有效性和坚固性，如果想要进行检查，则使用 <code>luaconf.h</code> 中的 <code>luai_apicheck()</code> 函数开启。</p>

<h2> 3.1 堆栈</h2>

<p>Lua 调用 C API 时使用一个虚拟栈来传递参数，栈中的所有元素都是 Lua 的类型（例如 <code>boolean</code>，<code>table</code>，<code>nil</code>等）。</p>

<p>Lua 调用 C 函数的时候都会新建一个虚拟栈，而不是使用旧栈或者其他的栈。同时在 C 函数中，对 Lua API 调用时，只能使用当前调用所对应栈中的元素，其他栈的元素是无法访问的。<br>
虚拟栈中包含 C 函数所需的所有参数，函数的返回值也都放在该栈中。</p>

<p>这里所谓的栈概念并不是严格意义上的栈，可以通过下标对栈中的元素进行访问。1表示栈底，-1表示栈顶，又例如 3 表示从栈底开始的第三个元素。</p>

<h2> 3.2 堆栈尺寸</h2>

<p>由于 Lua 的 C API 默认不做有效性和坚固性（鲁棒性）检测，因此开发人员有责任保证坚固性。特别要注意的是，不能让堆栈溢出。Lua 只保证栈大小会大于 <code>LUA_MINSTACK</code>（一般是 20）。开发人员可以使用 <code>lua_checkstack</code> 函数来手动设置栈的大小。</p>

<h2> 3.3 伪索引</h2>

<p>除了用索引访问函数堆栈的 Lua 元素，C 代码还可以使用<strong>伪索引</strong>来访问堆栈以外的 Lua 元素，例如线程的环境、注册表、函数的环境 以及 C函数的 <code>upvalue</code>（上值）。可以通过特别声明来禁用伪索引。</p>

<p>线程的环境放在伪索引 <code>LUA_GLOBALSINDEX</code> 处，函数的环境放在伪索引 <code>LUA_ENVIRONINDEX</code> 处。</p>

<p>访问环境的方式跟访问表的方式是一致的，例如要访问全局变量的值，可以使用：</p>

<pre><code>lua_getfield(L,LUA_GLOBALSINDEX,varname)
</code></pre>

<h2> 3.4 C 闭包</h2>

<p>当我们把创建出来的函数和一些值关联在一起，就得到了一个闭包。那些关联起来的值称为 <code>upvalue</code> （上值）。</p>

<p>函数的上值都放在特定的伪索引处，可以通过 <code>lua_upvalueindex</code> 获取上值的伪索引。例如 <code>lua_upvalueindex(3)</code> 表示获取第三个关联值（按照关联顺序排列）对应的伪索引。</p>

<h2> 3.5 注册表</h2>

<p>Lua 提供了一个注册表，C 代码可以用来存放想要存放的 Lua 值。注册表用伪索引 <code>LUA_REGISTRYINDEX</code> 定位。</p>

<p>为了避免命名冲突，一般采用包含库名的字符串作为键名。~~<strong>什么东西？：</strong>或者可以取你自己 C 代码 中的一个地址，以 light userdata 的形式做键。~~</p>

<p>注册表中的整数键有特定用途（用于实现补充库的引用系统），不建议用于其他用途。</p>

<h2> 3.6 C 中的错误处理</h2>

<p>[待补充]</p>

<h2> 3.7 函数和类型</h2>

<p>本节介绍 C API 中的函数和类型。</p>

<p>余下部分见 <a rel="nofollow" href="http://segmentfault.com/a/1190000002723546">Lua 学习笔记（下）</a></p>

<hr>
<h1>参考链接</h1>

<p><a rel="nofollow" href="http://blog.163.com/chenglian_999@126/blog/static/760002792009752402332/">BNF范式简介 </a>（简要介绍 BNF）<br><a rel="nofollow" href="http://www.jellythink.com/archives/882">Lua入门系列-果冻想</a>（对Lua进行了较为全面的介绍）<br><a rel="nofollow" href="https://docs.google.com/presentation/d/1gBGwwnmhkI5i45C5k4OmKSnAfBeqe_-nBFudUafgqHg/edit#slide=id.i52">Lua快速入门</a>（介绍 Lua 中最为重要的几个概念，为 C/C++ 程序员准备）<br><a rel="nofollow" href="http://manual.luaer.cn/">Lua 5.1 中文手册</a>（全面的 Lua5.1 中文手册）<br><a rel="nofollow" href="http://cloudwu.github.io/lua53doc/contents.html">Lua 5.3 中文手册</a>（云风花了6天写的，天哪，我看都要看6天的节奏呀）<br><a rel="nofollow" href="http://www.cnblogs.com/stephen-liu74/archive/2012/06/20/2413799.html">Lua迭代器和泛型for</a>（介绍 Lua 迭代器的详细原理以及使用）<br><a rel="nofollow" href="http://stackoverflow.com/questions/111102/how-do-javascript-closures-work">How do JavaScript closures work?——StackOverflow</a>（详细介绍了 Javascript 中闭包的概念）<br><a rel="nofollow" href="http://www.cnblogs.com/whiteyun/archive/2009/09/02/1541043.html">Lua模式匹配</a>（参考了此文中对 <code>%b</code> 的使用）<br><a rel="nofollow" href="http://w3.impa.br/~diego/software/luasocket/home.html">LuaSocket</a>（LuaSocket 官方手册）<br><a rel="nofollow" href="http://blog.sina.com.cn/s/blog_6a99c8bc0101krl8.html">Lua loadfile的用法, 与其他函数的比较</a>（loadfile的介绍部分引用了此文）<br><a rel="nofollow" href="http://segmentfault.com/a/1190000000410274">Lua 的元表</a>（对元表的描述比较有条理，通俗易懂，本文元表部分参考了此文）<br><a rel="nofollow" href="http://www.cnblogs.com/sifenkesi/p/3843348.html">设置函数环境——setfenv</a>（解释了如何方便地设置函数的环境，以及为什么要那样设置）<br><a rel="nofollow" href="http://blog.csdn.net/icyday/article/details/8116818">lua5.1中的setfenv使用</a>（介绍了该环境的设置在实际中的一个应用）</p>

2015年五月2日晚上 9:00:36
PHP数组操作详解
<h2>概述</h2>

<p>要访问一个变量的内容，可以直接使用其名称。如果该变量是一个数组，可以使用变量名称和关键字或索引的组合来访问其内容。</p>

<p>像其他变量一样，使用运算符<code>=</code>可以改变数组元素的内容。数组单元可以通过 <code>array[key]</code> 语法来访问。</p>

<p><img src="/img/bVlACw" alt="图片描述"></p>

<h2>数组的基本操作</h2>

<h3>php定义数组：</h3>

<pre><code>&lt;?php  
    $array = array();  
    $array["key"] = "values";  
?&gt; 
</code></pre>

<p>在<code>PHP</code>中声明数组的方式主要有两种：</p>

<p>1.用<code>array()</code>函数声明数组，<br>
2.直接为数组元素赋值。</p>

<pre><code>&lt;?php
    //array数组
    $users = array('phone','computer','dos','linux');
    echo $users;//只会打印出数据类型Array
    print_r($users);//Array ( [0] =&gt; phone [1] =&gt; computer [2] =&gt; dos [3] =&gt; linux )

    $numbers = range(1,5);//创建一个包含指定范围的数组
    print_r($numbers);//Array ( [0] =&gt; 1 [1] =&gt; 2 [2] =&gt; 3 [3] =&gt; 4 [4] =&gt; 5 )
    print_r(true);//1
    var_dump(false);//bool(false)

//print_r可以把字符串和数字简单地打印出来，数组会以Array开头并已键值形式表示，print_r输出布尔值和null的结果没有意义，因此用var_dump更合适

//通过循环来显示数组里所有的值
    for($i = 0 ;$i &lt; 5;$i++){
        echo $users[$i];
        echo '&lt;br/&gt;';
    }

//通过count/sizeof统计数组中单元数目或对象中的属性个数

    for($i = 0; $i &lt; count($users);$i++){
        echo $users[$i];
        echo '&lt;br/&gt;';
    }
//还可以通过foreach循环来遍历数组，这种好处在于不需要考虑key
    foreach($users as $value){
        echo $value.'&lt;br/&gt;';//点号为字符串连接符号
    }
//foreach循环遍历 $key =&gt; $value；$key和$value是变量名，可以自行设置
    foreach($users as $key =&gt; $value){
        echo $key.'&lt;br/&gt;';//输出键
    }
?&gt;
</code></pre>

<h3>创建自定义键的数组</h3>

<pre><code>&lt;?php

    //创建自定义键的数组
    $ceo = array('apple'=&gt;'jobs','microsoft'=&gt;'Nadella','Larry Page','Eric');
    //如果不去声明元素的key,它会从零开始
    print_r($ceo);//Array ( [apple] =&gt; jobs [microsoft] =&gt; Nadella [0] =&gt; Larry Page [1] =&gt; Eric )

    echo $ceo['apple'];//jobs

     //php5.4起的用法
    $array = [
        "foo" =&gt; "bar",
        "bar" =&gt; "foo",
    ];

    print_r($array);//Array ( [foo] =&gt; bar [bar] =&gt; foo ) 

?&gt;    
</code></pre>

<p>从<code>php5.4</code> 起可以使用短数组定义语法，用 <code>[]</code> 替代 <code>array()</code>。有点类似于<code>javascript</code>中数组的定义。</p>

<h3>each()的使用</h3>

<pre><code>&lt;?php
    //通过为数组元素赋值来创建数组
    $ages['trigkit4'] = 22;
    echo $ages.'&lt;br/&gt;';//Array
    //因为相关数组的索引不是数字，所以无法通过for循环来进行遍历操作，只能通过foreach循环或list()和each()结构

    //each的使用
    //each返回数组中当前的键/值对并将数组指针向前移动一步
    $users = array('trigkit4'=&gt;22,'mike'=&gt;20,'john'=&gt;30);
    //print_r(each($users));//Array ( [1] =&gt; 22 [value] =&gt; 22 [0] =&gt; trigkit4 [key] =&gt; trigkit4 )

   //相当于：$a = array([0]=&gt;trigkit4,[1]=&gt;22,[value]=&gt;22,[key]=&gt;trigkit4);
    $a = each($users);//each把原来的数组的第一个元素拿出来包装成新数组后赋值给$a
    echo $a[0];//trigkit4

    //!!表示将真实存在的数据转换成布尔值
    echo !!each($users);//1

?&gt;  
</code></pre>

<p><code>each</code>的指针指向第一个键值对，并返回第一个数组元素，获取其键值对，并包装成新数组</p>

<h3>list()的使用</h3>

<p><code>list</code>用来把数组用的值赋给一些变量，看下面例子：</p>

<pre><code>&lt;?php

    $a = ['2','abc','def'];
    list($var1,$var2) = $a;
    echo $var1.'&lt;br/&gt;';//2
    echo $var2;//abc

    $a = ['name'=&gt;'trigkit4','age'=&gt;22,'0'=&gt;'boy'];
    //list只认识key为数字的索引
    list($var1,$var2) = $a;

    echo $var1;//boy

?&gt;
</code></pre>

<p>注：<code>list</code>只认识key为数字的索引</p>

<h2>数组元素的排序</h2>

<pre><code>反向排序:sort()、asort()和 ksort()都是正向排序,当然也有相对应的反向排序. 
实现反向:rsort()、arsort()和 krsort()。

array_unshift()函数将新元素添加到数组头,array_push()函数将每个新元素添加到数组 的末尾。
array_shift()删除数组头第一个元素,与其相反的函数是 array_pop(),删除并返回数组末 尾的一个元素。
array_rand()返回数组中的一个或多个键。

函数shuffle()将数组个元素进 行随机排序。
函数 array_reverse()给出一个原来数组的反向排序
</code></pre>

<h2>数组的各类API的使用</h2>

<pre><code>count()和 sizeof()统计数组下标的个数 
array_count_values()统计数组内下标值的个数

&lt;?php
    $numbers = array('100','2');
    sort($numbers,SORT_STRING);//按字符串排序，字符串只比较第一位大小
    print_r($numbers);//Array ( [0] =&gt; 100 [1] =&gt; 2 )

    $arr = array('trigkit4','banner','10');
    sort($arr,SORT_STRING);
    print_r($arr);//Array ( [0] =&gt; 10 [1] =&gt; banner [2] =&gt; trigkit4 )

    shuffle($arr);
    print_r($arr);//随机排序

    $array = array('a','b','c','d','0','1');
    array_reverse($array);
    print_r($array);//原数组的反向排序。 Array ( [0] =&gt; a [1] =&gt; b [2] =&gt; c [3] =&gt; d [4] =&gt; 0 [5] =&gt; 1 )


    //数组的拷贝
    $arr1  = array( '10' , 2);
    $arr2  =  &amp;$arr1 ;
    $arr2 [] =  4 ;  // $arr2 被改变了,$arr1仍然是array('10', 3)
    print_r($arr2);//Array ( [0] =&gt; 10 [1] =&gt; 2 [2] =&gt; 4 )

    //asort的使用
    $arr3  = &amp; $arr1 ;//现在arr1和arr3是一样的
    $arr3 [] =  '3' ;
    asort($arr3);//对数组进行排序并保留原始关系
    print_r($arr3);// Array ( [1] =&gt; 2 [2] =&gt; 3 [0] =&gt; 10 )

    //ksort的使用
    $fruits = array('c'=&gt;'banana','a'=&gt;'apple','d'=&gt;'orange');
    ksort($fruits);
    print_r($fruits);//Array ( [a] =&gt; apple [c] =&gt; banana [d] =&gt; orange )

   //unshift的使用
    array_unshift($array,'z');//开头处添加一元素
    print_r($array);//Array ( [0] =&gt; z [1] =&gt; a [2] =&gt; b [3] =&gt; c [4] =&gt; d [5] =&gt; 0 [6] =&gt; 1 )  

    //current(pos)的使用
    echo current($array);//z;获取当前数组中的当前单元

    //next的使用
    echo next($array);//a;将数组中的内部指针向前移动一位

    //reset的使用
    echo reset($array);//z;将数组内部指针指向第一个单元

    //prev的使用
    echo next($array);//a;
    echo prev($array);//z;倒回一位

    //sizeof的使用
    echo sizeof($array);//7；统计数组元素的个数

    //array_count_values
    $num = array(10,20,30,10,20,1,0,10);//统计数组元素出现的次数
    print_r(array_count_values($num));//Array ( [10] =&gt; 3 [20] =&gt; 2 [30] =&gt; 1 [1] =&gt; 1 [0] =&gt; 1 ) 

?&gt;    
</code></pre>

<p><code>current()</code>：每个数组都有一个内部指针指向他的当前单元，初始指向插入到数组中的第一个元素</p>

<h2>for循环遍历</h2>

<pre><code>&lt;?php
    $value = range(0,120,10);
    for($i=0;$i&lt;count($value);$i++){
        print_r($value[$i].' ');//0 10 20 30 40 50 60 70 80 90 100 110 120 
    }
?&gt;
</code></pre>

<h2>数组的实例</h2>

<h3>array_pad函数的使用</h3>

<pre><code>&lt;?php
    //array_pad函数，数组数组首尾选择性追加
    $num = array(1=&gt;10,2=&gt;20,3=&gt;30);
    $num = array_pad($num,4,40);
    print_r($num);//Array ( [0] =&gt; 10 [1] =&gt; 20 [2] =&gt; 30 [3] =&gt; 40 )

    $num = array_pad($num,-5,50);//array_pad(array,size,value)
    print_r($num);//Array ( [0] =&gt; 50 [1] =&gt; 10 [2] =&gt; 20 [3] =&gt; 30 [4] =&gt; 40 ) 
?&gt;
</code></pre>

<p><code>size</code>:指定的长度。整数则填补到右侧，负数则填补到左侧。</p>

<h3>unset()的使用</h3>

<pre><code> &lt;?php
    //unset()的使用
    $num = array_fill(0,5,rand(1,10));//rand(min,max)
    print_r($num);//Array ( [0] =&gt; 8 [1] =&gt; 8 [2] =&gt; 8 [3] =&gt; 8 [4] =&gt; 8 ) 
    echo '&lt;br/&gt;';

    unset($num[3]);
    print_r($num);//Array ( [0] =&gt; 8 [1] =&gt; 8 [2] =&gt; 8 [4] =&gt; 8 ) 
?&gt;
</code></pre>

<h3>array_fill()的使用</h3>

<pre><code>&lt;?php
    //array_fill()的使用
    $num = range('a','e');
    $arrayFilled = array_fill(1,2,$num);//array_fill(start,number,value)
    echo '&lt;pre&gt;';

    print_r($arrayFilled);

?&gt;
</code></pre>

<h3>array_combine()的使用</h3>

<pre><code>&lt;?PHP
    $number = array(1,2,3,4,5);
    $array = array("I","Am","A","PHP","er");
    $newArray = array_combine($number,$array);
    print_r($newArray);//Array ( [1] =&gt; I [2] =&gt; Am [3] =&gt; A [4] =&gt; PHP [5] =&gt; er ) 
?&gt; 
</code></pre>

<h3>array_splice()删除数组成员</h3>

<pre><code>&lt;?php
    $color = array("red", "green", "blue", "yellow");
    count ($color); //得到4
    array_splice($color,1,1); //删除第二个元素
    print_r(count ($color)); //3
    echo $color[2]; //yellow
    echo $color[1]; //blue
?&gt;  
</code></pre>

<h3>array_unique删除数组中的重复值</h3>

<pre><code>&lt;?php
    $color=array("red", "green", "blue", "yellow","blue","green");
    $result = array_unique($color);
    print_r($result);//Array ( [0] =&gt; red [1] =&gt; green [2] =&gt; blue [3] =&gt; yellow ) 
?&gt; 
</code></pre>

<h3>array_flip()交换数组的键值和值</h3>

<pre><code>&lt;?PHP
    $array = array("red","blue","red","Black");
    print_r($array);
    echo "&lt;br /&gt;";
    $array = array_flip($array);//
    print_r($array);//Array ( [red] =&gt; 2 [blue] =&gt; 1 [Black] =&gt; 3 ) 
?&gt; 
</code></pre>

<h3>array_search()搜索数值</h3>

<pre><code>&lt;meta charset="utf-8"&gt;
&lt;?php
   $array = array("red","blue","red","Black");
   $result=array_search("red",$array)//array_search(value,array,strict)
    if(($result === NULL)){
        echo "不存在数值red";
    }else{
        echo "存在数值 $result";//存在数值 0 
    }
?&gt; 
</code></pre>

2015年五月2日晚上 8:56:47
Linux 文件和文件夹的操作权限
<p>由于 linux 是多用户操作系统，所以基于安全的考虑，需要具备保障个人隐私和系统安全的机制。因此在使用 linux 系统的时候，经常会出现权限的问题(比如: 删除文件、安装软件、运行应用等等)，期初遇到这些问题的时候，大部分都使用<code>sudo</code>或者是<code>sudo chmod 777 file</code>(后面会讲解这个命令)来解决的。虽然这种方式可以解决问题，但是这样是不安全的，特别是在服务器上操作的时候，因为不是所有的文件和文件夹都可以被其它用户操作的，不是所有的用户都有<code>root</code>权限的，不是所有的应用都可以用<code>root</code>用户启动的。那么我们要如何正确的处理这些权限问题呢？那就让我们来学习一下 linux 权限相关的知识。</p>



<h3>用户的权限</h3>

<p>要确定一个用户对某个文件或文件夹是否具有相应的操作权限，先要明确该用户与文件或文件夹之间的关系。在 linux 系统中，定义了如下三种关系：</p>

<ul>
<li>
<strong>文件或文件夹的所有者 (owner)</strong>：文件或文件夹的拥有者，开始创建文件或文件夹时为创建者。</li>
<li>
<strong>组 (group)</strong>：文件或文件夹所属的组, 开始创建文件或文件夹时为创建者的所属的组。</li>
<li>
<strong>其他人 (other)</strong>：除了文件或文件夹的所有者和文件或文件夹所属的组的其他成员，剩下的 linux 的用户。</li>
</ul>
<p>因为在 linux 下的文件和文件夹都有<code>读取(r)</code>、<code>写入(w)</code>、<code>执行(x)</code>的操作，所以上面描述的每种关系的用户分别都可以赋予这些操作权限。操作权限介绍:</p>

<table>
<thead><tr>
<th>权限</th>
  <th>简写</th>
  <th>对普通文件的作用</th>
  <th>对文件夹的作用</th>
</tr></thead>
<tbody>
<tr>
<td>读取</td>
  <td>r</td>
  <td>查看文件内容</td>
  <td>列出文件夹中的文件(ls)</td>
</tr>
<tr>
<td>写入</td>
  <td>w</td>
  <td>修改文件内容</td>
  <td>在文件夹中删除、添加或重命名文件(夹)</td>
</tr>
<tr>
<td>执行</td>
  <td>x</td>
  <td>文件可以作为程序执行</td>
  <td>cd 到文件夹</td>
</tr>
</tbody>
</table>
<h3>文件或文件夹和用户的三种关系的基础操作权限</h3>

<p>在 linux 使用<code>ls -la</code>命令可以查看文件夹内文件的属性，下面是我电脑上某个文件夹下文件的属性:</p>

<pre><code>bash</code><code>$ ls -la
drwxr-xr-x 14 root root     4096 Apr  3 18:47 .
drwxr-xr-x 23 root root     4096 Mar  2 05:48 ..
drwxr-xr-x  2 root root     4096 Apr  3 07:44 backups
drwxr-xr-x 17 root root     4096 Jul 22  2014 cache
drwxr-xr-x  2 root root     4096 Mar  2 04:26 docker-registry
lrwxrwxrwx  1 root root        9 Feb 25 13:31 lock -&gt; /run/lock
drwxrwxr-x 15 root syslog   4096 Apr  3 07:44 log
-rw-r--r--  1 root root        0 Apr  3 18:47 test
</code></pre>

<ul>
<li><p>上面的有九列数据，第一列数据表示和文件或文件夹相应关系用户的操作权限，第二列表示文件夹内文件和文件夹的总数量(包括文件夹本身)，第三列表示文件夹或文件的拥有者，第四列表示文件或文件夹的所属的组，第五列表示文件或文件夹的大小，第六、七、八列表示文件或文件夹最后被修改的时间，第九列文件或文件夹的名字。</p></li>
<li>
<p>接下主要分析第一列的数据，在上面的信息中倒数第二行<code>drwxrwxr-x</code>，从左到右第一个字母表示文件系统对象的类别，这里<code>d</code>表示为目录(文件夹)。其它文件系统对象:</p>

<blockquote>
  <p><code>-</code>(常规文件)、<code>d</code>(目录)、<code>l</code>(符号链接)、<code>c</code>(字符特殊设备)、<code>b</code>(模块特殊设备)、<code>p</code>(FIFO)、<code>s</code>(套接字)</p>
</blockquote>
</li>
<li><p><code>drwxrwxr-x</code>除出去第一个字母<code>d</code>后的<code>rwxrwxr-x</code>表示的是三种用户关系对文件或文件夹的操作权限。从左到右每三个一组，依次表示所有者权限、组权限、其他用户权限。每组的顺序均为<code>rwx</code>，如果用户有相应的操作权限就用相应的字母表示，如果不具有相应的操作权限就用<code>-</code>表示。比如: <code>rwxrwxr-x</code>表示文件或文件夹的所有者具有<code>rwx</code>(可读，可写，可执行)的操作权限，组用户也具有<code>rwx</code>(可读，可写，可执行)的权限，其他用户具有<code>r-x</code>(可读，可执行，没有可读)的操作权限。</p></li>
</ul>
<h3>特殊权限<code>SUID</code>、<code>SGID</code>、<code>Sticky</code>
</h3>

<p>在 linux 系统中还有三种与用户身份无关的三个文件权限属性。即<code>SUID、SGID和Sticky</code>。</p>

<ul>
<li>
<p><strong><em>SUID(Set User ID, 4):</em></strong></p>

<blockquote>
  <p>该属性只对有执行权限的文件有效，对目录无效。执行具有<code>SUID</code>权限的程序时，引发的进程的所有者是程序文件的所有者，而不是启动程序的用户（除非二者是同一个人）。比如，如果一个程序的所有者是<code>root</code>且具有<code>SUID</code>属性，一个普通用户执行此程序时，如同<code>root</code>执行此程序一样。（请注意该属性对<code>Shell</code>脚本程序无效）该属性为一些特殊程序（如lpr）的启动带来了方便。但有时也带来了安全隐患：比如一个具有<code>SUID</code>属性的程序如果在执行时运行了一个<code>shell</code>，那么用户可以籍此得到系统的最高权限。<code>SUID</code>可用<code>s</code>表示，如:</p>
</blockquote>

<pre><code>bash</code><code>$ ls -l /usr/bin/passwd
-rwsr-xr-x 1 root root 47032 Feb 16  2014 /usr/bin/passwd
</code></pre>
</li>
<li>
<p><strong><em>SGID(Set Group ID, 4):</em></strong></p>

<blockquote>
  <p>对于可执行文件，<code>SGID</code>与<code>SUID</code>类似，引发的进程的所有组是程序文件所属的组。对于目录，<code>SGID</code>属性会使目录中新建文件的所属组与该目录相同。<code>SGID</code>也可以用s表示，如:</p>
</blockquote>

<pre><code>bash</code><code>$ ls -l /var
drwxrwsr-x  2 root staff    4096 Apr 10  2014 local
drwxrwxr-x 15 root syslog   4096 Apr  4 19:57 log
</code></pre>
</li>
<li>
<p><strong><em>Sticky, 1:</em></strong></p>

<blockquote>
  <p>仅对目录有效。带<code>sticky</code>属性的目录下的文件或目录可以被其拥有者删除或改名。常利用<code>sticky</code>属性创建这样的目录：组用户可以在此目录中创建新文件、修改文件内容，但只有文件所有者才能对自己的文件进行删除或改名。如系统中的<code>/tmp</code>文件夹。在属性字符串中，通常用t表示。</p>
</blockquote>

<pre><code>bash</code><code>$ ls -l /
drwxrwxrwt   8 root root  4096 Apr  4 23:57 tmp
</code></pre>
</li>
</ul>
<h3>修改文件或文件夹对应用户的操作权限</h3>

<p>在 linux 系统中，可以使用<code>chmod</code>命令来修改文件或文件夹对应用户的操作权限，<code>chmod</code>命令也有两种方式修改，一种是使用代表相应操作权限的字母简写表示，另一种是使用代表相应操作权限的数字表示。</p>

<ul>
<li>
<p><strong><em>使用简写字母</em></strong></p>

<blockquote>
  <p><code>chmod</code>语法参数格式: [ugoa][[+-=][rwxst]<br>
  第一个字符是u、g、 o 或 a 中的一个（分别表示用户、组、其他人和所有人）。还可以选择添加（+）、删除（-）或设置（=）各种不同权限。</p>
</blockquote>

<ul>
<li>给文件或文件夹<code>try</code>的拥有者加可执行权限</li>
</ul>
<pre><code>bash</code><code>$ sudo chmod u+x try
</code></pre>

<ul>
<li>给文件或文件夹<code>try</code>的拥有者和组成员加可读可写权限</li>
</ul>
<pre><code>bash</code><code>$ sudo chmod ug+rw try
</code></pre>

<ul>
<li>给文件或文件夹<code>try</code>的拥有者和组成员除去可写权限</li>
</ul>
<pre><code>bash</code><code>$ sudo chmod ug-r try
</code></pre>
</li>
<li>
<p><strong><em>使用数字表示(八进制数)</em></strong></p>

<blockquote>
  <p>为了简化表述，也可使用八进制数来表示权限。即用一个四位八进制数来表示，其中最高位表示特殊权限，随后的三位依次是所有者权限、组权限和其他人权限。每一个八进制位的权限数值是文件具有的相应权限所对应的数值之后，如：</p>
</blockquote>

<pre><code>bash</code><code>0755=rwxr-xr-x=0(4+2+1)(4+0+1)(4+0+1)
</code></pre>

<blockquote>
  <p>数值权限的算法，比如<code>rw-</code>其实就是<code>110</code>的二进制，也就是<code>0*2^0 + 1*2^1 + 1*2^2 = 6</code>。有相应的权限就用<code>1</code>表示，没有相应的权限就用<code>0</code>表示。不过这种算法特殊权限不包含在内。</p>
</blockquote>

<ul>
<li>给文件或文件夹<code>try</code>的拥有者加<code>rwx</code>权限，组用户加<code>r-x</code>权限，其他用户<code>r--</code>权限</li>
</ul>
<pre><code>bash</code><code>$ sudo chmod 0754 try
</code></pre>

<ul>
<li>
<code>chmod</code>命令也可以递归的修改文件夹下所有的文件的权限，如给 try 文件夹下得所有文件加上 0755 权限</li>
</ul>
<pre><code>bash</code><code>$ sudo chmod -R 0755 try
</code></pre>

<ul>
<li>批量只修改文件或文件夹权限</li>
</ul>
<pre><code>bash</code><code>$ find -type d|xargs chmod 745     // 只修改文件夹权限
$ find -type f|xargs chmod 644     // 只修改文件权限
// 或者
$ chmod 745 `find 路径 -type d`     // 只修改文件夹权限
$ chmod 644 `find 路径 -type f`    // 只修改文件权限
</code></pre>

<ul>
<li>相应权限的数值:<br>
&gt; - <code>rwx</code>(7)、<code>rw-</code>(6)、<code>r-x</code>(5)、<code>r--</code>(4)、<code>--wx</code>(3)、<code>-w-</code>(2)、<code>--x</code>(1)、<code>---</code>(0)<br>
&gt; - suid: 符号<code>s</code>(4)<br>
&gt; - sgid: 符号<code>s</code>(2)<br>
&gt; - sticky: 符号<code>t</code>(1)</li>
</ul>
</li>
</ul>
<h3>修改文件或文件夹的拥有者和所属的组</h3>

<p>使用<code>chown</code>可以修改文件或文件夹的拥有者和所属的组。</p>

<ul>
<li>
<p>将文件或文件夹<code>try</code>的拥有者修改成<code>aikin</code>，所属的组修改成<code>adm</code></p>

<pre><code>bash</code><code>$ sudo chown aikin:adm try
</code></pre>
</li>
<li>
<p>和<code>chmod</code>一样，<code>-R</code>参数可以起到递归的作用</p>

<pre><code>bash</code><code>$ sudo chown -R aikin:adm try
</code></pre>
</li>
</ul>
<h3>创建组和用户</h3>

<ul>
<li>
<p><strong><em>组相关操作：</em></strong></p>

<ul>
<li>创建一个<code>try</code>组</li>
</ul>
<pre><code>bash</code><code>$ sudo groupadd  try
</code></pre>

<ul>
<li>修改<code>try</code>组的名字为<code>rename-try</code>
</li>
</ul>
<pre><code>bash</code><code>$ sudo groupadd -n rename-try try
</code></pre>

<ul>
<li>修改<code>try</code>组的名字为<code>rename-try</code>
</li>
</ul>
<pre><code>bash</code><code>$ sudo groupadd -n rename-try try
</code></pre>

<ul>
<li>删除<code>try2</code>组</li>
</ul>
<pre><code>bash</code><code>$ sudo groupdel  try2
</code></pre>

<ul>
<li>查看所有组</li>
</ul>
<pre><code>bash</code><code>$ sudo cat /etc/group
</code></pre>
</li>
<li>
<p><strong><em>用户相关操作：</em></strong></p>

<ul>
<li>创建用户<code>test</code><br>
&gt; 在 linux 系统上虽然可以使用<code>useradd</code>或<code>adduser</code>来创建用户，但是这两个命令是有区别的。<br>
&gt; 1. 使用<code>useradd</code>时，如果后面不添加任何参数选项，例如：<code>$sudo useradd test</code>创建出来的用户将是默认“三无”用户：一无Home Directory，二无密码，三无系统Shell。<br>
&gt; 2. 使用<code>adduser</code>时，创建用户的过程更像是一种人机对话，系统会提示你输入各种信息，然后会根据这些信息帮你创建新用户。<br>
&gt; 下面创建用户使用的是<code>adduser</code>命令:</li>
</ul>
<pre><code>bash</code><code>$ sudo adduser test
Adding user `test' ...
Adding new group `test' (1002) ...
Adding new user `test' (1001) with group `test' ...
Creating home directory `/home/test' ...
Copying files from `/etc/skel' ...
Enter new UNIX password:
Retype new UNIX password:
passwd: password updated successfully
Changing the user information for test
Enter the new value, or press ENTER for the default
Full Name []: test
Room Number []:
Work Phone []:
Home Phone []:
Other []:
Is the information correct? [Y/n] y
</code></pre>

<ul>
<li>修改用户</li>
</ul>
<pre><code>bash</code><code>$ sudo passwd test    // 修改用户密码
$ sudo usermod -d /home/test -G try2 test   // 将test用户的登录目录改成/home/test，并加入 try 组，注意这里是大 G。
$ sudo gpasswd -a test try     // 将用户 test 加入到 try2 组。
$ sudo gpasswd -d test try2    // 将用户 test 从 try 组中移除
</code></pre>

<ul>
<li>删除用户<code>test</code>
</li>
</ul>
<pre><code>bash</code><code>$ sudo userdel test
</code></pre>

<ul>
<li>查看所有用户</li>
</ul>
<pre><code>bash</code><code>$ cut -d : -f 1 /etc/passwd
// 或者
$ cat /etc/passwd |awk -F \: '{print $1}'
</code></pre>
</li>
</ul>
<p>　　<strong><em>了解 linux 用户操作权限，安全就掌握在手中。</em></strong></p>

<h2>参考</h2>

<ul>
<li><a rel="nofollow" href="http://www.ibm.com/developerworks/cn/linux/l-lpic1-v3-104-5/">学习 Linux，101: 管理文件权限和所有权</a></li>
<li><a rel="nofollow" href="http://linux-wiki.cn/wiki/zh-hans/%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90">文件权限</a></li>
<li><a rel="nofollow" href="http://blog.51yip.com/linux/1137.html">linux下添加，删除，修改，查看用户和用户组</a></li>
</ul>
<blockquote>
  <p><a rel="nofollow" href="http://ulaijn.com/2015/04/03/linux-file-permission-ower/">原文链接</a></p>
</blockquote>

2015年五月2日晚上 8:47:47
Fedora 21下Nvidia显卡的安装
<p>最近由于工作和学习需要，把家用的两台电脑攒成了一台机器，用的是Fedora 21，安装过程比较傻瓜就不写了，因为显卡用的是比较搓的N卡，N卡的开源驱动nouveau又搓的要死，装了跟不装一事，所以装机后需要做的第一件事就是要安装N卡的官方驱动，过程不难但是背不下来，所以正好在这里记录一下，以后也好找。</p>

<p>简单来说：</p>

<ul>
<li>
<p>查看自己显卡的型号</p>

<p>$ lspci | grep VGA<br>
01:00.0 VGA compatible controller: NVIDIA Corporation GK208 [<strong>GeForce GT 730</strong>] (rev a1)</p>
</li>
</ul>
<p>这里GeForce GT730就是我这块网卡的型号</p>

<ul>
<li>
<a rel="nofollow" href="http://www.geforce.cn/drivers">官网</a>搜索下载驱动</li>
</ul>
<p>按照提示几个选项一路选下来，搜索得到的驱动里选择一个最新的，随便用什么工具下载下来</p>

<pre><code>wget http://us.download.nvidia.com/XFree86/Linux-x86_64/346.59/NVIDIA-Linux-x86_64-346.59.run
</code></pre>

<ul>
<li>准备驱动安装环境</li>
</ul>
<p>到这里还不能直接安装驱动，下载下来的run文件在安装过程中会编译匹配我们当前系统版本的驱动出来。编译驱动需要用到kernel source，但如果是像我这样直接下了发行版来安装的话，默认是不包含kernel source的，所以我们需要安装对应当前系统版本的kernel-devel</p>

<pre><code>sudo yum install gcc kernel-devel-$(uname -r) 
</code></pre>

<p>系统更新完成后，要重启新的kernel才会生效，不过没关系等等一起重启也可以，现在我们要做的是屏蔽nouveau驱动，直接</p>

<pre><code>echo "blacklist nouveau" &gt;&gt; /etc/modprobe.d/blacklist.conf
</code></pre>

<p>移除已经安装的开源驱动包</p>

<pre><code>yum list | grep nouveau
yum remove xorg-x11-drv-nouveau.x86_64
</code></pre>

<p>设置默认启动进入字符界面</p>

<pre><code>systemctl set-default multi-user.target
</code></pre>

<p>(效力等同于重启后在登录界面输入ctrl+alt+F2,这点还不熟悉的同学可以看看systemcl的几组user target的定义)</p>

<p>重启系统之后安装官方驱动</p>

<pre><code>chmod u+x ./*.run
./NVIDIA-Linux-x86_64-346.59.run
</code></pre>

<p>跟着提示一路走下去即可，安装完成之后记得将启动级别改回到图形界面</p>

<pre><code>systemctl set-default graphical.target
</code></pre>

<p>然后重启就可以了。</p>

<p>问题：<br>
安装过程没遇到什么问题，有一点可以注意一下，如果你安装kernel-devel的时候没有指定<code>uname -r</code>，即当前版本，你更新到的kernel source会是最新版的，在编译官方驱动的时候会跟你抱怨找不到KDIR的。</p>

2015年五月2日晚上 8:13:32
关于redis不同权限列表显示缓存问题-带分页
<div class="markdown-text"><p>各位大神好,求助,由于对redis+mysql这种nosql+sql方式存储没有最佳实践,想求教下有这种经验的大神,最近用mysql+redis+nodejs做个大数据高并发东西,想要用redis缓存带分页列表信息减少mysql查询压力,当前端访问时候可以根据不同访问权限到redis提取数据,如果没有则从mysql查询.(比如:老师,学生,校长三个不同权限拉取数据不同,需要考虑数据更新,redis-mysql数据一致性问题).</p>
</div>

2015年五月2日下午 3:07:27
T-SQL学习中--内联接，外连接，交叉连接
<p>交叉连接可以表A和表B是同一张表取得笛卡尔乘积。<br>
比如说下面这种写法：</p>

<pre><code>SQL</code><code>SELECT D.n AS theday, S.n AS shiftno  
FROM dbo.Nums AS D
  cross JOIN dbo.Nums AS S
WHERE D.n &lt;= 7
  AND S.N &lt;= 3
ORDER BY theday, shiftno;

</code></pre>

<p>当然也可以表A和表B是两张不同的表，取得笛卡尔乘积。</p>

<pre><code>SQL</code><code>SELECT D.n AS theday, S.empid AS shiftno  
FROM dbo.Nums AS D
  cross JOIN [HR].[Employees] AS S
WHERE D.n &lt;= 7
  AND S.empid &lt;= 3
ORDER BY theday, shiftno;
</code></pre>

<p>但是<code>CROSS JOIN</code>不能用<code>ON</code>条件，只能用<code>WHERE</code>条件。下面这句与上面的语句查询结果相同。</p>

<pre><code>SQL</code><code>SELECT D.n AS theday, S.empid AS shiftno  
FROM dbo.Nums AS D
  inner JOIN [HR].[Employees] AS S
on D.n &lt;= 7
  AND S.empid &lt;= 3
ORDER BY theday, shiftno;
</code></pre>

<p>内联接查询，表A和表B中的数据必须紧密对应，不可以是Null。下面的查询中，<code>Production.Products</code>表中没有商品记录的的日本供货商不会被列出来。<code>INNER</code>这个关键词是可以舍去的，如果只写<code>JOIN</code>就表示<code>INNER JOIN</code>。</p>

<pre><code>SQL</code><code>SELECT
  S.companyname AS supplier, S.country,
  P.productid, P.productname, P.unitprice
FROM Production.Suppliers AS S
  INNER JOIN Production.Products AS P
    ON S.supplierid = P.supplierid
WHERE S.country = N'Japan';
</code></pre>

<p>外连接查询有三种情况：左外连接，右外连接，全外连接。<br>
下面这个查询与上面这个查询写法只差一点点（WHERE变成了AND），但是结果就有区别：</p>

<pre><code>SQL</code><code>SELECT
  S.companyname AS supplier, S.country,
  P.productid, P.productname, P.unitprice
FROM Production.Suppliers AS S
  INNER JOIN Production.Products AS P
    ON S.supplierid = P.supplierid
    AND S.country = N'Japan';
</code></pre>

<p>而且<code>Production.Products</code>表中没有商品记录的的日本供货商同样也会被列出来，但是相关的P.productid, P.productname, P.unitprice都会被记为NULL。<br>
下面这句：</p>

<pre><code>SQL</code><code>SELECT E.empid,
  E.firstname + N' ' + E.lastname AS emp,
  M.firstname + N' ' + M.lastname AS mgr
FROM HR.Employees AS E
  INNER JOIN HR.Employees AS M
    ON E.mgrid = M.empid;
</code></pre>

<p>用了内联接，则最高主管（CEO）不会被列出来，因为最高主管没有更高的主管了。<br>
而改用左外连接</p>

<pre><code>SQL</code><code>SELECT E.empid,
  E.firstname + N' ' + E.lastname AS emp,
  M.firstname + N' ' + M.lastname AS mgr
FROM HR.Employees AS E
  LEFT OUTER JOIN HR.Employees AS M
    ON E.mgrid = M.empid;
</code></pre>

<p>则CEO也会被列出来，CEO对应的mgr会被记为NULL。<br>
套用内联接的左外连接：</p>

<pre><code>SQL</code><code>SELECT
  S.companyname AS supplier, S.country,
  P.productid, P.productname, P.unitprice,
  C.categoryname
FROM Production.Suppliers AS S
  LEFT OUTER JOIN Production.Products AS P
    ON S.supplierid = P.supplierid
  INNER JOIN Production.Categories AS C
    ON C.categoryid = P.categoryid
WHERE S.country = N'Japan';
</code></pre>

<p>查询出日本供货商的所有的产品以及产品类别名。而且<code>Production.Products</code>表中没有商品记录的的日本供货商同样也会被列出来，但是相关的P.productid, P.productname, P.unitprice, C.categoryname都会被记为NULL。<br>
上面的语句与下面带括号的语句等同：</p>

<pre><code>SQL</code><code>SELECT
  S.companyname AS supplier, S.country,
  P.productid, P.productname, P.unitprice,
  C.categoryname
FROM Production.Suppliers AS S
  LEFT OUTER JOIN 
    (Production.Products AS P
       INNER JOIN Production.Categories AS C
         ON C.categoryid = P.categoryid)
    ON S.supplierid = P.supplierid
WHERE S.country = N'Japan';
</code></pre>

<p><code>RIGHT OUTER JOIN</code>则与<code>LEFT OUTER JOIN</code>相反，根据ON条件和WHERE条件查询表A和表B，查询结果可以表A中数据为NULL。<br><code>FULL OUTER JOIN</code>则只要表A和表B中任一表中有数据，结果都会被显示出来。无论是表A为NULL，还是表B为NULL。<br><code>OUTER</code>也是可以被省略的。<code>LEFT JOIN</code>就是<code>LEFT OUTER JOIN</code>的简写，相应的，<code>RIGHT JOIN</code>是<code>RIGHT OUTER JOIN</code>的简写，<code>FULL JOIN</code>是<code>FULL OUTER JOIN</code>的简写。</p>

2015年五月2日下午 2:22:12
T-SQL学习中--取得部分检索数据记录
<p><code>SELECT TOP(n) FROM _TableName_ ORDER BY _ColumnName_</code>是一种非标准SQL语句，从数据表中最多检索出排在前面的n条数据来，但是它可以用<code>SELECT TOP(n) PERCENT FROM _TABLENAME_ ORDER BY</code> 这样的根据总数据量来按比例取得数据记录。<br>
如果数据表中有560条数据，检索<code>SELECT TOP(1) FROM _TableName_ ORDER BY _ColumnName_</code>就会检索出6条数据来，总而言之，不是按四舍五入计的，而是按<code>ceil</code>向上取整法计数的。<br>
如果不加<code>ORDER BY</code>，数据会以不确定的顺序检索出来。<br>
这里括号可有可无，但是建议加括号。<br>
n可以是常数，也可以是定义的变量。下面这种写法也是可以的：</p>

<pre><code>SQL</code><code>DECLARE @n AS BIGINT = 5;
SELECT TOP (@n) orderid, orderdate, custid, empid
FROM Sales.Orders
ORDER BY orderdate DESC;
GO
</code></pre>

<p>如果加了<code>WITH TIE</code>，比如说写成</p>

<pre><code>SQL</code><code>SELECT TOP (3) WITH TIES orderid, orderdate, custid, empid
FROM Sales.Orders
ORDER BY orderdate DESC;
</code></pre>

<p>则<code>orderdate</code>相同的数据会被计作一条数据，总检索出的结果可能不止3条。</p>

<p><code>OFFSET FETCH</code>语句是标准SQL语句。但是它有局限性，不能按百分比检索出数据结果。</p>

<pre><code>SQL</code><code>SELECT orderid, orderdate, custid, empid
FROM Sales.Orders
ORDER BY orderdate DESC, orderid DESC
OFFSET 50 ROWS FETCH NEXT 25 ROWS ONLY;
</code></pre>

<p>表示跳过前50条数据，取得第51到第75条数据。</p>

<pre><code>SQL</code><code>SELECT orderid, orderdate, custid, empid
FROM Sales.Orders
ORDER BY orderdate DESC, orderid DESC
OFFSET 0 ROWS FETCH FIRST 25 ROWS ONLY;
</code></pre>

<p>表示取得第1到第25条数据。</p>

<pre><code>SQL</code><code>SELECT orderid, orderdate, custid, empid
FROM Sales.Orders
ORDER BY orderdate DESC, orderid DESC
OFFSET 50 ROWS;
</code></pre>

<p>表示跳过前50条数据，取得之后的全部数据。<br><code>OFFSET FETCH</code>语句必须带有<code>ORDER BY</code>语句，但是如果不想指定用于排序的columnName，可以用下面这种这种语法，即用<code>SELECT NULL</code>作为排序列：</p>

<pre><code>SQL</code><code>SELECT orderid, orderdate, custid, empid
FROM Sales.Orders
ORDER BY (SELECT NULL)
OFFSET 0 ROWS FETCH FIRST 3 ROWS ONLY;
</code></pre>

<p><code>OFFSET FETCH</code>可用于分页检索，比如说下面这种写法：</p>

<pre><code>SQL</code><code>DECLARE @pagesize AS BIGINT = 25, @pagenum AS BIGINT = 3;

SELECT orderid, orderdate, custid, empid
FROM Sales.Orders
ORDER BY orderdate DESC, orderid DESC
OFFSET (@pagenum - 1) * @pagesize ROWS FETCH NEXT @pagesize ROWS ONLY;
</code></pre>

2015年五月2日上午 11:09:04
GitLab 安装配置笔记
<h1>GitLab的安装方式</h1>

<p>GitLab的两种安装方法:</p>

<ul>
<li>编译安装<br><br><ul>
<li>优点：可定制性强。数据库既可以选择MySQL,也可以选择PostgreSQL;服务器既可以选择Apache，也可以选择Nginx。</li>
<li>缺点：国外的源不稳定，被墙时，依赖软件包难以下载。配置流程繁琐、复杂，容易出现各种各样的问题。依赖关系多，不容易管理，卸载GitLab相对麻烦。</li>
</ul>
</li>
<li>通过rpm包安装<br><br><ul>
<li>优点：安装过程简单，安装速度快。采用rpm包安装方式，安装的软件包便于管理。</li>
<li>缺点：数据库默认采用PostgreSQL，服务器默认采用Nginx，不容易定制。</li>
</ul>
</li>
</ul>
<p>由于公司只配备了一台阿里云服务器，并且没有分配任何的域名。该服务器上需要运行版本控制软件、bug管理软件、知识库等多套程序，只能采用ip的方式访问。原先采用GitLab+Apache+MySQL编译安装的方式，并且将GitLab配置为可通过<code>xxx.xx.xxx.xx/gitlab</code>的形式访问，由于bug管理软件（禅道）也运行于Apache之上，两套软件之间彼此有互斥的影响，找不到解决方法。同时，GitLab的注册需要邮箱验证，由于网上提供的配置方法都是基于域名的，在阿里云上多次进行配置都无法正常使用。</p>

<p>因此，只能放弃编译安装的方式，而采取rpm包的方式重新进行安装。</p>

<h1>安装GitLab CE Omnibus包</h1>

<ol>
<li><p>在linux终端下，使用<code>cat /etc/issue</code>命令查询当前系统的发行版本，查询到阿里云所安装的linux版本为CentOS release 6.6 (Final)。</p></li>
<li>
<p>进入<a rel="nofollow" href="https://about.gitlab.com/downloads/">gitlab官方网站</a>,选择对应的操作系统——CentOS 6 (and RedHat/Oracle/Scientific Linux 6),按照官方的提示进行安装：</p>

<ol>
<li>
<p>安装配置必要的依赖</p>

<p>在Centos 6 和 7 中，以下的命令将会打开HTTP和SSH在系统防火墙中的可访问权限。</p>

<pre><code>bash</code><code>sudo yum install openssh-server

sudo yum install postfix

sudo yum install cronie

sudo service postfix start

sudo chkconfig postfix on

sudo lokkit -s http -s ssh

</code></pre>
</li>
<li>
<p>下载Omnibus package包并安装</p>

<pre><code>bash</code><code>curl -O https://downloads-packages.s3.amazonaws.com/centos-6.6/gitlab-ce-7.10.0~omnibus.2-1.x86_64.rpm
sudo rpm -i gitlab-ce-7.10.0~omnibus.2-1.x86_64.rpm
</code></pre>

<pre><code>Note:由于amazonaws的服务器被墙，下载这个包时可能需要翻墙下载。
</code></pre>
</li>
<li>
<p>配置并启动GitLab<br>
打开<code>/etc/gitlab/gitlab.rb</code>,将<code>external_url = 'http://git.example.com'</code>修改为自己的IP地址：<code>http://xxx.xx.xxx.xx</code>,，然后执行下面的命令，对GitLab进行编译。</p>

<pre><code>bash</code><code>sudo gitlab-ctl reconfigure
</code></pre>
</li>
<li>
<p>登录GitLab</p>

<pre><code>Username: root 
Password: 5iveL!fe
</code></pre>
</li>
</ol>
</li>
</ol>
<h1>配置GitLab的默认发信邮箱</h1>

<ol>
<li>GitLab中使用<code>postfix</code>进行邮件发送。因此，可以卸载系统中自带的<code>sendmail</code>。<br>
使用<code>yum list installed</code>查看系统中是否存在<code>sendmail</code>，若存在，则使用<code>yum remove sendmail</code>指令进行卸载。</li>
<li>
<p>测试系统是否可以正常发送邮件。</p>

<pre><code>bash</code><code>echo "Test mail from postfix" | mail -s "Test Postfix" xxx@xxx.com
</code></pre>

<pre><code>注：上面的xxx@xxx.com为你希望收到邮件的邮箱地址。
</code></pre>

<p>当邮箱收到系统发送来的邮件时，将系统的地址复制下来，如：<code>root@iZ23syflhhzZ.localdomain</code>,打开<code>/etc/gitlab/gitlab.rb</code>,将</p>

<pre><code># gitlab_rails['gitlab_email_from'] = 'gitlab@example.com' 
</code></pre>

<p>修改为</p>

<pre><code>gitlab_rails['gitlab_email_from'] = 'root@iZ23syflhhzZ.localdomain' 
</code></pre>

<p>保存后，执行<code>sudo gitlab-ctl reconfigure</code>重新编译GitLab。如果邮箱的过滤功能较强，请添加系统的发件地址到邮箱的白名单中，防止邮件被过滤。</p>

<pre><code>Note:系统中邮件发送的日志可通过`tail /var/log/maillog`命令进行查看。
</code></pre>
</li>
</ol>
<h1>安装过程中出现的问题</h1>

<ol>
<li>
<p>在浏览器中访问GitLab出现<code>502</code>错误</p>

<p>原因：内存不足。</p>

<p>解决办法：检查系统的虚拟内存是否随机启动了，如果系统无虚拟内存，则增加虚拟内存，再重新启动系统。</p>
</li>
<li>
<p><code>80</code>端口冲突</p>

<p>原因：Nginx默认使用了<code>80</code>端口。</p>

<p>解决办法：为了使Nginx与Apache能够共存，并且为了简化GitLab的URL地址，Nginx端口保持不变，修改Apache的端口为4040。这样就可以直接用使用ip访问Gitlab。而禅道则可以使用<code>4040</code>端口进行访问，像这样：<code>xxx.xx.xxx.xx:4040/zentao</code>。具体修改的地方在<code>/etc/httpd/conf/httpd.conf</code>这个文件中，找到<code>Listen 80</code>这一句并将之注释掉，在底下添加一句<code>Listen 4040</code>，保存后执行<code>service httpd restart</code>重启apache服务即可。</p>

<pre><code>#Listen 80 
Listen 4040 
</code></pre>
</li>
<li>
<p><code>8080</code>端口冲突</p>

<p>原因：由于unicorn默认使用的是<code>8080</code>端口。</p>

<p>解决办法：打开<code>/etc/gitlab/gitlab.rb</code>,打开<code># unicorn['port'] = 8080</code>的注释，将<code>8080</code>修改为<code>9090</code>，保存后运行<code>sudo gitlab-ctl reconfigure</code>即可。</p>
</li>
<li>
<p>STMP设置</p>

<p>配置无效，暂时不知道原因。</p>
</li>
<li>
<p>GitLab头像无法正常显示<br>
原因：gravatar被墙<br>
解决办法：<br>
编辑 <code>/etc/gitlab/gitlab.rb</code>，将</p>

<pre><code>#gitlab_rails['gravatar_plain_url'] = 'http://gravatar.duoshuo.com/avatar/%{hash}?s=%{size}&amp;d=identicon'
</code></pre>

<p>修改为：</p>

<pre><code>gitlab_rails['gravatar_plain_url'] = 'http://gravatar.duoshuo.com/avatar/%{hash}?s=%{size}&amp;d=identicon'
</code></pre>

<p>然后在命令行执行：</p>

<pre><code>bash</code><code>sudo gitlab-ctl reconfigure 
sudo gitlab-rake cache:clear RAILS_ENV=production
</code></pre>
</li>
</ol>
<h1>参考资料</h1>

<p><a rel="nofollow" href="http://www.07net01.com/program/641580.html">GitLab 6.1 使用postfix发送email</a></p>

<p><a rel="nofollow" href="http://devonoid.net/configure-gitlab-omnibus-installation-alongside-with-apache/">Configure GitLab Omnibus installation alongside with Apache</a></p>

<p><a rel="nofollow" href="http://my.oschina.net/anylain/blog/355797">解决Gitlab的Gravatar头像无法显示的问题</a></p>

<p><a rel="nofollow" href="https://www.digitalocean.com/community/tutorials/how-to-set-up-gitlab-as-your-very-own-private-github-clone">How To Set Up GitLab As Your Very Own Private GitHub Clone</a></p>

2015年五月1日晚上 8:12:21
PHP 5.3 连接 Oracle 的客户端及 PDO_OCI 模块安装
<p>php连接oracle数据库虽然不是最佳拍档，但组内开发确实有这样需求。如果没有参考合适的文档，这个过程还是挺折磨人的，下面是一个记录，原型是国外的一篇博客 <a rel="nofollow" href="http://shiki.me/blog/installing-pdo_oci-and-oci8-php-extensions-on-centos-6-4-64bit/">Installing PDO_OCI and OCI8 PHP extensions on CentOS 6.4 64bit</a>。</p>

<p>假设你已经安装好php的环境，php版本为5.3，要连接的oracle服务器是 11g R2，操作系统版本CentOS 6.4 x86_64。如果没有安装php，可以通过以下命令安装：</p>

<pre><code># yum install php php-pdo
# yum install php-devel php-pear php-fpm php-gd php-ldap \
php-mbstring php-xml php-xmlrpc  php- zlib zlib-devel bc libaio glibc
</code></pre>

<p>假如web服务器使用apache。</p>

<h2>1. 安装InstantClient</h2>

<p>instantclient是oracle的连接数据库的简单客户端，不用安装一个500Moracle客户端就可以连接oracle数据库，有windows和linux版本。从 <a rel="nofollow" href="http://www.oracle.com/technetwork/topics/linuxx86-64soft-092277.html">这里</a> 选择需要的版本下载，只需Basic和Devel两个rpm包。</p>

<pre><code>安装
# rpm -ivh oracle-instantclient11.2-basic-11.2.0.4.0-1.x86_64.rpm
# rpm -ivh oracle-instantclient11.2-devel-11.2.0.4.0-1.x86_64.rpm

软链接
# ln -s /usr/include/oracle/11.2/client64 /usr/include/oracle/11.2/client
# ln -s /usr/lib/oracle/11.2/client64 /usr/lib/oracle/11.2/client
</code></pre>

<p>64位系统需要创建32位的软链接，这里可能是一个遗留bug，不然后面编译会出问题。</p>

<p>接下来还要让系统能够找到oracle客户端的库文件，修改LD_LIBRARY_PATH：</p>

<pre><code># vi /etc/profile.d/oracle.sh
export ORACLE_HOME=/usr/lib/oracle/11.2/client64
export LD_LIBRARY_PATH=$ORACLE_HOME/lib
</code></pre>

<p>执行<code>source /etc/profile.d/oracle.sh</code>使环境变量生效。</p>



<h2>2. 安装PDO_OCI</h2>

<p>在连接互联网的情况下，通过pecl在线安装php的扩展非常简单，参考 <a rel="nofollow" href="http://stackoverflow.com/questions/21936091/how-to-install-oracle-instantclient-and-pdo-oci-on-ubuntu-machine">How to install oracle instantclient and pdo_oci on ubuntu machine</a> 。</p>

<p>从<a rel="nofollow" href="https://pecl.php.net/package/PDO_OCI">https://pecl.php.net/package/PDO_OCI</a>下载 PDO_OCI-1.0.tgz 源文件。</p>

<pre><code># wget https://pecl.php.net/get/PDO_OCI-1.0.tgz
# tar -xvf PDO_OCI-1.0.tgz
# cd PDO_OCI-1.0
</code></pre>

<p>由于PDO_OCI很久没有更新，所以下面需要编辑<code>ODI_OCI-1.0</code>文件夹里的<code>config.m4</code>文件来让它支持11g：</p>

<pre><code># 在第10行左右找到与下面类似的代码，添加这两行：
elif test -f $PDO_OCI_DIR/lib/libclntsh.$SHLIB_SUFFIX_NAME.11.2; then
  PDO_OCI_VERSION=11.2

# 在第101行左右添加这几行：
11.2)
  PHP_ADD_LIBRARY(clntsh, 1, PDO_OCI_SHARED_LIBADD)
  ;;
</code></pre>

<p>编译安装pdo_oci扩展：（安装完成后可在 /usr/lib64/php/modules/pdo_oci.so 找到这个模块）</p>

<pre><code>$ phpize
$ ./configure --with-pdo-oci=instantclient,/usr,11.2
$ make
$ sudo make install
</code></pre>

<p>要启用这个扩展，在<code>/etc/php.d/</code>下新建一个<code>pdo_oci.ini</code>文件，内容：</p>

<pre><code>extension=pdo_oci.so
</code></pre>

<p>验证安装成功：</p>

<pre><code># php -i|grep oci
看到类似下面的内容则安装成功:
/etc/php.d/pdo_oci.ini,
PDO drivers =&gt; oci, sqlite

或
# php -m
</code></pre>

<h2>3. 安装OCI8</h2>

<p>从 <a rel="nofollow" href="https://pecl.php.net/package/oci8">https://pecl.php.net/package/oci8</a> 下载oci8-2.0.8.tgz源文件。</p>

<pre><code># wget https://pecl.php.net/get/oci8-2.0.8.tgz
# tar -xvf oci8-2.0.8.tgz
# cd oci8-2.0.8
</code></pre>

<p>编译安装oci8扩展：</p>

<pre><code># phpize
# ./configure --with-oci8=shared,instantclient,/usr/lib/oracle/11.2/client64/lib
# make
# make install
</code></pre>

<p>要启用这个扩展，在<code>/etc/php.d/</code>下新建一个<code>oci8.ini</code>文件，内容：</p>

<pre><code>extension=oci8.so
</code></pre>

<p>验证安装成功：</p>

<pre><code># php -i|grep oci8
/etc/php.d/oci8.ini,
oci8
oci8.connection_class =&gt; no value =&gt; no value
oci8.default_prefetch =&gt; 100 =&gt; 100
oci8.events =&gt; Off =&gt; Off
oci8.max_persistent =&gt; -1 =&gt; -1
oci8.old_oci_close_semantics =&gt; Off =&gt; Off
oci8.persistent_timeout =&gt; -1 =&gt; -1
oci8.ping_interval =&gt; 60 =&gt; 60
oci8.privileged_connect =&gt; Off =&gt; Off
oci8.statement_cache_size =&gt; 20 =&gt; 20
OLDPWD =&gt; /usr/local/src/oci8-2.0.8
_SERVER["OLDPWD"] =&gt; /usr/local/src/oci8-2.0.8
</code></pre>

<p>最后别忘了重启逆web服务器如apache，可以通过phpinfo()来确保扩展是否成功安装。</p>

<h2>4. 测试连接</h2>

<p>在你web服务器如apache的php目录下创建<code>testoci.php</code>：</p>

<pre><code>&lt;?php

$conn = oci_connect('username', 'password', '172.29.88.178/DBTEST');

$stid = oci_parse($conn, 'select table_name from user_tables');
oci_execute($stid);

echo "&lt;table&gt;\n";
while (($row = oci_fetch_array($stid, OCI_ASSOC+OCI_RETURN_NULLS)) != false) {
    echo "&lt;tr&gt;\n";
    foreach ($row as $item) {
        echo "  &lt;td&gt;".($item !== null ? htmlentities($item, ENT_QUOTES) : "&amp;nbsp;")."&lt;/td&gt;\n";
    }
    echo "&lt;/tr&gt;\n";
}
echo "&lt;/table&gt;\n";

?&gt;
</code></pre>

<p>访问这个页面就应该可以得到结果了。</p>

<p><strong>参考</strong></p>

<ul>
<li><a rel="nofollow" href="http://shiki.me/blog/installing-pdo_oci-and-oci8-php-extensions-on-centos-6-4-64bit/">Installing PDO_OCI and OCI8 PHP extensions on CentOS 6.4 64bit</a></li>
<li><a rel="nofollow" href="http://www.oracle.com/technetwork/cn/articles/dsl/technote-php-instant-090922-zhs.html">在 Linux 和 Windows 上安装 PHP 和 Oracle Instant Client</a></li>
<li><a rel="nofollow" href="http://iceeggplant.blog.51cto.com/1446843/1052512">php5.3安装oracle的扩展oci8与pdo_oci</a></li>
</ul>
<hr>
<p>原文链接地址：<a rel="nofollow" href="http://seanlook.com/2015/03/10/install-pdo-oci-oci8-phpext/">http://seanlook.com/2015/03/10/install-pdo-oci-oci8-phpext/</a></p>

<hr>

2015年四月30日晚上 11:41:21
OpenWrt路由器开发
<blockquote>
  <p><a rel="nofollow" href="http://homeway.me"></a><a rel="nofollow" href="http://homeway.me">http://homeway.me</a></p>
</blockquote>

<p><img src="http://xiaocao.u.qiniudn.com/blog/logo-openwrt.png" alt="OpenWrt"></p>



<p><br></p>

<hr>
<p><br></p>

<h1>0x01.About</h1>

<p>第一次尝试开发路由器，发现并不是想象中那么难，和普通嵌入式开发一样，也是一块ARM板刷上Linux系统。</p>

<p>OpenWrt有很多好用的软件，附带流量监测。</p>

<p>OpenWrt主要开发语言为Python、Lua、Shell，还可以做深入研究写ipk软件包。</p>

<p>写了几个脚本，主要实现了openwrt下面GPIO控制、系统信息获取、wifi扫描器、定时发送邮件系统报警等功能，下面会介绍。</p>

<p>代码已经在Github开源：  <a rel="nofollow" href="https://github.com/grasses/OpenWRT-Util"></a><a rel="nofollow" href="https://github.com/grasses/OpenWRT-Util">https://github.com/grasses/OpenWRT-Util</a></p>

<p><br></p>

<hr>
<h1>0x02.About OpenWrt</h1>

<p>刷OpenWrt先要去<a rel="nofollow" href="https://downloads.openwrt.org/"></a><a rel="nofollow" href="https://downloads.openwrt.org/">https://downloads.openwrt.org/</a>下载你想要的版本，包含aa型和bb型。</p>

<p>然后用Linux烧入命令烧入系统。</p>

<p>早MAC下面，先现将U盘插入电脑格式化，然后运行命令查看U盘编号：</p>

<blockquote>
  <p>diskUtil list</p>
</blockquote>

<p>注意查看U盘编号，选择你的U盘，解除挂载：</p>

<blockquote>
  <p>diskUtil unmountDisk /dev/disk2</p>
</blockquote>

<p>然后烧入系统：</p>

<blockquote>
  <p>dd if=/path/to/openwrt.img of=/dev/disk2 bs=2m</p>
</blockquote>

<p>等待几分钟后烧入成功。</p>

<h4>关于痛点：</h4>

<pre><code>第一次是在树莓派上安装OpenWrt，装好后，用有线把连进上级路由器的Lan口

然后，上级路由的包开始乱了，上级路由把OpenWrt当成路由器，OpenWrt把路由器当成上级路由器，然后就GG了。
</code></pre>

<p><br></p>

<hr>
<h1>0x03.About WRTnode</h1>

<p>WRTnode是OpenWrt系统一个硬件解决方案，预先安装了OpenWrt相关软件包，并且内置两块无线网卡。</p>

<p>关于WRTnode，官方wiki已经介绍的很详细了：<a rel="nofollow" href="http://wiki.wrtnode.com/index.php?title=Main_Page/zh-cn"></a><a rel="nofollow" href="http://wiki.wrtnode.com/index.php?title=Main_Page/zh-cn">http://wiki.wrtnode.com/index.php?title=Main_Page/zh-cn</a></p>

<p>解析来的代码基本上是在WRTnode环境上开发的，主要包含了：</p>

<ul>
<li><p>luci(WRTnode自带，非WRTnode用opkg安装即可)</p></li>
<li><p>python(WRTnode自带，非WRTnode用opkg安装即可)</p></li>
<li><p>luasocket( <a rel="nofollow" href="http://see.sl088.com/wiki/Luasocket"></a><a rel="nofollow" href="http://see.sl088.com/wiki/Luasocket">http://see.sl088.com/wiki/Luasocket</a> )</p></li>
</ul>
<p>目前只能想起这3个，如果报错，该装什么再装好了。</p>

<p><br></p>

<hr>
<h1>0x04.WRTnode控制GPIO</h1>

<p>GPIO控制可以很好地实现软件硬件之间的交互。</p>

<p><img src="http://xiaocao.u.qiniudn.com/blog/2015-04-29-openwrt-gpio.jpg" alt="WRTnode GPIO"></p>

<p>GPIO的控制也不难，wiki讲得很清晰了，就是文件输入输出<a rel="nofollow" href="http://wiki.wrtnode.com/index.php?title=The_user_space_gpio_calls/zh-cn"></a><a rel="nofollow" href="http://wiki.wrtnode.com/index.php?title=The_user_space_gpio_calls/zh-cn">http://wiki.wrtnode.com/index.php?title=The_user_space_gpio_calls/zh-c...</a></p>

<p>这里我写了一个Lua版的GPIO控制模块，文件保存为gpio.lua：</p>

<pre><code>#!/usr/bin/lua
--[[
Copyright 2015 http://homeway.me
@author homeway
@version 15.04.29
@link http://homeway.me
@function OpenWRT gpio module
-- ]]--

local M = {}
M.id = ""
M.path = "/sys/class/gpio/gpio"
M.router = "/sys/class/gpio"

M.check = function(where)
    print("check path =&gt; "..where)
    local f=io.open(where, "r")
    if f~=nil then io.close(f) return true else return false end
end
-- set mode &amp;&amp; check type
M.mode = function(id, mtype)
    M.id = id
    where = M.path..M.id
    -- if id not use
    if false==M.check(M.path..id..'/direction') then
        --M.writeFile(M.router.."/unexport",id)
        M.writeFile(M.router.."/export", id)
    end
    -- if type different 
    if mtype ~= M.readFile(M.path..id..'/direction') then
        print("type =&gt;"..mtype.." direction=&gt;"..M.readFile(M.path..id..'/direction').." different")
        M.writeFile(M.path..id..'/direction', mtype)
    end
end
-- file write
M.writeFile = function(where, what)
    print("write path =&gt; "..where.." data =&gt;"..what)
    local fp=io.open(where, 'w')
    fp:write(what)
    fp:close()  
end
-- file read
M.readFile = function(where)
    print("read path =&gt; "..where)
    local fp=io.open(where, 'r')
    if fp~=nil then
        data = fp:read("*all")
        fp:close()
        return data
    end
    return nil
end
M.set = function(id)
    M.id = id
end
M.read = function()
    res = M.readFile(M.path..M.id..'/value')
    return res
end
M.write = function(value)
    res = M.writeFile(M.path..M.id..'/value', value)
end
M.close = function()
    print("sleep io =&gt; "..M.id)
    os.execute("sleep " .. tonumber(M.id))
end

return M

</code></pre>

<p>API很简单，先设置设置模式，GPIO.mode(id, "out/in")两种模式之一</p>

<p>如果为'out'即可调用GPIO.write(value)函数，写入当然id端口，如果为'in'模式，只能调用GPIO.read()读取数值。</p>

<p>这里数值只能是0或1，非0即为1.</p>

<p>调用方式如下，这个存在一个可忽略的问题，一旦调用mode，数值将被置为默认数值，即0：</p>

<pre><code>#!/usr/bin/lua
x=require("gpio")
print("Please input io id =&gt;")
id = io.read("*num")
x.mode(id, "out")-- 设置io的模式为输入还是输出 [in/out]
function readGPIO(id)
    value = x.read()
    print("read data from =&gt; `"..id.."` =&gt;"..value)
end
function writeGPIO(id, data)
    x.write(data)
    print("write data to =&gt; `"..id.."` =&gt;"..data)
end

count=1
repeat
    count=count+1
    print("Please input value =&gt;")
    data = io.read("*num")
    writeGPIO(id, data)
    readGPIO(id)
until count&gt;3

</code></pre>

<p><br></p>

<hr>
<h1>0x05.WRTnode获取系统信息</h1>

<p>其实获取系统信息不属于WRTnode范围，因为这部分主要是调用Linux Shell获取系统信息，做个反馈。</p>

<p>这里我也写了个python脚本，主要检查系统信息，这个脚本在树莓派那里面也有：<a rel="nofollow" href="http://homeway.me/2014/10/09/raspberry-the-current-status-and-data/"></a><a rel="nofollow" href="http://homeway.me/2014/10/09/raspberry-the-current-status-and-data/">http://homeway.me/2014/10/09/raspberry-the-current-status-and-data/</a></p>

<p>这里我做了部分修改，添加系统ip、连接的ssid等信息：</p>

<pre><code>#!/usr/bin/python
'''
    @author homeway
    @version 15.04.29
    @link http://homeway.me
    @function python get OpenWRT system info
'''
import os
# Return CPU temperature as a character string                                     
def getCPUtemperature():
    res = os.popen('vcgencmd measure_temp').readline()
    return(res.replace("temp=","").replace("'C\n",""))
# Return RAM information (unit=kb) in a list                                      
# Index 0: total RAM                                                              
# Index 1: used RAM                                                                
# Index 2: free RAM                                                                
def getRAMinfo():
    p = os.popen('free')
    i = 0
    while 1:
        i = i + 1
        line = p.readline()
        if i==2:
            return(line.split()[1:4])
# Return % of CPU used by user as a character string                               
def getCPUuse():
    return(str(os.popen("top -n1 | awk '/Cpu\(s\):/ {print $2}'").readline().strip()))

# Return information about disk space as a list (unit included)                    
# Index 0: total disk space                                                        
# Index 1: used disk space                                                        
# Index 2: remaining disk space                                                    
# Index 3: percentage of disk used                                                 
def getDiskSpace():
    p = os.popen("df -h /")
    i = 0
    while 1:
        i = i +1
        line = p.readline()
        if i==2:
            return(line.split()[1:5])
def getSystem():
    p = os.popen("uname -amnrspv")
    while 1:
        line = p.readline()
        return(line)
def getExtranetIp():
    p = os.popen('wget "http://www.ip138.com/ips1388.asp" -q -O - | sed -nr \'s/.*\[(([0-9]+\.){3}[0-9]+)\].*/\1/p\'')
    while 1:
        line = p.readline()
        print line
        return(line)
def getIntranetIp():
    p = os.popen('ifconfig apcli0 | grep inet\ addr')
    while 1:
        line = p.readline()
        return(line)
def getSsid():
    p = os.popen('uci get wireless.@wifi-iface[0].ApCliSsid')
    while 1:
        line = p.readline()
        return(line)
# CPU informatiom
CPU_temp = getCPUtemperature()
CPU_usage = getCPUuse()
# RAM information
# Output is in kb, here I convert it in Mb for readability
RAM_stats = getRAMinfo()
RAM_total = round(int(RAM_stats[0]) / 1000,1)
RAM_used = round(int(RAM_stats[1]) / 1000,1)
RAM_free = round(int(RAM_stats[2]) / 1000,1)
# Disk information
DISK_stats = getDiskSpace()
DISK_total = DISK_stats[0]
DISK_used = DISK_stats[1]
DISK_perc = DISK_stats[3]
# system info
SYSTEM_info = getSystem()
# NET infomation
NET_extranet_ip = getExtranetIp()
NET_internet_ip = getIntranetIp().lstrip('')
NET_connect_ssid = getSsid()

if __name__ == '__main__':
    print('-------------------------------------------')
    print("System info ="+str(SYSTEM_info))
    print('-------------------------------------------')
    print('RAM Total = '+str(RAM_total)+' MB')
    print('RAM Used = '+str(RAM_used)+' MB')
    print('RAM Free = '+str(RAM_free)+' MB')
    print('-------------------------------------------')
    print('DISK Total Space = '+str(DISK_total)+'B')
    print('DISK Used Space = '+str(DISK_used)+'B')
    print('DISK Used Percentage = '+str(DISK_perc))
    print('-------------------------------------------')
    print('NET Extranet Ip ='+str(NET_extranet_ip))
    print('NET Connect Ssid ='+str(NET_connect_ssid))
    print('NET Internet Wan Ip ='+str(NET_internet_ip))

</code></pre>

<p>直接调用<code>python sysinfo.py</code>:</p>

<p><img src="http://xiaocao.u.qiniudn.com/blog/2015-04-29-openwrt-sysinfo.png" alt="系统信息"></p>

<p><br></p>

<hr>
<h1>0x06.WRTnode发送邮件</h1>

<p>好了，系统信息有了，GPIO信息有了，接下来就试试发送邮件了。</p>

<p>发送邮件3中法案都可以，Lua，Python，Shell，找了找资料，Python写了，但是缺少了一个包，Lua缺少Luasocket模块，Shell要安装模块。</p>

<p>最后，懵了，全都要依赖，尼玛，看了看，好像Lua安装个Luasocket最简单，一个包轻松： <a rel="nofollow" href="http://see.sl088.com/wiki/Luasocket"></a><a rel="nofollow" href="http://see.sl088.com/wiki/Luasocket">http://see.sl088.com/wiki/Luasocket</a></p>

<p>安装也不难，接下来就写写吧。</p>

<p>Lua发送邮件源码模块，设置文件名为<code>email.lua</code>：</p>

<pre><code>#!/usr/bin/lua
--[[
Copyright 2015 http://homeway.me
@author homeway
@version 15.04.29
@link http://homeway.me
@function lua email module
-- ]]--
local smtp = require("socket.smtp")
local M ={}
M.user = {["from"]="", ["to"]="", ["password"]=""}
M.mail = {["subject"]="", ["body"]=""}
M.sys = {["server"]=""}
M.set = function(data)
    M.user = data.user
    M.mail = data.mail
    M.sys = data.sys    
end
M.send = function()
    rcpt = {
        M.user["to"]
    }
    mesgt = {
        headers = {
            from = M.user["from"],
            to = M.user["to"], --收件人
            cc = "", --抄送 
            subject = M.mail["subject"] --主题
        },
        body = M.mail["body"]
    }
    r, e = smtp.send{
        from = M.user["from"],
        rcpt = rcpt,
        source = smtp.message(mesgt),
        server = M.sys["server"],
        port = M.sys["port"],
        user = M.user["from"],
        password = M.user["password"],
    }
    if not r then
        print(e)
    else
        print("send ok!")
    end
end
return M
</code></pre>

<p>下面是调用方式：</p>

<pre><code>#!/usr/bin/lua
local mail = require("email")
local data = {}
data.user = {["from"]="sender@gmail.com", ["to"]="receiver@gmail.com", ["password"]="password"}
data.mail = {["subject"]="测试邮件模块", ["body"]="这是主体内容..."}
data.sys = {["server"]="smtp.gmail.com", ["port"]=587}

mail.set(data)
mail.send()
</code></pre>

<p>测试下，是可以接收到邮件的，注意GFW，还是别用非法gmail好了，别等半天收不到。</p>

<p><br></p>

<hr>
<h1>0x07.重要的东西放后面</h1>

<p>嗯！看到这里，估计菊花也有点疼了，再看最后一点看完就擦洗擦洗去吧。</p>

<p>最后就是，设置定时器，让路由器定时发送系统信息给指定邮箱。</p>

<p>嗯...定时器，Linux的一个模块crontab命令，看看功能吧 <code>crontab --help</code></p>

<p>关于定时器语法，看看这里吧 <a rel="nofollow" href="http://kvz.io/blog/2007/07/29/schedule-tasks-on-linux-using-crontab/"></a><a rel="nofollow" href="http://kvz.io/blog/2007/07/29/schedule-tasks-on-linux-using-crontab/">http://kvz.io/blog/2007/07/29/schedule-tasks-on-linux-using-crontab/</a></p>

<p>这里，我只做简单地，每隔10分钟发送一次系统信息给我邮箱。</p>

<p>具体怎么做，去下载这个脚本吧：<a rel="nofollow" href="https://github.com/grasses/OpenWRT-Util/blob/master/lua/crontab.lua"></a><a rel="nofollow" href="https://github.com/grasses/OpenWRT-Util/blob/master/lua/crontab.lua">https://github.com/grasses/OpenWRT-Util/blob/master/lua/crontab.lua</a></p>

<p>我的目录是这样的，用户是root：</p>

<pre><code>~|--script
    |--schedule
    |--send
|--log
    |--sys.log
    |--crontab.log
</code></pre>

<p>先开一个定时器，定时跑Lua，Lua调用python读取系统信息，生成日志文件，Lua读取日志文件，发送邮箱。</p>

<p>how to use:<br>
step1: configure you email information in this script<br>
step2: mkdir /root/log &amp;&amp; mkdir /root/script<br>
step3: mv /path/to/crontab.lua /root/script/send<br>
step4: chmod +x /root/script/send<br>
step5: echo 10,20,30,40,50  * * * * /root/script/send &gt; /root/script/schedule<br>
step6: crontab /root/script/schedule</p>

<p>东西有点多，都是散乱的部件，这篇主要介绍细节信息，接下来会做大得模块。</p>

<p>如果打通路由器，各种嵌入式开发的联网问题就都解决了，所以路由器系统还是很重要的。</p>

<p><br></p>

<hr>
<p><br></p>

<h4>本文出自 <a rel="nofollow" href="http:/homeway.me">夏日小草</a>,转载请注明出处： <a rel="nofollow" href="http://homeway.me/2015/04/29/openwrt-develop-base-util/"></a><a rel="nofollow" href="http://homeway.me/2015/04/29/openwrt-develop-base-util/">http://homeway.me/2015/04/29/openwrt-develop-base-util/</a>
</h4>

<h4>by 小草</h4>

<p>2015-04-30 23:59:20</p>

2015年四月30日晚上 9:56:57
VSCode 初体验
<p>Microsoft 今天在其 Build 开发者大会上正式宣布了 Visual Studio Code 项目：一个运行于 OS X，Windows 和 Linux 之上的，针对于编写现代web和云应用的跨平台编辑器。</p>

<p>作为编辑器控的我，得知消息后立马下载体验了一下。Windows上优秀的编辑器实在太多了，<code>Sublime Text</code>，<code>EditPlus</code>，<code>Notepad++</code>......还有诸如国产的<code>EverEdit</code>等后起之秀。所以这次我这次把测评的环境放在了编辑器相对匮乏的Linux桌面上。</p>

<h2>环境&amp;安装</h2>

<ul>
<li>Ubuntu 14.04 LTS</li>
<li>Visual Studio Code 0.1.0</li>
</ul>
<p>主要对比对象是<code>Sublime Text3</code></p>

<pre><code>    wget http://download.microsoft.com/download/0/D/5/0D57186C-834B-463A-AECB-BC55A8E466AE/VSCode-linux-x64.zip

    //注意不要使用归档解压会报错
    unzip  unzip VSCode-linux-x64 -d VS

    //双击VS里的Code就能运行了
</code></pre>

<h2>颜值</h2>

<p><img src="http://7xawrk.com1.z0.glb.clouddn.com/c08cce9034f37cc93fc026bba9a9e326_b.jpg" alt="VSCode"></p>

<p>可以看到VSCode颜值不算太糟糕，绿色的注释散发着一股浓浓的VS的风格，Theme里一共两款主题可以选择，另外一款是白色主题。题外话，我最喜欢的主题是Sublime Text的<code>Monokai</code>。</p>

<h2>性能</h2>

<p>总体来说输入的体验比Sublime Text3稍微要差一点，但是比同类WEB IDE <code>ATOM</code>，<code>Brackets</code>要快太多，ATOM、Brackets已经迭代很多个版本了，VSCode基于ATOM SHELL的，估计ATOM要哭晕在厕所。看到一些网友的测试，在打开大文件上，VSCode已经秒杀了<code>Sublime Text3</code>。</p>

<h2>特性</h2>

<h3>智能提示</h3>

<p>VSCode提供了强大的自动补全、悬浮提示、定义跳转等功能，支持以下语言：</p>

<pre><code>C++, jade, PHP, Python, XML, Batch, F#, DockerFile, Coffee Script, Java, HandleBars, R,Objective-C, PowerShell, Luna, Visual Basic, Markdown
</code></pre>

<p>我测试了下在Javascript、Typscript上体验不错，HTML还支持Angular标签，悬浮提示很详细包括了注解，但是试了下C#貌似没有什么效果，不知道是不是需要特殊的环境。不管怎样，在某些语言上的智能提示已经比其他的同类编辑器已经强太多了，可以和一些IDE媲美。</p>

<p><img src="http://7xawrk.com1.z0.glb.clouddn.com/b3041588c25e63c108d34519c1ed7435_b.jpg" alt="enter image description here"></p>

<p>下面贴几张官网的示例图片:</p>

<p>参数提示：<br><img src="https://code.visualstudio.com/Content/images/editing_evolved_parameterhints.png" alt="enter image description here"></p>

<p>定义跳转：<br><img src="https://code.visualstudio.com/Content/images/editing_evolved_ctrl_hover.png" alt="enter image description here"></p>

<p>引用提示：<br><img src="https://code.visualstudio.com/Content/images/editing_evolved_reference_info.png" alt="enter image description here"></p>

<p>方法定位：<br><img src="https://code.visualstudio.com/Content/images/editing_evolved_symbol.png" alt="enter image description here"></p>

<p>还有其他很酷炫的功能我没测试，大家<a rel="nofollow" href="https://code.visualstudio.com/Docs/editingevolved">官网</a>看吧。</p>

<h3>Markdown</h3>

<p>在Linux桌面上，好用的Markdown编辑器可以说没有，<code>ReText</code>和记事本一样简陋，Sublime Text3虽然可以装插件支持，但是体验不是很好，不支持中文。因此我一直使用的在线Markdown代替。</p>

<p>这回VSCode支持Markdown重新让我看到了点希望。快捷键<code>ctr+shift+v</code>预览，可以看到这个布局还是非常人性化的。</p>

<p><img src="http://7xawrk.com1.z0.glb.clouddn.com/d01756018f5c5bb172180a81522badec_b.jpg" alt="enter image description here"></p>

<p>但是缺点也很明显，首先中文支持不好，编辑器里的中文输入可以改，但是预览还是出现口口，目前找到解决方法。还有不支持快捷键输入，那种像写代码般的快感没有了。没有能自定义CSS的功能，不管在哪种Theme下，<code>&gt;</code> 代码高亮都看不出有什么效果。</p>

<h3>版本控制</h3>

<p>自带了一个git工具，并且放在了一个比较显要的位置上，不过功能不是很全，只能<code>commit</code>等几个操作。自带了类似于git diff的文件比较功能：</p>

<p><img src="http://7xawrk.com1.z0.glb.clouddn.com/ab4461ceb4d7121a0dc7276a0e47c0c4_b.jpg" alt="enter image description here"></p>

<h3>Debug</h3>

<p>Debug需要MONO，所以就没进行测试。详情大家看<a rel="nofollow" href="https://code.visualstudio.com/Docs/debugging">官网</a>吧。</p>

<h2>缺陷</h2>

<h3>中文支持</h3>

<p>默认的字体是不支持中文的，输入中文的时候会出现口口。需要设置一下字体，我使用的是文泉驿，思源也行。</p>

<p>没安装的首先安装这个字体。</p>

<pre><code>sudo apt-get install fonts-wqy-microhei fonts-wqy-zenhei
File -&gt; Preference -&gt; User Settings
//在右侧添加一句：
"editor.fontFamily": "WenQuanYi Micro Hei Mono"
</code></pre>

<p>不过这只能解决编辑器内的中文乱码问题，其他的比如标题栏，markdown预览，该口的还是口。对了还有一点需要注意的是输入法需要是<code>Fctix</code>或者基于<code>Fctix</code>的。</p>

<p>Sublime Text3同样有这问题，事实上Sublime Text3全平台对于中文的支持都不是很好。Linux桌面上的解决方法也是<a rel="nofollow" href="http://my.oschina.net/tsl0922/blog/113495">奇技淫巧</a>。</p>

<h3>插件化</h3>

<p>不过插件化已经提到议程上了，以微软的实力实现这个不难。</p>

<h3>Markdown</h3>

<p>缺陷在上面已经提到了</p>

<h3>设置</h3>

<p>用户设置是直接以JSON形式出现了，虽然说鼠标悬浮上去会看到详细的解释，但还是没有图形化来的简便，而且没有搜索的功能，想要搜索还得以文本的形式复制出来，修改起来略费劲。</p>

<h2>结论</h2>

<p>总体而言，VSCode表现出来的潜力还是不俗的，毕竟还是个预览版，我对接下来的版本比较看好，至少比<code>Brackets</code>要好吧。希望Sublime Text的作者能够更加上心一点，能解决中文问题那就最好了，喜欢Sublime Text3的童鞋们可以看我这篇博文<a rel="nofollow" href="http://reecoblog.info/2015/03/04/my-sublime-text3-setting/">《我的Sublime Text3设置》</a>。</p>

<p>最后，人生苦短，我用<code>geany</code>。</p>

<h2>参考</h2>

<p><a rel="nofollow" href="https://code.visualstudio.com/Docs">https://code.visualstudio.com/Docs</a><br><a rel="nofollow" href="http://www.zhihu.com/question/29984607">http://www.zhihu.com/question/29984607</a></p>

2015年四月30日下午 3:54:11
45个必备的JavaScript Web开发工具
<p>JavaScript是一种灵活多变的脚本语言，它在全世界被广泛的应用在Web页面和服务器应用中。你可以因为任何目的去使用它，但是你需要一些工具。幸运的是，为了完成独特的任务，无以计数的JavaScript工具已经被开发者发布。</p>

<p>这里有45个关于JavaScript的工具，所有这些工具将帮助您创建现代网站与用户所期望的所有特性。它们都提供了精简的设计和简单的接口。。。。</p>

<h2>AngularJS</h2>

<p><a rel="nofollow" href="https://angularjs.org/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/12.jpg" alt="AngularJS"></a><br>
Google创建<a rel="nofollow" href="https://angularjs.org/">AngularJS</a>，目的是提供一个稳定的、轻量级的框架在浏览器中呈现信息。它从服务器收集数据,然后在本地编译模板。换句话说，AngularJS以MVC框架形式来构建在浏览器中运行的HTML、JavaScript和CSS。</p>

<h2>Odyssey.JS</h2>

<p><a rel="nofollow" href="http://cartodb.github.io/odyssey.js/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/13.jpg" alt="Odyssey.JS"></a><br><a rel="nofollow" href="http://cartodb.github.io/odyssey.js/">Odyssey</a> 是一个将故事和地图结合，并绑定了交互文本的工具。图片显示为一个沙箱来构建与地图交互的故事。</p>

<h2>PlayCanvas</h2>

<p><a rel="nofollow" href="https://playcanvas.com/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/14.jpg" alt="PlayCanvas"></a><br><a rel="nofollow" href="https://playcanvas.com/">PlayCanvas</a>是一个围绕WebGL建立的游戏引擎。它把物理、照明、阴影、音频和更多其它特效结合到更一致的工具中,以创建被对象填充的世界。图像显示的是一个针对该框架的在线开发工具。</p>

<h2>Gantt</h2>

<p><a rel="nofollow" href="http://gantt.twproject.com/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/15.jpg" alt="Gantt"></a><br><a rel="nofollow" href="http://gantt.twproject.com/">Gantt</a>是一个基于JQuery构建的JavaScript组件，用于创建图标,任务树和用JSON格式输出结果数据的相关性。它提供了编辑、缩放、数据快捷键,CSS皮肤,等等。</p>

<h2>Handy.JS</h2>

<p><a rel="nofollow" href="http://handyjs.org/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/16.jpg" alt="Handy.JS"></a><br><a rel="nofollow" href="http://handyjs.org/">Handy</a>是一个Nodejs的Web应用模板。Handy提供了一个Web APP所有的基础功能，因此你可以把焦点放在开发让你的APP真正唯一的功能。</p>

<h2>RegExr</h2>

<p><a rel="nofollow" href="http://www.regexr.com/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/17.jpg" alt="RegExr"></a><br><a rel="nofollow" href="http://www.regexr.com/">RegExr</a>是一个在线编辑和测试正则表达式的工具。它提供了一个简单的正则表达式输入界面，并且能实时可视化匹配可编辑的源文本。同时它还提供了一个便捷的RegExp边栏用于描述案例用法。</p>

<h2>TimelineJS</h2>

<p><a rel="nofollow" href="http://timeline.knightlab.com/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/18.jpg" alt="TimelineJS"></a><br><a rel="nofollow" href="http://timeline.knightlab.com/">TimelineJS</a>是一个开源工具，允许任何人建立形象精美的时间轴。初学者可以可以不使用任何东西就能创建一个时间轴。</p>

<h2>Responsive Nav</h2>

<p><a rel="nofollow" href="http://responsive-nav.com/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/19.jpg" alt="Responsive Nav"></a><br><a rel="nofollow" href="http://responsive-nav.com/">Responsive Nav</a>是一个比较小的JavaScript插件，可以帮助你创建针对小屏幕的连续导航。它会利用touch事件和CSS3过渡带来最好的性能。</p>

<h2>Sinon.JS</h2>

<p><a rel="nofollow" href="http://sinonjs.org/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/20.jpg" alt="Sinon.JS"></a><br><a rel="nofollow" href="http://sinonjs.org/">Sinon.JS</a>是一个单独的测试应用，没有依赖关系,适用于任何单元测试框架。</p>

<h2>Mocha</h2>

<p><a rel="nofollow" href="http://mochajs.org/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/21.jpg" alt="Mocha"></a><br><a rel="nofollow" href="http://mochajs.org/">Mocha</a>是一个运行在Nodejs和浏览器上的功能多样的JavaScript测试框架，使异步测试变得简单有趣。</p>

<h2>JS Bin</h2>

<p><a rel="nofollow" href="http://jsbin.com/?html,output"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/22.jpg" alt="JS Bin"></a><br><a rel="nofollow" href="http://jsbin.com/?html,output">JS Bin</a>是一个专门设计用于帮助JavaScript和CSS民间测试的代码片段,在某些上下文中,协作和调试代码的应用。jsbin允许编辑和测试JavaScript和HTML。</p>

<h2>JSLitmus</h2>

<p><a rel="nofollow" href="http://broofa.com/Tools/JSLitmus/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/23.jpg" alt="JSLitmus"></a><br><a rel="nofollow" href="http://broofa.com/Tools/JSLitmus/">JSLitmus</a>,一个轻量级框架，用于创建特别的JavaScript基准测试。</p>

<h2>Bookmarkify</h2>

<p><a rel="nofollow" href="https://bookmarkify.it/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/24.jpg" alt="Bookmarkify"></a><br><a rel="nofollow" href="https://bookmarkify.it/">Bookmarkify</a>使得创建书签工具变得非常简单，仅需要给书签命名，然后输入JavaScript并包含它就可以了。</p>

<h2>Kreate.JS</h2>

<p><a rel="nofollow" href="http://itsjonq.github.io/kreate/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/25.jpg" alt="Kreate.JS"></a><br><a rel="nofollow" href="http://itsjonq.github.io/kreate/">Kreate.JS</a>能够辅助JQuery快速以JQuery对象形式生成DOM元素。你可以“Kreate” 单个元素或者“Kreate”多个元素，直到浏览器奔溃。但多数情况下，Kreate创建单个元素或者多个元素都会比JQuery快。</p>

<h2>YUI Compressor</h2>

<p><a rel="nofollow" href="http://yui.github.io/yuicompressor/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/1.jpg" alt="YUI Compressor"></a><br><a rel="nofollow" href="http://yui.github.io/yuicompressor/">YUI Compressor</a>是用Java创建的命令行工具，用于压缩JavaScript文件。YUI Compressor是100%安全的，并且比其他工具的压缩比高。它也能压缩CSS文件。</p>

<h2>Google Closure Compiler</h2>

<p><a rel="nofollow" href="https://developers.google.com/closure/compiler/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/2.jpg" alt="Google Closure Compiler"></a><br><a rel="nofollow" href="https://developers.google.com/closure/compiler/">Google Closure Compiler</a>能使JavaScript的下载和运行变得更快。它是一个真正针对JavaScript编译的。Google Closure Compiler不是将源语言编译成机器代码,而是从JavaScript编译到更好的JavaScript。</p>

<h2>JSMin</h2>

<p><a rel="nofollow" href="http://crockford.com/javascript/jsmin"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/3.jpg" alt="JSMin"></a><br><a rel="nofollow" href="http://crockford.com/javascript/jsmin">JSMin</a>会删除JavaScript文件中的注释和不必要的空白。它将减少文件一半的尺寸，带来更快的下载速度。它也鼓励更富有表现力的编程风格,因为它消除了下载在精简代码、自文档化方面的成本。</p>

<h2>Packer</h2>

<p><a rel="nofollow" href="http://dean.edwards.name/packer/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/4.jpg" alt="Packer"></a><br><a rel="nofollow" href="http://dean.edwards.name/packer/">Packer</a>是DeanEdwards创建的一个很流行的JavaScript压缩工具，它能自动创建一个压缩版本。只需要粘贴代码，然后点击 ‘Pack’ 按钮。它还能利用JavaScript运行时片进行超常规压缩和动态压缩。</p>

<h2>Meteor</h2>

<p><a rel="nofollow" href="https://www.meteor.com/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/5.jpg" alt="Meteor"></a><br><a rel="nofollow" href="https://www.meteor.com/">Meteor</a>WebApp框架为现代软件开发提供了一个坚实的基础。一些是很实用的，例如拥抱开源社区，促进插件的贡献。Meteor做到了。</p>

<h2>Epoch</h2>

<p><a rel="nofollow" href="http://fastly.github.io/epoch/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/6.jpg" alt="Epoch"></a><br><a rel="nofollow" href="http://fastly.github.io/epoch/">Epoch</a>是一个实时的、用于创建漂亮、平稳流畅和高性能可视化的图表库。<br>
Web Starter Kit<br><a rel="nofollow" href="https://github.com/google/web-starter-kit"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/7.jpg" alt="Web Starter Kit"></a><br><a rel="nofollow" href="https://github.com/google/web-starter-kit">Web Starter Kit</a>是一个致力于协助开发者支持多设备的项目。这意味着通过同步点击、必要时重新加载和保持一切尽可能精简来确保屏幕保持同步。</p>

<h2>Reveal.JS</h2>

<p><a rel="nofollow" href="https://github.com/hakimel/reveal.js/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/8.jpg" alt="Reveal.JS"></a><br><a rel="nofollow" href="https://github.com/hakimel/reveal.js/">Reveal.JS</a>是一个基于HTML5的、很灵活的组件，用于替代PPT。点击按钮，然后复杂的动画会依赖碎片信息而翻转，就跟PPT一样。但是它真正的表现力在与你如何你在你的网络策略中使用它。</p>

<h2>RxJS</h2>

<p><a rel="nofollow" href="http://reactive-extensions.github.io/RxJS/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/9.jpg" alt="RxJS"></a><br><a rel="nofollow" href="http://reactive-extensions.github.io/RxJS/">RxJS</a>是一个为鼠标和键盘添加平滑、反应性的和异步响应生成的事件流。图像显示代码绑定了一个搜索维基百科的事件。</p>

<h2>NodeBB</h2>

<p><a rel="nofollow" href="https://nodebb.org/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/10.jpg" alt="NodeBB"></a><br>
基于节点演化的公告板隐喻是及时和可定制的,并提供实时流的对话。<a rel="nofollow" href="https://nodebb.org/">NodeBB</a>的发展已经添加了更多现代主题，并支持小屏幕的手机和平板。</p>

<h2>Gulp.JS</h2>

<p><a rel="nofollow" href="http://gulpjs.com/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/11.jpg" alt="Gulp.JS"></a><br><a rel="nofollow" href="http://gulpjs.com/">Gulp.JS</a>是一个流构建系统。它使用流和代码配置创建更简单和直观的构建。宁愿选择代码配置,让简单的事情变得简单,使复杂的任务易于管理。</p>

<h2>Contour</h2>

<p><a rel="nofollow" href="http://forio.com/contour/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/26.jpg" alt="Contour"></a><br><a rel="nofollow" href="http://forio.com/contour/">Contour</a>是Forio的一个可视化库，用于提供一组核心的公共可视化功能。建立在受欢迎的D3引擎之上,轮廓让你轻松创建数据可视化和基于常用的图表等直观的抽象。</p>

<h2>Nightwatch.JS</h2>

<p><a rel="nofollow" href="http://nightwatchjs.org/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/27.jpg" alt="Nightwatch.JS"></a><br>
对基于浏览器的APP和网站，<a rel="nofollow" href="http://nightwatchjs.org/">Nightwatch.JS</a>能使用Node.js建立基于端到端的测试解决方案。它使用强大的Selenium WebDriver API在DOM元素上执行命令和断言。</p>

<h2>EasyStar.JS</h2>

<p><a rel="nofollow" href="http://www.easystarjs.com/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/28.jpg" alt="EasyStar.JS"></a><br><a rel="nofollow" href="http://www.easystarjs.com/">EasyStar.JS</a>是一个用JavaScript编写的异步A*寻路API,可应用在HTML5游戏和互动项目。这个项目的目标是使它容易和快速实现性能意识上的寻路。</p>

<h2>Headroom.JS</h2>

<p><a rel="nofollow" href="http://wicky.nillia.ms/headroom.js/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/29.jpg" alt="Headroom.JS"></a><br><a rel="nofollow" href="http://wicky.nillia.ms/headroom.js/">Headroom.JS</a>是一个轻量级、高性能javascript小部件,允许你对用户的滚动做出反应。这个网站的头部就是一个实例,当向下滚动时，头部会滑出视窗，向上滚动时又滑入视窗。</p>

<h2>FileAPI</h2>

<p><a rel="nofollow" href="http://mailru.github.io/FileAPI/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/30.jpg" alt="FileAPI"></a><br><a rel="nofollow" href="http://mailru.github.io/FileAPI/">FileAPI</a>是一组处理所有跟文件相关的工作的组件库。它提供了许多功能，文件上传（单个/多个）、拖放支持、图像裁剪、大小调整、应用过滤器和获取文件信息等等。</p>

<h2>Unminify</h2>

<p><a rel="nofollow" href="http://unminify.com/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/31.jpg" alt="Unminify"></a><br><a rel="nofollow" href="http://unminify.com/">Unminify</a>对于格式化JavaScript、CSS和HTML代码是很有用的工具，并且会让代码变得易读和漂亮。</p>

<h2>HarpJS</h2>

<p><a rel="nofollow" href="http://harpjs.com/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/32.jpg" alt="HarpJS"></a><br><a rel="nofollow" href="http://harpjs.com/">HarpJS</a>是一个静态服务器，在没有任何配置的情况下，也为Jade, Markdown, EJS, Less, Stylus, Sass, CoffeeScript asHTML, CSS和JavaScript 提供服务。它支持爱心式的布局/部分模式,并能灵活的遍历文件系统元数据、全局对象和注入定制数据模板。</p>

<h2>JSHint</h2>

<p><a rel="nofollow" href="http://jshint.com/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/33.jpg" alt="JSHint"></a><br><a rel="nofollow" href="http://jshint.com/">JSHint</a>是一个社区驱动的工具,用于检测JavaScript中的语法错误和潜在的问题，并执行你的团队的编码惯例。</p>

<h2>GruntJS</h2>

<p><a rel="nofollow" href="http://gruntjs.com/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/34.jpg" alt="GruntJS"></a><br><a rel="nofollow" href="http://gruntjs.com/">GruntJS</a>是一个基于任务的命令行JavaScript项目构建工具。下面的预定义的任务,可以直接在你的项目中使用:连接文件、用JSHint验证文件、用UglifyJS压缩文件和用节点单元运行单元测试。</p>

<h2>ZeptoBuilder</h2>

<p><a rel="nofollow" href="http://github.e-sites.nl/zeptobuilder/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/35.jpg" alt="ZeptoBuilder"></a><br><a rel="nofollow" href="http://github.e-sites.nl/zeptobuilder/">ZeptoBuilder</a>是Zepto的一个在线版本，从列表中选取你想包含的文件，就能得到你自定义的构建了。</p>

<h2>Gif.JS</h2>

<p><a rel="nofollow" href="http://jnordberg.github.io/gif.js/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/36.jpg" alt="Gif.JS"></a><br><a rel="nofollow" href="http://jnordberg.github.io/gif.js/">Gif.JS</a>是一个能运行在你的浏览器中的JavaScript GIF编码器。</p>

<h2>Favico.JS</h2>

<p><a rel="nofollow" href="http://lab.ejci.net/favico.js/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/37.jpg" alt="Favico.JS"></a><br><a rel="nofollow" href="http://lab.ejci.net/favico.js/">Favico.JS</a>可以让你为你的图标添加动画徽章,图片,甚至视频,或者从图像、视频,甚至从访问者的摄像头获取的现场图片创建一个图标。</p>

<h2>Chart.JS</h2>

<p><a rel="nofollow" href="http://www.chartjs.org/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/38.jpg" alt="Chart.JS"></a><br><a rel="nofollow" href="http://www.chartjs.org/">Chart.JS</a>生成简单,干净,和基于HTML5的JavaScript图表。它用一种简单的方式，能在你的网站上自由的包含动画、交互式图形。</p>

<h2>AdminJS</h2>

<p><a rel="nofollow" href="http://adminjs.com/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/39.jpg" alt="AdminJS"></a><br><a rel="nofollow" href="http://adminjs.com/">AdminJS</a>是一个独立包含Ember.js的应用，它的两个主要文件是adminjs.js和 adminjs.css。两者都需要和Ember.js和EPF.一起被包含在页面中。</p>

<h2>Sir Trevor</h2>

<p><a rel="nofollow" href="http://madebymany.github.io/sir-trevor-js/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/40.jpg" alt="Sir Trevor"></a><br>
[]Sir Trevor](<a rel="nofollow" href="http://madebymany.github.io/sir-trevor-js/">http://madebymany.github.io/sir-trevor-js/</a>)是一个会完全重绘网页内容的工具：直观的编辑网页内容而不用假定任何关于它是如何重绘的事。</p>

<h2>Instano.JS</h2>

<p><a rel="nofollow" href="http://laucheukhim.github.io/instano/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/41.jpg" alt="Instano.JS"></a><br>
页面加载之后，<a rel="nofollow" href="http://laucheukhim.github.io/instano/">Instano.JS</a>允许你及时检测JavaScript是否可用。它修改了标准的标记以致于不管JavaScript什么时候被禁用，里面的消息都能被显示。</p>

<h2>Resumable.JS</h2>

<p><a rel="nofollow" href="http://www.resumablejs.com/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/43.jpg" alt="Resumable.JS"></a><br><a rel="nofollow" href="http://www.resumablejs.com/">Resumable.JS</a>是一个JavaScript库，通过HTML5 API提供了稳定可恢复的多文件上传功能。</p>

<hr>
<p>英文原文：<a rel="nofollow" href="http://www.developerdrive.com/2015/01/40-essential-javascript-tools-for-the-web/">40+ essential JavaScript tools for the Web</a><br>
译文出处：<a rel="nofollow" href="http://www.ido321.com/1543.html">http://www.ido321.com/1543.html</a></p>

2015年四月30日下午 2:35:43
CentOS 安装 Subversion
<h2>安装依赖</h2>

<p>命令：<code>yum install mod_dav_svn subversion</code></p>

<p>貌似只要安装mod_dav_svn时，就会把subversion和Apache安装上。</p>

<h2>Subversion's Apache 配置</h2>

<p>命令如下：</p>

<pre><code>[root@lucifer ~] cd /etc/httpd/conf.d/
[root@lucifer ~] vim subversion.conf

# 有需要的话，请确定你删除这两行的注释
LoadModule dav_svn_module     modules/mod_dav_svn.so
LoadModule authz_svn_module   modules/mod_authz_svn.so

# 加入下列内容来支持基本验证，并将 Apache 指向实际放置版本库的地方。
&lt;Location /repos&gt;
        DAV svn
        SVNPath /var/www/svn/repos
        AuthType Basic
        AuthName "Subversion repos"
        AuthUserFile /etc/svn-auth-conf
        Require valid-user
&lt;/Location&gt;
</code></pre>

<p>上面的位置是 Apache 在 URL 上使用的。举个例说：<a rel="nofollow" href="http://yourmachine/repos">http://yourmachine/repos</a> 指向你所指定的 SVNPath。上面只是一个样例，因此请按你的首选放置东西。请确定你在完成编辑后存储文件。</p>

<p>然后我们须要创建你在上一步所指定的口令档。开始时你要利用 -cm 这个选项。它会创建文件并用 MD5 将口令加密。如果你需要加用户，请确定你只使用 -m 选项，而不包含初次创建时的 -c。</p>

<h2>设置你的版本库</h2>

<p>你接著要做的事情就是创建你用来提交及取出文件的版本库。利用 svn 所包含的工具，这是很容易的。</p>

<pre><code>[root@lucifer ~] cd /var/www/ —— 或者你在上面所指定的路径
[root@lucifer ~] mkdir svn
[root@lucifer ~] cd svn
[root@lucifer ~] svnadmin create repos
[root@lucifer ~] chown -R apache.apache repos  （这步很重要）
[root@lucifer ~] service httpd restart
</code></pre>

<p>现在去测试你能否通过网页浏览器访问你的版本库：<a rel="nofollow" href="http://yourmahcine/repos">http://yourmahcine/repos</a> 。你应该取得一个对话框询问用户名称及口令。若然是这样，请输入你的凭证，然后你应该看见一版 Revision 0:/ 的页面。这样的话，版本库的设置便大工告成了。如果你须要多个版本库，请参考上面连结内的文档。这里只示范如何设置一个版本库及开始应用它。话说回来，让我们就这样做。</p>

<h2>参考</h2>

<p>英文原文：<a rel="nofollow" href="http://wiki.centos.org/HowTos/Subversion">http://wiki.centos.org/HowTos/Subversion</a><br>
中文翻译：<a rel="nofollow" href="http://wiki.centos.org/zh/HowTos/Subversion">http://wiki.centos.org/zh/HowTos/Subversion</a><br>
CentOS搭建Nginx+Subversion环境：<a rel="nofollow" href="http://www.opstool.com/article/282">http://www.opstool.com/article/282</a><br>
CentOS Linux搭建SVN Server配置详解：<a rel="nofollow" href="http://www.ha97.com/4467.html">http://www.ha97.com/4467.html</a></p>

2015年四月30日下午 2:20:27
美国大数据创业公司总结
<p>最近调研了一下美国的大数据创业公司，总结如下，如有疏漏，欢迎反馈指正(boyang798@gmail.com)。</p>

<table>
<thead><tr>
<th>公司</th>
  <th>成立时间</th>
  <th>技术亮点</th>
  <th>IPO或者收购</th>
</tr></thead>
<tbody>
<tr>
<td>hortonworks.com</td>
  <td>June, 2011</td>
  <td>三大主要Hadoop平台提供商之一, 提供Windows平台Hadoop支持</td>
  <td>IPO，Dec 11, 2014</td>
</tr>
<tr>
<td>cloudera.com</td>
  <td>October, 2008</td>
  <td>三大主要Hadoop平台提供商之一, 用户基数最大的Hadoop平台</td>
  <td></td>
</tr>
<tr>
<td>mapr.com</td>
  <td>July, 2009</td>
  <td>三大主要Hadoop平台提供商之一, 实现自己的Linux文件系统来提升Hadoop速度</td>
  <td></td>
</tr>
<tr>
<td>databricks.com</td>
  <td>September，2013</td>
  <td>创立Apache Spark，提升Hadoop速度10倍，同时提供优于MapReduce的编程模型</td>
  <td></td>
</tr>
<tr>
<td>datameer.com</td>
  <td>September, 2009</td>
  <td>提供端到端（从数据收集到数据可视化）的一站式大数据分析平台</td>
  <td></td>
</tr>
<tr>
<td>palantir.com</td>
  <td>January, 2004</td>
  <td>自有技术，着重于非机构化数据深度分析，初期以政府客户为主，后扩展到银行和金融领域</td>
  <td></td>
</tr>
<tr>
<td>splunk.com</td>
  <td>October, 2003</td>
  <td>大规模机器数据（日志）收集，存储，可视化分析</td>
  <td>IPO，Apr 19, 2012</td>
</tr>
<tr>
<td>vertica.com</td>
  <td>May, 2005</td>
  <td>基于列存储的数据库技术，提升数据仓库查询速度，注重MPP(massively parallel processing),企业级Hadoop方案和SQL on Hadoop</td>
  <td>被Hewlett-Packard收购，February 14, 2011</td>
</tr>
<tr>
<td>autonomy.com</td>
  <td>January, 1996</td>
  <td>自有非Hadoop大数据技术，非主流技术，但是比较有特色</td>
  <td>被Hewlett-Packard收购，August 18, 2011，但是被业界认为是HP的一个失败收购案例</td>
</tr>
<tr>
<td>teradata.com</td>
  <td>July, 1979</td>
  <td>老牌传统数据仓库提供商，扩展业务到Hadoop平台</td>
  <td>December 1991被NCR收购，之后又由NCR公司剥离，作为单独的上市公司，Oct 5, 2007</td>
</tr>
<tr>
<td>jaspersoft.com</td>
  <td>June, 2001</td>
  <td>侧重于商务数据分析报表，提供移动端的报表工具</td>
  <td>被TIBCO Software收购，April 28, 2014</td>
</tr>
<tr>
<td>karmasphere.com</td>
  <td>April, 2010</td>
  <td>基于Hadoop的解决方案和数据可视化分析</td>
  <td>被FICO收购，April 2014</td>
</tr>
<tr>
<td>domo.com</td>
  <td>October, 2010</td>
  <td>提供数据分析云服务平台</td>
  <td></td>
</tr>
<tr>
<td>talend.com</td>
  <td>September, 2005</td>
  <td>提供多种数据集成服务</td>
  <td></td>
</tr>
<tr>
<td>qubole.com</td>
  <td>December, 2014</td>
  <td>提供Hadoop云平台服务</td>
  <td></td>
</tr>
<tr>
<td>treasuredata.com</td>
  <td>December, 2011</td>
  <td>提供大数据存储，查询，分析云服务</td>
  <td></td>
</tr>
<tr>
<td>platfora.com</td>
  <td>June, 2011</td>
  <td>端到端一站式大数据平台解决方案，基于Hadoop和Spark</td>
  <td></td>
</tr>
<tr>
<td>interana.com</td>
  <td>January, 2013</td>
  <td>自服务数据分析平台，侧重于面向事件的数据</td>
  <td></td>
</tr>
<tr>
<td>gridgain.com</td>
  <td>May, 2005</td>
  <td>基于内存的大数据实时处理系统</td>
  <td></td>
</tr>
<tr>
<td>metamarkets.com</td>
  <td>May, 2010</td>
  <td>在线广告领域内数据实时处理分析平台</td>
  <td></td>
</tr>
<tr>
<td>pivotal.io</td>
  <td>April, 2013</td>
  <td>大数据集成产品，提供Hadoop，内存Non-SQL数据库，RabbitMQ，以及Greenplum MPP(massively parallel processing)等多种服务</td>
  <td></td>
</tr>
<tr>
<td>fiscalnote.com</td>
  <td>April, 2013</td>
  <td>使用大数据和人工智能技术预测立法机构的投票结果</td>
  <td></td>
</tr>
<tr>
<td>dato.com</td>
  <td>May, 2013</td>
  <td>专注于机器学习的数据处理平台，非hadoop技术，底层用C++实现，从GraphLab（graph based framework）发展而来</td>
  <td></td>
</tr>
</tbody>
</table>
<hr>
<p>除了以上大数据公司外，还有很多各具特色的公司，比如专门提供Non-SQL数据库的公司：</p>

<table>
<thead><tr>
<th>Non-SQL数据库</th>
  <th>公司</th>
</tr></thead>
<tbody>
<tr>
<td>Cassandra</td>
  <td>datastax.com</td>
</tr>
<tr>
<td>MongoDB</td>
  <td>mongodb.com</td>
</tr>
<tr>
<td>Couchbase</td>
  <td>couchbase.com</td>
</tr>
<tr>
<td>FoundationDB</td>
  <td>foundationdb.com</td>
</tr>
</tbody>
</table>
<hr>
<p>其它还有很多提供商务数据分析，可视化报表，大数据平台的公司，就不详细例举了，包括：Tableau, GoodData, ZoomData, SpagoBI, Pentaho, Eclipse BIRT, birst, netezza, paraccel, Ayasdi, Trifecta, Clearstory, Alpine Data Labs, Altiscale, Trifacta, Splice Machine, DataTorrent, Continuuity, Xplenty, Aerospike, snowflake.net, SumAll, Tamr, wibidata</p>

<hr>
<p>从对美国大数据市场的调研来看，我们可以得到一些启示：</p>

<ol>
<li><p>美国的数据分析市场非常大，容纳超过30家公司，这得益于美国信息化的高度发达。</p></li>
<li><p>虽然有很多公司，但是大家很少有重复竞争，每一家都有自己的特色，在自己的领域内发展，这也符合美国公司注重差异化相关。</p></li>
<li><p>传统的商务数据分析公司在维持旧有客户和平台的情况下，在积极向大数据技术扩展。</p></li>
<li><p>新兴的大数据技术发展非常快，但是目前还没有到成熟阶段，除了Hadoop之外，没有其他统一的技术被各家公司采用。</p></li>
<li><p>新的大数据技术趋势是快速响应，开始追求数据的实时处理和快速查询。</p></li>
</ol>
<hr>
<p>相对于美国市场，中国的大数据市场还处于非常初期的阶段，这可能跟中国的信息化程度相关。做长期展望预测，如果中国的信息化发展到美国的阶段，并且公司普遍采用基于数据的量化决策机制，将会迎来一个大数据发展的爆发式增长。</p>

<p>扫描微信二维码联系作者<br><img src="http://s3-us-west-1.amazonaws.com/wechatboyang/qrcode/BoYangWeChatQRCode.jpg" alt="扫描微信二维码联系作者"></p>

2015年四月30日上午 10:49:50
提问的智慧
<h2>案例</h2>

<blockquote>
  <p>我想要一个XX的完美实现，各位大神谁能说下怎样实现？</p>
</blockquote>

<p>PS:我看到这个问题的内容，冲动的就想把它删了，根本都不会去考虑怎么回答。你这是问题吗？</p>

<hr>
<blockquote>
  <p><em>以下省略1大段描述</em>，<em>这里有个截图显示的是一些code</em>，请问大家这样的错误是怎么回事？</p>
</blockquote>

<p>PS:X。。。你这是想害死人的节奏啊，问题中的code用截图，是你省事了还是想害死给你解答问题的人？我们连在其他地方try一下的机会都没有了，除非按照截图一个字母一个字母的敲，这是有多大的仇？</p>

<hr>
<blockquote>
  <p>mysql连接显示"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"，我调用了XXXXXX，但还是出现这个错误，请帮忙解决。</p>
</blockquote>

<p>PS:多点描述会死吗？</p>

<p>之后如果你有耐心的话，就和题主挤牙膏吧！问一句答一句，这是贴吧！不是问答。</p>

<hr>
<blockquote>
  <p>请问各位大神，怎样实现XXXXXXX？……</p>
</blockquote>

<blockquote>
  <p>我遇到了一个XXXXX问题……</p>
</blockquote>

<p>PS:经常性的看到很多的问题，竟然找度娘都能搜到答案，可是为啥题主就不知道看看？</p>

<hr>
<p>还遇到过不同的3个人，发的相同的3个问题，这是刷分的节奏吗？特地等了很久没看到有人会回复，试着回了一下，没有任何的相应。。这是什么意思？</p>

<hr>
<p>难道说答题的人就没事了吗？不是！</p>

<p>碰到过一个问题，就上面截图的例子，我因为觉得奇葩，一个字母一个字母敲的，最后为了省事和题主的命名不太一样，写了例子发了截图来证明没问题。竟然被其他答复者踩，说我这样命名不对，和题主相同的命名才会有问题。好吧，我承认因为自己懒，这么做了有问题？就改一下试试，但我试过之后证明这个答复者说的话是错的，和题主相同命名也不会有问题。没有责任心的答复亏你发的出来！</p>

<hr>
<h2>警语</h2>

<p>看到一个描述不明确的问题，现在懒得和挤牙膏一样慢慢的挤了，但是多天过去后还是没人答复问题，我总是会多余的问一下，不是想说自己怎么样，只是因为我有遇到紧急问题时的经历知道那是一种什么样的心态。</p>

<p>答复你的人，可能是正在工作，可能加班回家休息刚起床，又可能是个脱离了技术岗位的热心人士……总之答复你的人，没有任何义务在你提出问题后答复你问题！有人说有积分哦！积分算个P！多少人真不是看中积分才回答你的，大家都是从一个问题又一个问题走过来的，都明白遇到了解决不了问题的心情，技术注重的是交流，所以才会有这个平台的市场来供大家交流。</p>

<p><strong>我想奉劝大家，提问要有智慧！哪怕你再着急，也要言之有物，越着急越应该把所有相关的信息列出来，这样才会让其他人在空闲的时间看到问题思考后，给你一个答复，而不是把所有的时间都费在"挤牙膏"身上！</strong></p>

2015年四月30日早上 7:18:00
你真的弄明白 new 了吗
<p>好久没有写点东西了，总觉得自己应该写点牛逼的，却又不知道如何下笔。既然如此，还是回归最基本的吧，今天就来说一说这个<code>new</code>。关于javascript的<code>new</code>关键字的内容上网搜一搜还真不少，大家都说<code>new</code>干了3件事：</p>

<ul>
<li>创建一个空对象</li>
<li>将空对象的<code>__proto__</code>指向构造函数的<code>prototype</code>
</li>
<li>使用空对象作为上下文调用构造函数</li>
</ul>
<p>文字比较难懂，翻译成javascript：</p>

<pre><code>javascript</code><code>function Base() {
    this.str = "aa";
}

// new Base()干了下面的事
var obj  = {};
obj.__proto__ = Base.prototype;
Base.call(obj);
</code></pre>

<p>想想是这么回事哈，那就赶快试试：</p>

<pre><code>javascript</code><code>var b = new Base();
console.dir(b); // Base {str: 'aa', __proto__: Base}
</code></pre>

<p>好像是正确的，但是真的正确吗？？？</p>

<h2>真的就3件事？</h2>

<p>每个对象都有一个<code>constructor</code>属性，那么我们来试试看<code>new</code>出来的实例的<code>constructor</code>是什么吧。</p>

<pre><code>javascript</code><code>console.dir(b.constructor); // [Function: Base]
</code></pre>

<p>可以看出实例b的<code>constructor</code>属性就是<code>Base</code>，那么我们可以猜测<code>new</code>是不是至少还做了第4件事：</p>

<pre><code>javascript</code><code>b.constructor = Base;
</code></pre>

<p>以上结果看似正确，下面我们进行一点修改，这里我们修改掉原型的<code>constructor</code>属性：</p>

<pre><code>javascript</code><code>Base.prototype.constructor = function Other(){ };
var b = new Base();
console.dir(b.constructor); // [Function: Other]
</code></pre>

<p>情况就不一样了，可以看出，之前的猜测是错误的，第4件事应该是这样的：</p>

<pre><code>javascript</code><code>b.constructor = Base.prototype.constructor;
</code></pre>

<p>这里犯了一个错误，那就是没有理解好这个<code>constructor</code>的实质：<strong>当我们创建一个函数时，会自动生成对应的原型，这个原型包含一个<code>constructor</code>属性</strong>，使用<code>new</code>构造的实例，可以通过原型链查找到<code>constructor</code>。如下图所示：</p>

<p><img src="/img/bVlzPC" alt="constructor"></p>

<p>这里非常感谢<a rel="nofollow" href="http://segmentfault.com/u/zonxin">zonxin</a>同学指出我的错误。</p>

<h2>如果构造函数有返回值呢？</h2>

<p>一般情况下构造函数没有返回值，但是我们依旧可以得到该对象的实例；如果构造函数有返回值，凭直觉来说情况应该会不一样。我们对于之前的构造函数进行一点点修改：</p>

<pre><code>javascript</code><code>function Base() {
    this.str = "aa";
    return 1;
    // return "a";
    // return true;
}
var b = new Base();
console.dir(b); // { str: 'aa'}
</code></pre>

<p>我们在构造函数里设置的返回值好像没什么用，返回的还是原来对象的实例，换一些例子试试：</p>

<pre><code>javascript</code><code>function Base() {
    this.str = "aa";
    return [1];
    // return {a:1};
}
var b = new Base();
console.dir(b); // [1] or {a: 1}
</code></pre>

<p>此时结果就不一样了，从上面的例子可以看出，<strong>如果构造函数返回的是原始值，那么这个返回值会被忽略，如果返回的是对象，就会覆盖构造的实例</strong>。</p>

<h2>new至少做了4件事</h2>

<p>总结一下，<code>new</code>至少做了4件事：</p>

<pre><code>javascript</code><code>// new Base();

// 1.创建一个空对象 obj
var obj = {};
// 2.设置obj的__proto__为原型
obj.__proto__ = Base.prototype;
// 3.使用obj作为上下文调用Base函数
var ret = Base.call(obj);
// 4.如果构造函数返回的是原始值，那么这个返回值会被忽略，如果返回的是对象，就会覆盖构造的实例
if(typeof ret == 'object'){
    return ret;
} else {
    return obj;
}
</code></pre>

<h2>new的不足</h2>

<p>在《Javascript语言精粹》（Javascript: The Good Parts）中，道格拉斯认为应该避免使用<code>new</code>关键字：</p>

<blockquote>
  <p>If you forget to include the new prefix when calling a constructor function, then this will not be bound to the new object. Sadly, this will be bound to the global object, so instead of augmenting your new object, you will be clobbering global variables. That is really bad. There is no compile warning, and there is no runtime warning.</p>
</blockquote>

<p>大意是说在应该使用<code>new</code>的时候如果忘了<code>new</code>关键字，会引发一些问题。最重要的问题就是影响了原型查找，原型查找是沿着<code>__proto__</code>进行的，而任何函数都是<code>Function</code>的实例，一旦没用使用<code>new</code>，你就会发现什么属性都查找不到了，因为相当于直接短路了。如下面例子所示，没有使用<code>new</code>来创建对象的话，就无法找到原型上的fa1属性了：</p>

<pre><code>javascript</code><code>function F(){ }
F.prototype.fa1 = "fa1";

console.log(F.fa1);       // undefined
console.log(new F().fa1); // fa1
</code></pre>

<p>这里我配合一张图来说明其中原理，黄色的线为原型链，使用<code>new</code>构造的对象可以正常查找到属性<code>fa1</code>，没有使用<code>new</code>则完全走向了另外一条查找路径：</p>

<p><img src="/img/bVlztF" alt="原型查找"></p>

<p>以上的问题对于有继承的情况表现得更为明显，沿着原型链的方法和属性全都找不到，你能使用的只有短路之后的<code>Function.prototype</code>的属性和方法了。</p>

<p>当然了，遗忘使用任何关键字都会引起一系列的问题。再退一步说，这个问题是完全可以避免的：</p>

<pre><code>javascript</code><code>function foo()
{   
   // 如果忘了使用关键字，这一步骤会悄悄帮你修复这个问题
   if ( !(this instanceof foo) )
      return new foo();

   // 构造函数的逻辑继续……
}
</code></pre>

<p>可以看出<code>new</code>并不是一个很好的实践，道格拉斯将这个问题描述为：</p>

<blockquote>
  <p>This indirection was intended to make the language seem more familiar to classically trained programmers, but failed to do that, as we can see from the very low opinion Java programmers have of JavaScript. JavaScript’s constructor pattern did not appeal to the classical crowd. It also obscured JavaScript’s true prototypal nature. As a result, there are very few programmers who know how to use the language effectively.</p>
</blockquote>

<p>简单来说，JavaScript是一种prototypical类型语言，在创建之初，是为了迎合市场的需要，让人们觉得它和Java是类似的，才引入了<code>new</code>关键字。Javascript本应通过它的Prototypical特性来实现实例化和继承，但<code>new</code>关键字让它变得不伦不类。</p>

<h2>再说一点关于constructor的</h2>

<p>虽然使用<code>new</code>创建新对象的时候用讨论了这个<code>constructor</code>属性，但是这个属性似乎并没有什么用，也许设置这个属性就是一种习惯，能够让其他人直观理解对象之间的关系。</p>

<p>欢迎光临小弟博客：<a rel="nofollow" href="http://blog.liuwanlin.info/">Superlin's Blog</a><br>
我的博客原文：<a rel="nofollow" href="http://blog.liuwanlin.info/newzhi-shao-gan-liao-5jian-shi/">你真的弄明白new了吗</a></p>

<h2>参考</h2>

<ul>
<li><a rel="nofollow" href="http://coolshell.cn/articles/6668.html">再谈javascript面向对象编程</a></li>
<li><a rel="nofollow" href="http://www.infoq.com/cn/articles/javascript-instantiation-and-inheritance">JavaScript的实例化与继承：请停止使用new关键字</a></li>
</ul>

2015年四月29日晚上 9:08:52
地图移动应用实战：Ionic ElasticSearch 搜索服务
<p>在上一篇<a rel="nofollow" href="http://www.phodal.com/blog/django-elasticsearch-ionic-build-gis-application-create-model/">《GIS 移动应用实战 —— Django Haystack ElasticSearch 构建》</a>中，我们构建了我们的服务端，可以通过搜索搜索到结果，这一篇，我们来构建一个简单的搜索。</p>

<p>最后效果如下图所示:</p>

<p><img src="http://www.phodal.com/static/media/uploads/ionic_elasticsearch_search_view.jpg" alt="Ionic ElasticSearch"></p>

<h2>开始之前</h2>

<p>如果你没有Ionic的经验，可以参考一下之前的一些文章:<a rel="nofollow" href="http://www.phodal.com/blog/ionic-development-android-ios-windows-phone-application/">《HTML5打造原生应用——Ionic框架简介与Ionic Hello World》</a>。</p>

<p>我们用到的库有:</p>

<ul>
<li>elasticsearch</li>
<li>ionic</li>
<li>ngCordova</li>
</ul>
<p>将他们添加到<code>bower.json</code>，然后</p>

<pre><code>bower install
</code></pre>

<p>吧</p>

<h2>Ionic ElasticSearch 创建页面</h2>

<p>1.引入库</p>

<p>在<code>index.html</code>中添加</p>

<pre><code>&lt;script src="lib/elasticsearch/elasticsearch.angular.min.js"&gt;&lt;/script&gt;
&lt;script src="lib/ngCordova/dist/ng-cordova.js"&gt;&lt;/script&gt;
</code></pre>

<p>接着开始写我们的搜索模板<code>tab-search.html</code></p>

<pre><code>html</code><code>    &lt;ion-view view-title="搜索" ng-controller="SearchCtrl"&gt;
        &lt;ion-content&gt;
            &lt;div id="search-bar"&gt;
                &lt;div class="item item-input-inset"&gt;
                    &lt;label class="item-input-wrapper" id="search-input"&gt;
                        &lt;i class="icon ion-search placeholder-icon"&gt;&lt;/i&gt;
                        &lt;input type="search" placeholder="Search" ng-model="query" ng-change="search(query)" autocorrect="off"&gt;
                    &lt;/label&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/ion-content&gt;
    &lt;/ion-view&gt;
</code></pre>

<p>显示部分</p>

<pre><code>xml</code><code> &lt;ion-list&gt;
                &lt;ion-item class="item-remove-animate item-icon-right" ng-repeat="result in results"&gt;
                    &lt;h2 class="icon-left"&gt;{{result.title}}&lt;/h2&gt;
                    &lt;p&gt;简介: {{result.body}}&lt;/p&gt;
                    &lt;div class="icon-left ion-ios-home location_info"&gt;
                        {{result.location_info}}
                    &lt;/div&gt;
                    &lt;div class="button icon-left ion-ios-telephone button-calm button-outline"&gt;
                        &lt;a ng-href="tel: {{result.phone_number}}"&gt;{{result.phone_number}}&lt;/a&gt;
                    &lt;/div&gt;
                &lt;/ion-item&gt;
            &lt;/ion-list&gt;
</code></pre>

<p>而我们期待的<code>SearchCtrl</code>则是这样的</p>

<pre><code>$scope.query = "";
var doSearch = ionic.debounce(function(query) {
    ESService.search(query, 0).then(function(results){
        $scope.results = results;
    });
}, 500);

$scope.search = function(query) {
    doSearch(query);
}
</code></pre>

<p>当我们点下搜索的时候，调用 ESService.</p>

<h2>Ionic ElasticSearch Service</h2>

<p>接着我们就来构建我们的ESService，下面的部分来自网上:</p>

<pre><code>angular.module('starter.services', ['ngCordova', 'elasticsearch'])

.factory('ESService',
  ['$q', 'esFactory', '$location', '$localstorage', function($q, elasticsearch, $location, $localstorage){
    var client = elasticsearch({
      host: $location.host() + ":9200"
    });

    var search = function(term, offset){
      var deferred = $q.defer(), query, sort;
      if(!term){
        query = {
          "match_all": {}
        };
      } else {
        query = {
          match: { title: term }
        }
      }

      var position = $localstorage.get('position');

      if(position){
        sort = [{
          "_geo_distance": {
            "location": position,
            "unit": "km"
          }
        }];
      } else {
        sort = [];
      }

      client.search({
        "index": 'haystack',
        "body": {
          "query": query,
          "sort": sort
        }
      }).then(function(result) {
        var ii = 0, hits_in, hits_out = [];
        hits_in = (result.hits || {}).hits || [];
        for(;ii &lt; hits_in.length; ii++){
          var data = hits_in[ii]._source;
          var distance = {};
          if(hits_in[ii].sort){
            distance = {"distance": parseFloat(hits_in[ii].sort[0]).toFixed(1)}
          }
          angular.extend(data, distance);
          hits_out.push(data);
        }
        deferred.resolve(hits_out);
      }, deferred.reject);

      return deferred.promise;
    };


    return {
      "search": search
    };
  }]
);
</code></pre>

<p>这个Service主要做的是创建ElasitcSearch Query，然后返回解析结果。</p>

<h2>运行</h2>

<p>如果是要在真机上运行，需要处于同一网段，或者是部署到服务器上。</p>

<h2>其他</h2>

<p>服务端代码: <a rel="nofollow" href="https://github.com/phodal/django-elasticsearch"></a><a rel="nofollow" href="https://github.com/phodal/django-elasticsearch">https://github.com/phodal/django-elasticsearch</a><br>
客户端代码: <a rel="nofollow" href="https://github.com/phodal/ionic-elasticsearch"></a><a rel="nofollow" href="https://github.com/phodal/ionic-elasticsearch">https://github.com/phodal/ionic-elasticsearch</a></p>

2015年四月29日晚上 9:05:33
SegmentFault for Android.
<blockquote>
  <p>我用尽一生的好运气去遇见你。<br>
  所幸，这运气够长够远，足够我陪你一辈子。</p>
</blockquote>

<h3>非常荣幸的告诉大家，SegmentFault For Android 1.0 已经在以下市场发布</h3>

<ol>
<li><a rel="nofollow" href="https://play.google.com/store/apps/details?id=com.segmentfault.app">Google Play</a></li>
<li><a rel="nofollow" href="http://www.wandoujia.com/apps/com.segmentfault.app">豌豆荚</a></li>
<li><a rel="nofollow" href="http://sj.qq.com/myapp/detail.htm?apkName=com.segmentfault.app">应用宝</a></li>
<li><a rel="nofollow" href="http://app.mi.com/detail/93605">小米</a></li>
<li>360</li>
</ol>
<p>现在大家可以在已经发布的市场中搜索我们的App进行试用啦~</p>

<blockquote>
  <p>如果SegmentFault是一本书，您就是那唯一能领略它墨香的读者，只为您散尽芳华。<br>
  如果SegmentFault是一束向日葵，您就是那一缕明媚的阳光，只因日出盛放。<br>
  如果SegmentFault是一行诗，您就是那一壶陈酿，只为醇香刻下所有的时光。</p>
</blockquote>

<p>反馈请点 <a rel="nofollow" href="https://github.com/SegmentFault/report">https://github.com/SegmentFault/report</a></p>

<p>感谢有你。</p>

<blockquote>
  <p>Build By Developers.<br>
  Build For Developers.</p>
</blockquote>

2015年四月29日晚上 8:01:18
从外网 SSH 进局域网，反向代理+正向代理解决方案
<p>相信很多同学都会碰到这样一个问题。在实验室有一台机器用于日常工作，当我回家了或者回宿舍之后因为没法进入内网，所以访问不到了。如果这个时候我需要 SSH 进去做一下工作，那么怎么解决这个问题呢？本文将给出一种使用 SSH 的代理功能的解决方案。</p>

<h2>问题描述：</h2>

<h3>机器状况</h3>

<table>
<thead><tr>
<th>机器号</th>
  <th>IP</th>
  <th>用户名</th>
  <th>备注</th>
</tr></thead>
<tbody>
<tr>
<td>A</td>
  <td>192.168.0.A</td>
  <td>usr_a</td>
  <td>目标服务器，在局域网中，可以访问 A</td>
</tr>
<tr>
<td>B</td>
  <td>B.B.B.B</td>
  <td>usr_b</td>
  <td>代理服务器，在外网中，无法访问 A</td>
</tr>
<tr>
<td>C</td>
  <td>-</td>
  <td>-</td>
  <td>可以直接访问 B，无法直接访问 A</td>
</tr>
</tbody>
</table>
<h3>目标</h3>

<p>从 C 机器使用 SSH 访问 A</p>

<h2>解决方案</h2>

<p>在 A 机器上做到 B 机器的反向代理；在 B 机器上做正向代理本地端口转发</p>

<h3>环境需求</h3>

<ul>
<li>每台机器上都需要 SSH 客户端</li>
<li>
<p>A、B 两台机器上需要 SSH 服务器端。通常是 openssh-server。</p>

<p>在 Ubuntu 上安装过程为</p>

<pre><code>bash</code><code>sudo apt-get install openssl-server
</code></pre>
</li>
</ul>
<h3>实施步骤</h3>

<ol>
<li>
<p>建立 A 机器到 B 机器的反向代理【A 机器上操作】</p>

<pre><code>bash</code><code>ssh -fCNR &lt;port_b1&gt;:localhost:22 usr_b@B.B.B.B
</code></pre>

<p><code>&lt;port_b1&gt;</code> 为 B 机器上端口，用来与 A 机器上的22端口绑定。</p>
</li>
<li>
<p>建立 B 机器上的正向代理，用作本地转发。做这一步是因为绑定后的  端口只支持本地访问【B 机器上操作】</p>

<pre><code>bash</code><code>ssh -fCNL "*:&lt;port_b2&gt;:localhost:&lt;port_b1&gt;' localhost
</code></pre>

<p><code>&lt;port_b2&gt;</code> 为本地转发端口，用以和外网通信，并将数据转发到 <code>&lt;port_b1&gt;</code>，实现可以从其他机器访问。</p>

<p>其中的<code>*</code>表示接受来自任意机器的访问。</p>
</li>
<li>
<p>现在在 C 机器上可以通过 B 机器 ssh 到 A 机器</p>

<pre><code>bash</code><code>ssh -p &lt;portb2&gt; usra@B.B.B.B
</code></pre>
</li>
</ol>
<p>至此方案完成。</p>

<p>附：</p>

<h3>SSH 参数解释</h3>

<pre><code>-f 后台运行
-C 允许压缩数据
-N 不执行任何命令
-R 将端口绑定到远程服务器，反向代理
-L 将端口绑定到本地客户端，正向代理
</code></pre>

2015年四月29日晚上 6:05:19
使用Gulp来加速你的开发
<p>Gulp与Grunt一样，也是一个自动任务运行器。它充分借鉴了Unix操作系统的管道（pipe）思想，在操作上，它要比Grunt简单。</p>

<h2>安装</h2>

<p>Gulp需要<strong>全局安装</strong>，然后<strong>再在项目的开发目录中安装为本地模块</strong>。先进入项目目录，运行下面的命令。</p>

<pre><code>bash</code><code>npm install -g gulp
npm install --save-dev gulp
</code></pre>

<h2>gulpfile.js</h2>

<p>项目根目录中的gulpfile.js，是Gulp的配置文件。它大概是下面的样子。</p>

<pre><code>javascript</code><code>var gulp = require('gulp');
gulp.task('default', function () {
});
</code></pre>

<p>举个栗子，我们要实现js的压缩。</p>

<pre><code>javascript</code><code>var gulp = require('gulp'),
   uglify = require('gulp-uglify');

gulp.task('minify', function () {
   gulp.src('js/app.js')
      .pipe(uglify())
      .pipe(gulp.dest('app.min'))
});
</code></pre>

<p>上面代码中使用了gulp-uglify模块。在此之前，需要先安装这个模块。<br>
记住在安装之前先 运行 <code>npm init</code> 来生成package.json，如果已经有了就不需要这一步了。</p>

<pre><code>bash</code><code>npm install --save-dev gulp-uglify
</code></pre>

<p><strong>Tips</strong>： --save-dev  会将 gulp-uglify 自动添加到package.json的devDependencies中；</p>

<p>gulpfile.js加载gulp和gulp-uglify模块之后，使用gulp模块的task方法指定任务。task方法有两个参数，第一个是<strong>任务名</strong>，第二个是<strong>任务函数</strong>。在任务函数中，使用gulp模块的src方法，指定所要处理的文件，然后使用pipe方法，将上一步的输出转为当前的输入，进行链式处理。</p>

<p>在上面代码中，使用两次pipe方法，也就是说做了两种处理。第一种处理是使用gulp-uglify模块，压缩源码；第二种处理是使用gulp模块的dest方法，将上一步的输出写入本地文件，这里是app.min.js（代码中省略了后缀名js）。</p>

<p>从上面的例子中可以看到，gulp充分使用了“管道”思想，就是一个数据流（stream）：src方法读入文件产生数据流，dest方法将数据流写入文件，中间是一些中间步骤，每一步都对数据流进行一些处理。</p>

<h2>gulp.src()</h2>

<p>gulp模块的src方法，用于产生数据流。它的参数表示所要处理的文件，一般有以下几种形式。</p>

<ul>
<li>js/app.js：指定确切的文件名。</li>
<li>js/*.js：某个目录所有后缀名为js的文件。</li>
<li>js/**/*.js：某个目录及其所有子目录中的所有后缀名为js的文件。</li>
<li>!js/app.js：除了js/app.js以外的所有文件。</li>
<li>*.+(js|css)：匹配项目根目录下，所有后缀名为js或css的文件。</li>
</ul>
<p>src方法的参数还可以是一个数组，用来指定多个成员。</p>

<pre><code>javascript</code><code><br>gulp.src(['js/**/*.js', 'css/**/*.css'])

</code></pre>

<h2>gulp.task()</h2>

<p>gulp模块的task方法，用于定义具体的任务。它的第一个参数是任务名，第二个参数是任务函数。下面是一个非常简单的任务函数。</p>

<pre><code>javascript</code><code><br>gulp.task('test', function () {
   console.log('就测试下。');
});

</code></pre>

<p>task方法还可以指定按顺序运行的一组任务。</p>

<pre><code>javascript</code><code><br>gulp.task('build', ['css', 'js', 'templates']);

</code></pre>

<p>上面代码先指定build任务，它按次序由css、js、templates三个任务所组成。注意，由于每个任务都是异步调用，所以没有办法保证js任务的开始运行的时间，正是css任务运行结束。</p>

<p>如果希望各个任务严格按次序运行，可以把前一个任务写成后一个任务的依赖模块。</p>

<pre><code>javascript</code><code><br>gulp.task('css', ['templates'], function () {
   // Deal with CSS here
});

</code></pre>

<p>上面代码表明，css任务依赖templates任务，所以css一定会在templates运行完成后再运行。</p>

<p>如果一个任务的名字为default，就表明它是“默认任务”，在命令行直接输入gulp命令，就会运行该任务。</p>

<pre><code>javascript</code><code><br>gulp.task('default', function () {
   // Your default task
});

</code></pre>

<h2>gulp.watch()</h2>

<p>gulp模块的watch方法，用于指定需要监视的文件。一旦这些文件发生变动，就运行指定任务。</p>

<pre><code>javascript</code><code><br>gulp.task('watch', function () {
   gulp.watch('templates/*.tmpl.html', ['build']);
});

</code></pre>

<p>上面代码指定，一旦templates目录中的模板文件发生变化，就运行build任务。</p>

<p>watch方法也可以用回调函数，代替指定的任务。</p>

<pre><code>javascript</code><code><br>gulp.watch('templates/*.html', function (event) {
   console.log('Event type: ' + event.type); 
   console.log('Event path: ' + event.path); 
});

</code></pre>

<p>另一种写法是watch方法所监控的文件发生变化时（修改、增加、删除文件），会触发change事件。可以对change事件指定回调函数。</p>

<pre><code>javascript</code><code><br>var watcher = gulp.watch('templates/*.html', ['build']);

watcher.on('change', function (event) {
   console.log('Event type: ' + event.type);
   console.log('Event path: ' + event.path);
});

</code></pre>

<p>除了change事件，watch方法还可能触发以下事件。</p>

<ul>
<li>end：回调函数运行完毕时触发。</li>
<li>error：发生错误时触发。</li>
<li>ready：当开始监听文件时触发。</li>
<li>nomatch：没有匹配的监听文件时触发。</li>
</ul>
<p>watcher对象还包含其他一些方法。</p>

<ul>
<li>watcher.end()：停止watcher对象，不会再调用任务或回调函数。</li>
<li>watcher.files()：返回watcher对象监视的文件。</li>
<li>watcher.add(glob)：增加所要监视的文件，它还可以附件第二个参数，表示回调函数。</li>
<li>watcher.remove(filepath)：从watcher对象中移走一个监视的文件。</li>
</ul>
<h2>gulp实现自动刷新 - gulp-livereload</h2>

<p>gulp-livereload模块用于自动刷新浏览器，反映出源码的最新变化。它除了模块以外，还需要在浏览器中<a rel="nofollow" href="https://chrome.google.com/webstore/detail/livereload/jnihajbhpnppcggbcgedagnkighmdlei">安装插件</a>，用来配合源码变化。</p>

<pre><code>javascript</code><code><br>var gulp = require('gulp'),
    livereload = require('gulp-livereload');

gulp.task('watch', function () {
    livereload.listen();
    gulp.watch(['./asset/**/*.*','./templates/**/*.*'], function (file) {
        livereload.changed(file.path);
    });
});

</code></pre>

<p>上面代码监视asset和templates下的任何文件，一旦有变化，就自动刷新浏览器。<br>
Tips: 调试css 很方遍，因为刷新css 不需要刷新这个页面，只需要重新加载css即可，赶紧双屏幕，三屏幕搞起来；代码敲得飞起。</p>

<p>还有很多实用的插件 可以到 <a rel="nofollow" href="https://www.npmjs.com/search?q=gulp">NpmJs.org</a> 去找。</p>

2015年四月29日下午 5:45:17
alsotang starred node-modules/optimized
<!-- watch -->
<div class="simple">
  <span class="octicon octicon-star"></span>

  <div class="title">
    <a href="https://github.com/alsotang" data-ga-click="News feed, event click, Event click type:WatchEvent target:actor">alsotang</a> <span>starred</span> <a href="https://github.com/node-modules/optimized" data-ga-click="News feed, event click, Event click type:WatchEvent target:repo">node-modules/optimized</a>
  </div>

  <div class="time">
    <time datetime="2015-04-29T09:45:17Z" is="relative-time">Apr 29, 2015</time>
  </div>
</div>

2015年四月29日下午 4:54:48
各种设备的CSS3MediaQuery整理及爽歪歪写法
<h2>响应式布局</h2>

<p>响应式布局麻烦之处就是每个尺寸的都要进行css定义，这个真的不是一般的蛋疼，下面有搜集到的各种尺寸css Media Query内容，搜集来源：<a rel="nofollow" href="https://css-tricks.com/snippets/css/media-queries-for-standard-devices/">media-queries-for-standard-devices</a>好东西哦。</p>

<p>看了之后是不是非常之蛋疼呢，那么只有使用工具来写这些玩意儿了，俺用得最爽的就是 <code>stylus</code> ，真的爽yy了，如果 <code>stylus</code> 不会玩耍请看这里 <a rel="nofollow" href="http://jslite.io/2015/04/27/stylus%E8%8F%9C%E9%B8%9F%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/">stylus入门使用方法</a></p>

<p>stylus</p>

<pre><code>// Media queries
mq-mobile = "screen and (max-width: 479px)"
mq-tablet = "screen and (min-width: 480px) and (max-width: 767px)"
mq-iPhones4 = "only screen and (min-device-width: 320px) and (max-device-width: 480px) and (-webkit-min-device-pixel-ratio: 2)"
mq-normal = "screen and (min-width: 768px)"

.page-number
    display: inline-block
    @media mq-mobile
        display: none
    @media mq-tablet
        color:red
    @media mq-iPhones4
        font-size:12px
    @media mq-normal
        background:yellow
</code></pre>

<p>编译成</p>

<pre><code>css</code><code>.page-number {
  display: inline-block;
}
@media screen and (max-width: 479px) {
  .page-number {
    display: none;
  }
}
@media screen and (min-width: 480px) and (max-width: 767px) {
  .page-number {
    color: #f00;
  }
}
@media only screen and (min-device-width: 320px) and (max-device-width: 480px) and (-webkit-min-device-pixel-ratio: 2) {
  .page-number {
    font-size: 12px;
  }
}
@media screen and (min-width: 768px) {
  .page-number {
    background: #ff0;
  }
}
</code></pre>

<h2>Phones and Handhelds</h2>

<h3>iPhones</h3>

<pre><code>css</code><code>/* ----------- iPhone 4 and 4S ----------- */

/* Portrait and Landscape */
@media only screen 
  and (min-device-width: 320px) 
  and (max-device-width: 480px)
  and (-webkit-min-device-pixel-ratio: 2) {

}

/* Portrait */
@media only screen 
  and (min-device-width: 320px) 
  and (max-device-width: 480px)
  and (-webkit-min-device-pixel-ratio: 2)
  and (orientation: portrait) {
}

/* Landscape */
@media only screen 
  and (min-device-width: 320px) 
  and (max-device-width: 480px)
  and (-webkit-min-device-pixel-ratio: 2)
  and (orientation: landscape) {

}

/* ----------- iPhone 5 and 5S ----------- */

/* Portrait and Landscape */
@media only screen 
  and (min-device-width: 320px) 
  and (max-device-width: 568px)
  and (-webkit-min-device-pixel-ratio: 2) {

}

/* Portrait */
@media only screen 
  and (min-device-width: 320px) 
  and (max-device-width: 568px)
  and (-webkit-min-device-pixel-ratio: 2)
  and (orientation: portrait) {
}

/* Landscape */
@media only screen 
  and (min-device-width: 320px) 
  and (max-device-width: 568px)
  and (-webkit-min-device-pixel-ratio: 2)
  and (orientation: landscape) {

}

/* ----------- iPhone 6 ----------- */

/* Portrait and Landscape */
@media only screen 
  and (min-device-width: 375px) 
  and (max-device-width: 667px) 
  and (-webkit-min-device-pixel-ratio: 2) { 

}

/* Portrait */
@media only screen 
  and (min-device-width: 375px) 
  and (max-device-width: 667px) 
  and (-webkit-min-device-pixel-ratio: 2)
  and (orientation: portrait) { 

}

/* Landscape */
@media only screen 
  and (min-device-width: 375px) 
  and (max-device-width: 667px) 
  and (-webkit-min-device-pixel-ratio: 2)
  and (orientation: landscape) { 

}

/* ----------- iPhone 6+ ----------- */

/* Portrait and Landscape */
@media only screen 
  and (min-device-width: 414px) 
  and (max-device-width: 736px) 
  and (-webkit-min-device-pixel-ratio: 3) { 

}

/* Portrait */
@media only screen 
  and (min-device-width: 414px) 
  and (max-device-width: 736px) 
  and (-webkit-min-device-pixel-ratio: 3)
  and (orientation: portrait) { 

}

/* Landscape */
@media only screen 
  and (min-device-width: 414px) 
  and (max-device-width: 736px) 
  and (-webkit-min-device-pixel-ratio: 3)
  and (orientation: landscape) { 

}
</code></pre>

<h3>Galaxy Phones</h3>

<pre><code>css</code><code>/* ----------- Galaxy S3 ----------- */

/* Portrait and Landscape */
@media screen 
  and (device-width: 320px) 
  and (device-height: 640px) 
  and (-webkit-device-pixel-ratio: 2) {

}

/* Portrait */
@media screen 
  and (device-width: 320px) 
  and (device-height: 640px) 
  and (-webkit-device-pixel-ratio: 2) 
  and (orientation: portrait) {

}

/* Landscape */
@media screen 
  and (device-width: 320px) 
  and (device-height: 640px) 
  and (-webkit-device-pixel-ratio: 2) 
  and (orientation: landscape) {

}

/* ----------- Galaxy S4 ----------- */

/* Portrait and Landscape */
@media screen 
  and (device-width: 320px) 
  and (device-height: 640px) 
  and (-webkit-device-pixel-ratio: 3) {

}

/* Portrait */
@media screen 
  and (device-width: 320px) 
  and (device-height: 640px) 
  and (-webkit-device-pixel-ratio: 3) 
  and (orientation: portrait) {

}

/* Landscape */
@media screen 
  and (device-width: 320px) 
  and (device-height: 640px) 
  and (-webkit-device-pixel-ratio: 3) 
  and (orientation: landscape) {

}

/* ----------- Galaxy S5 ----------- */

/* Portrait and Landscape */
@media screen 
  and (device-width: 360px) 
  and (device-height: 640px) 
  and (-webkit-device-pixel-ratio: 3) {

}

/* Portrait */
@media screen 
  and (device-width: 360px) 
  and (device-height: 640px) 
  and (-webkit-device-pixel-ratio: 3) 
  and (orientation: portrait) {

}

/* Landscape */
@media screen 
  and (device-width: 360px) 
  and (device-height: 640px) 
  and (-webkit-device-pixel-ratio: 3) 
  and (orientation: landscape) {

}
</code></pre>

<h3>HTC Phones</h3>

<pre><code>css</code><code>/* ----------- HTC One ----------- */

/* Portrait and Landscape */
@media screen 
  and (device-width: 360px) 
  and (device-height: 640px) 
  and (-webkit-device-pixel-ratio: 3) {

}

/* Portrait */
@media screen 
  and (device-width: 360px) 
  and (device-height: 640px) 
  and (-webkit-device-pixel-ratio: 3) 
  and (orientation: portrait) {

}

/* Landscape */
@media screen 
  and (device-width: 360px) 
  and (device-height: 640px) 
  and (-webkit-device-pixel-ratio: 3) 
  and (orientation: landscape) {

}
</code></pre>

<h2>Tablets</h2>

<h3>iPads</h3>

<pre><code>css</code><code>/* ----------- iPad mini ----------- */

/* Portrait and Landscape */
@media only screen 
  and (min-device-width: 768px) 
  and (max-device-width: 1024px) 
  and (-webkit-min-device-pixel-ratio: 1) {

}

/* Portrait */
@media only screen 
  and (min-device-width: 768px) 
  and (max-device-width: 1024px) 
  and (orientation: portrait) 
  and (-webkit-min-device-pixel-ratio: 1) {

}

/* Landscape */
@media only screen 
  and (min-device-width: 768px) 
  and (max-device-width: 1024px) 
  and (orientation: landscape) 
  and (-webkit-min-device-pixel-ratio: 1) {

}

/* ----------- iPad 1 and 2 ----------- */
/* Portrait and Landscape */
@media only screen 
  and (min-device-width: 768px) 
  and (max-device-width: 1024px) 
  and (-webkit-min-device-pixel-ratio: 1) {

}

/* Portrait */
@media only screen 
  and (min-device-width: 768px) 
  and (max-device-width: 1024px) 
  and (orientation: portrait) 
  and (-webkit-min-device-pixel-ratio: 1) {

}

/* Landscape */
@media only screen 
  and (min-device-width: 768px) 
  and (max-device-width: 1024px) 
  and (orientation: landscape) 
  and (-webkit-min-device-pixel-ratio: 1) {

}

/* ----------- iPad 3 and 4 ----------- */
/* Portrait and Landscape */
@media only screen 
  and (min-device-width: 768px) 
  and (max-device-width: 1024px) 
  and (-webkit-min-device-pixel-ratio: 2) {

}

/* Portrait */
@media only screen 
  and (min-device-width: 768px) 
  and (max-device-width: 1024px) 
  and (orientation: portrait) 
  and (-webkit-min-device-pixel-ratio: 2) {

}

/* Landscape */
@media only screen 
  and (min-device-width: 768px) 
  and (max-device-width: 1024px) 
  and (orientation: landscape) 
  and (-webkit-min-device-pixel-ratio: 2) {

}
</code></pre>

<h3>Galaxy Tablets</h3>

<pre><code>css</code><code>/* ----------- Galaxy Tab 10.1 ----------- */

/* Portrait and Landscape */
@media 
  (min-device-width: 800px) 
  and (max-device-width: 1280px) {

}

/* Portrait */
@media 
  (max-device-width: 800px) 
  and (orientation: portrait) { 

}

/* Landscape */
@media 
  (max-device-width: 1280px) 
  and (orientation: landscape) { 

}
</code></pre>

<h3>Nexus Tablets</h3>

<pre><code>css</code><code>/* ----------- Asus Nexus 7 ----------- */

/* Portrait and Landscape */
@media screen 
  and (device-width: 601px) 
  and (device-height: 906px) 
  and (-webkit-min-device-pixel-ratio: 1.331) 
  and (-webkit-max-device-pixel-ratio: 1.332) {

}

/* Portrait */
@media screen 
  and (device-width: 601px) 
  and (device-height: 906px) 
  and (-webkit-min-device-pixel-ratio: 1.331) 
  and (-webkit-max-device-pixel-ratio: 1.332) 
  and (orientation: portrait) {

}

/* Landscape */
@media screen 
  and (device-width: 601px) 
  and (device-height: 906px) 
  and (-webkit-min-device-pixel-ratio: 1.331) 
  and (-webkit-max-device-pixel-ratio: 1.332) 
  and (orientation: landscape) {

}
</code></pre>

<h3>Kindle Fire</h3>

<pre><code>css</code><code>/* ----------- Kindle Fire HD 7" ----------- */

/* Portrait and Landscape */
@media only screen 
  and (min-device-width: 800px) 
  and (max-device-width: 1280px) 
  and (-webkit-min-device-pixel-ratio: 1.5) {

}

/* Portrait */
@media only screen 
  and (min-device-width: 800px) 
  and (max-device-width: 1280px) 
  and (-webkit-min-device-pixel-ratio: 1.5) 
  and (orientation: portrait) {
}

/* Landscape */
@media only screen 
  and (min-device-width: 800px) 
  and (max-device-width: 1280px) 
  and (-webkit-min-device-pixel-ratio: 1.5) 
  and (orientation: landscape) {

}

/* ----------- Kindle Fire HD 8.9" ----------- */
/* Portrait and Landscape */
@media only screen 
  and (min-device-width: 1200px) 
  and (max-device-width: 1600px) 
  and (-webkit-min-device-pixel-ratio: 1.5) {

}
/* Portrait */
@media only screen 
  and (min-device-width: 1200px) 
  and (max-device-width: 1600px) 
  and (-webkit-min-device-pixel-ratio: 1.5) 
  and (orientation: portrait) {
}

/* Landscape */
@media only screen 
  and (min-device-width: 1200px) 
  and (max-device-width: 1600px) 
  and (-webkit-min-device-pixel-ratio: 1.5) 
  and (orientation: landscape) {

}
</code></pre>

<h2>Laptops</h2>

<pre><code>css</code><code>/* ----------- Non-Retina Screens ----------- */
@media screen 
  and (min-device-width: 1200px) 
  and (max-device-width: 1600px) 
  and (-webkit-min-device-pixel-ratio: 1) { 
}
/* ----------- Retina Screens ----------- */
@media screen 
  and (min-device-width: 1200px) 
  and (max-device-width: 1600px) 
  and (-webkit-min-device-pixel-ratio: 2)
  and (min-resolution: 192dpi) { 
}
</code></pre>

<h2>Wearables</h2>

<h3>Apple Watch</h3>

<pre><code>css</code><code>/* ----------- Apple Watch ----------- */
@media
  (max-device-width: 42mm)
  and (min-device-width: 38mm) { 

}
</code></pre>

<h3>Moto 360 Watch</h3>

<pre><code>css</code><code>/* ----------- Moto 360 Watch ----------- */
@media 
  (max-device-width: 218px)
  and (max-device-height: 281px) { 

}
</code></pre>

2015年四月29日下午 4:25:28
alsotang pushed to master at cnodejs/nodeclub
<!-- push -->
<span class="mega-octicon octicon-git-commit"></span>

<div class="time">
  <time datetime="2015-04-29T08:25:28Z" is="relative-time">Apr 29, 2015</time>
</div>

<div class="title">
  <a href="https://github.com/alsotang" data-ga-click="News feed, event click, Event click type:PushEvent target:actor">alsotang</a> <span>pushed</span> to <a href="/cnodejs/nodeclub/tree/master" data-ga-click="News feed, event click, Event click type:PushEvent target:branch">master</a> at <a href="https://github.com/cnodejs/nodeclub" data-ga-click="News feed, event click, Event click type:PushEvent target:repo">cnodejs/nodeclub</a>
</div>

<div class="details">
  <a href="https://github.com/alsotang"><img alt="@alsotang" class="gravatar" data-user="1147375" height="30" src="https://avatars0.githubusercontent.com/u/1147375?v=3&amp;s=60" width="30" /></a>

    <div class="commits pusher-is-only-committer">
      <ul>
        <li>
          <span title="alsotang">
            <img alt="@alsotang" data-user="1147375" height="16" src="https://avatars1.githubusercontent.com/u/1147375?v=3&amp;s=32" width="16" />
          </span>
          <code><a href="/cnodejs/nodeclub/commit/b7ac06b009ccec9a5c86f6da12ca19d60b242610" data-ga-click="News feed, event click, Event click type:PushEvent target:sha">b7ac06b</a></code>
          <div class="message">
            <blockquote>
              update readme
            </blockquote>
          </div>
        </li>
      </ul>
    </div>
</div>

2015年四月29日下午 4:24:27
alsotang pushed to master at cnodejs/nodeclub
<!-- push -->
<span class="mega-octicon octicon-git-commit"></span>

<div class="time">
  <time datetime="2015-04-29T08:24:27Z" is="relative-time">Apr 29, 2015</time>
</div>

<div class="title">
  <a href="https://github.com/alsotang" data-ga-click="News feed, event click, Event click type:PushEvent target:actor">alsotang</a> <span>pushed</span> to <a href="/cnodejs/nodeclub/tree/master" data-ga-click="News feed, event click, Event click type:PushEvent target:branch">master</a> at <a href="https://github.com/cnodejs/nodeclub" data-ga-click="News feed, event click, Event click type:PushEvent target:repo">cnodejs/nodeclub</a>
</div>

<div class="details">
  <a href="https://github.com/alsotang"><img alt="@alsotang" class="gravatar" data-user="1147375" height="30" src="https://avatars0.githubusercontent.com/u/1147375?v=3&amp;s=60" width="30" /></a>

    <div class="commits pusher-is-only-committer">
      <ul>
        <li>
          <span title="alsotang">
            <img alt="@alsotang" data-user="1147375" height="16" src="https://avatars1.githubusercontent.com/u/1147375?v=3&amp;s=32" width="16" />
          </span>
          <code><a href="/cnodejs/nodeclub/commit/b2d4ba4593db951d8ef30b9bafd091c1a2443fb1" data-ga-click="News feed, event click, Event click type:PushEvent target:sha">b2d4ba4</a></code>
          <div class="message">
            <blockquote>
              update readme
            </blockquote>
          </div>
        </li>
      </ul>
    </div>
</div>

2015年四月29日上午 10:30:37
alsotang pushed to online at cnodejs/nodeclub
<!-- push -->
<span class="mega-octicon octicon-git-commit"></span>

<div class="time">
  <time datetime="2015-04-29T02:30:37Z" is="relative-time">Apr 29, 2015</time>
</div>

<div class="title">
  <a href="https://github.com/alsotang" data-ga-click="News feed, event click, Event click type:PushEvent target:actor">alsotang</a> <span>pushed</span> to <a href="/cnodejs/nodeclub/tree/online" data-ga-click="News feed, event click, Event click type:PushEvent target:branch">online</a> at <a href="https://github.com/cnodejs/nodeclub" data-ga-click="News feed, event click, Event click type:PushEvent target:repo">cnodejs/nodeclub</a>
</div>

<div class="details">
  <a href="https://github.com/alsotang"><img alt="@alsotang" class="gravatar" data-user="1147375" height="30" src="https://avatars0.githubusercontent.com/u/1147375?v=3&amp;s=60" width="30" /></a>

    <div class="commits pusher-is-only-committer">
      <ul>
        <li>
          <span title="alsotang">
            <img alt="@alsotang" data-user="1147375" height="16" src="https://avatars1.githubusercontent.com/u/1147375?v=3&amp;s=32" width="16" />
          </span>
          <code><a href="/cnodejs/nodeclub/commit/7ea37f8951137831493f66e9cb7f9f44c3b12139" data-ga-click="News feed, event click, Event click type:PushEvent target:sha">7ea37f8</a></code>
          <div class="message">
            <blockquote>
              coding
            </blockquote>
          </div>
        </li>
      </ul>
    </div>
</div>

2015年四月28日下午 3:23:19
alsotang starred ideawu/ssdb
<!-- watch -->
<div class="simple">
  <span class="octicon octicon-star"></span>

  <div class="title">
    <a href="https://github.com/alsotang" data-ga-click="News feed, event click, Event click type:WatchEvent target:actor">alsotang</a> <span>starred</span> <a href="https://github.com/ideawu/ssdb" data-ga-click="News feed, event click, Event click type:WatchEvent target:repo">ideawu/ssdb</a>
  </div>

  <div class="time">
    <time datetime="2015-04-28T07:23:19Z" is="relative-time">Apr 28, 2015</time>
  </div>
</div>

2015年四月28日上午 10:48:03
alsotang starred phacility/xhprof
<!-- watch -->
<div class="simple">
  <span class="octicon octicon-star"></span>

  <div class="title">
    <a href="https://github.com/alsotang" data-ga-click="News feed, event click, Event click type:WatchEvent target:actor">alsotang</a> <span>starred</span> <a href="https://github.com/phacility/xhprof" data-ga-click="News feed, event click, Event click type:WatchEvent target:repo">phacility/xhprof</a>
  </div>

  <div class="time">
    <time datetime="2015-04-28T02:48:03Z" is="relative-time">Apr 28, 2015</time>
  </div>
</div>

2015年四月27日晚上 10:08:08
alsotang starred nuysoft/node-print
<!-- watch -->
<div class="simple">
  <span class="octicon octicon-star"></span>

  <div class="title">
    <a href="https://github.com/alsotang" data-ga-click="News feed, event click, Event click type:WatchEvent target:actor">alsotang</a> <span>starred</span> <a href="https://github.com/nuysoft/node-print" data-ga-click="News feed, event click, Event click type:WatchEvent target:repo">nuysoft/node-print</a>
  </div>

  <div class="time">
    <time datetime="2015-04-27T14:08:08Z" is="relative-time">Apr 27, 2015</time>
  </div>
</div>

2015年四月27日中午 11:36:09
alsotang starred petitspois/docs.ren
<!-- watch -->
<div class="simple">
  <span class="octicon octicon-star"></span>

  <div class="title">
    <a href="https://github.com/alsotang" data-ga-click="News feed, event click, Event click type:WatchEvent target:actor">alsotang</a> <span>starred</span> <a href="https://github.com/petitspois/docs.ren" data-ga-click="News feed, event click, Event click type:WatchEvent target:repo">petitspois/docs.ren</a>
  </div>

  <div class="time">
    <time datetime="2015-04-27T03:36:09Z" is="relative-time">Apr 27, 2015</time>
  </div>
</div>

2015年四月24日晚上 10:01:44
alsotang commented on issue alsotang/node-lessons#34
<!-- issue_comment -->
<span class="mega-octicon octicon-comment-discussion"></span>

<div class="time">
  <time datetime="2015-04-24T14:01:44Z" is="relative-time">Apr 24, 2015</time>
</div>

<div class="title">
  <a href="https://github.com/alsotang" data-ga-click="News feed, event click, Event click type:IssueCommentEvent target:actor">alsotang</a> <span>commented</span> on issue <a href="https://github.com/alsotang/node-lessons/issues/34#issuecomment-95943100" data-ga-click="News feed, event click, Event click type:IssueCommentEvent target:issue-comment" title="Lesson2中又安装了好几个依赖模块才能执行成功">alsotang/node-lessons#34</a>
</div>

<div class="details">
  <a href="https://github.com/alsotang"><img alt="@alsotang" class="gravatar" data-user="1147375" height="30" src="https://avatars0.githubusercontent.com/u/1147375?v=3&amp;s=60" width="30" /></a>
  <div class="message markdown-body">
    <blockquote>
      <p>lesson2 不涉及任何 css 的内容吧 </p>
    </blockquote>
  </div>
</div>

2015年四月23日晚上 10:58:10
alsotang pushed to online at cnodejs/nodeclub
<!-- push -->
<span class="mega-octicon octicon-git-commit"></span>

<div class="time">
  <time datetime="2015-04-23T14:58:10Z" is="relative-time">Apr 23, 2015</time>
</div>

<div class="title">
  <a href="https://github.com/alsotang" data-ga-click="News feed, event click, Event click type:PushEvent target:actor">alsotang</a> <span>pushed</span> to <a href="/cnodejs/nodeclub/tree/online" data-ga-click="News feed, event click, Event click type:PushEvent target:branch">online</a> at <a href="https://github.com/cnodejs/nodeclub" data-ga-click="News feed, event click, Event click type:PushEvent target:repo">cnodejs/nodeclub</a>
</div>

<div class="details">
  <a href="https://github.com/alsotang"><img alt="@alsotang" class="gravatar" data-user="1147375" height="30" src="https://avatars0.githubusercontent.com/u/1147375?v=3&amp;s=60" width="30" /></a>

    <div class="commits pusher-is-only-committer">
      <ul>
        <li>
          <span title="alsotang">
            <img alt="@alsotang" data-user="1147375" height="16" src="https://avatars1.githubusercontent.com/u/1147375?v=3&amp;s=32" width="16" />
          </span>
          <code><a href="/cnodejs/nodeclub/commit/9f66bb526ff4aab5e2cc918feddcf7c015415d96" data-ga-click="News feed, event click, Event click type:PushEvent target:sha">9f66bb5</a></code>
          <div class="message">
            <blockquote>
              jpush
            </blockquote>
          </div>
        </li>
        <li>
          <span title="alsotang">
            <img alt="@alsotang" data-user="1147375" height="16" src="https://avatars1.githubusercontent.com/u/1147375?v=3&amp;s=32" width="16" />
          </span>
          <code><a href="/cnodejs/nodeclub/commit/8be2e14a298e53d33f707cccbcb2930eff0936f4" data-ga-click="News feed, event click, Event click type:PushEvent target:sha">8be2e14</a></code>
          <div class="message">
            <blockquote>
              topic 详情页缓存零回复主题
            </blockquote>
          </div>
        </li>
        <li class="more"><a href="https://github.com/cnodejs/nodeclub/compare/b249827d22...9f66bb526f" data-ga-click="News feed, event click, Event click type:PushEvent target:comparison">View comparison for these 2 commits &raquo;</a></li>
      </ul>
    </div>
</div>

2015年四月23日晚上 10:57:37
alsotang pushed to master at cnodejs/nodeclub
<!-- push -->
<span class="mega-octicon octicon-git-commit"></span>

<div class="time">
  <time datetime="2015-04-23T14:57:37Z" is="relative-time">Apr 23, 2015</time>
</div>

<div class="title">
  <a href="https://github.com/alsotang" data-ga-click="News feed, event click, Event click type:PushEvent target:actor">alsotang</a> <span>pushed</span> to <a href="/cnodejs/nodeclub/tree/master" data-ga-click="News feed, event click, Event click type:PushEvent target:branch">master</a> at <a href="https://github.com/cnodejs/nodeclub" data-ga-click="News feed, event click, Event click type:PushEvent target:repo">cnodejs/nodeclub</a>
</div>

<div class="details">
  <a href="https://github.com/alsotang"><img alt="@alsotang" class="gravatar" data-user="1147375" height="30" src="https://avatars0.githubusercontent.com/u/1147375?v=3&amp;s=60" width="30" /></a>

    <div class="commits pusher-is-only-committer">
      <ul>
        <li>
          <span title="alsotang">
            <img alt="@alsotang" data-user="1147375" height="16" src="https://avatars1.githubusercontent.com/u/1147375?v=3&amp;s=32" width="16" />
          </span>
          <code><a href="/cnodejs/nodeclub/commit/8be2e14a298e53d33f707cccbcb2930eff0936f4" data-ga-click="News feed, event click, Event click type:PushEvent target:sha">8be2e14</a></code>
          <div class="message">
            <blockquote>
              topic 详情页缓存零回复主题
            </blockquote>
          </div>
        </li>
      </ul>
    </div>
</div>

2015年四月23日晚上 10:52:40
alsotang pushed to online at cnodejs/nodeclub
<!-- push -->
<span class="mega-octicon octicon-git-commit"></span>

<div class="time">
  <time datetime="2015-04-23T14:52:40Z" is="relative-time">Apr 23, 2015</time>
</div>

<div class="title">
  <a href="https://github.com/alsotang" data-ga-click="News feed, event click, Event click type:PushEvent target:actor">alsotang</a> <span>pushed</span> to <a href="/cnodejs/nodeclub/tree/online" data-ga-click="News feed, event click, Event click type:PushEvent target:branch">online</a> at <a href="https://github.com/cnodejs/nodeclub" data-ga-click="News feed, event click, Event click type:PushEvent target:repo">cnodejs/nodeclub</a>
</div>

<div class="details">
  <a href="https://github.com/alsotang"><img alt="@alsotang" class="gravatar" data-user="1147375" height="30" src="https://avatars0.githubusercontent.com/u/1147375?v=3&amp;s=60" width="30" /></a>

    <div class="commits pusher-is-only-committer">
      <ul>
        <li>
          <span title="alsotang">
            <img alt="@alsotang" data-user="1147375" height="16" src="https://avatars1.githubusercontent.com/u/1147375?v=3&amp;s=32" width="16" />
          </span>
          <code><a href="/cnodejs/nodeclub/commit/b249827d22526b15bde68cc6b45ff6f4dcdbcd1b" data-ga-click="News feed, event click, Event click type:PushEvent target:sha">b249827</a></code>
          <div class="message">
            <blockquote>
              jpush
            </blockquote>
          </div>
        </li>
        <li>
          <span title="alsotang">
            <img alt="@alsotang" data-user="1147375" height="16" src="https://avatars1.githubusercontent.com/u/1147375?v=3&amp;s=32" width="16" />
          </span>
          <code><a href="/cnodejs/nodeclub/commit/778ede2adf317abab25652a14eef5e8258a680e4" data-ga-click="News feed, event click, Event click type:PushEvent target:sha">778ede2</a></code>
          <div class="message">
            <blockquote>
              零回复的主题不显示招聘栏目
            </blockquote>
          </div>
        </li>
        <li class="more"><a href="https://github.com/cnodejs/nodeclub/compare/6c2fc20cab...b249827d22" data-ga-click="News feed, event click, Event click type:PushEvent target:comparison">View comparison for these 2 commits &raquo;</a></li>
      </ul>
    </div>
</div>

2015年四月23日晚上 10:52:23
alsotang pushed to master at cnodejs/nodeclub
<!-- push -->
<span class="mega-octicon octicon-git-commit"></span>

<div class="time">
  <time datetime="2015-04-23T14:52:23Z" is="relative-time">Apr 23, 2015</time>
</div>

<div class="title">
  <a href="https://github.com/alsotang" data-ga-click="News feed, event click, Event click type:PushEvent target:actor">alsotang</a> <span>pushed</span> to <a href="/cnodejs/nodeclub/tree/master" data-ga-click="News feed, event click, Event click type:PushEvent target:branch">master</a> at <a href="https://github.com/cnodejs/nodeclub" data-ga-click="News feed, event click, Event click type:PushEvent target:repo">cnodejs/nodeclub</a>
</div>

<div class="details">
  <a href="https://github.com/alsotang"><img alt="@alsotang" class="gravatar" data-user="1147375" height="30" src="https://avatars0.githubusercontent.com/u/1147375?v=3&amp;s=60" width="30" /></a>

    <div class="commits pusher-is-only-committer">
      <ul>
        <li>
          <span title="alsotang">
            <img alt="@alsotang" data-user="1147375" height="16" src="https://avatars1.githubusercontent.com/u/1147375?v=3&amp;s=32" width="16" />
          </span>
          <code><a href="/cnodejs/nodeclub/commit/778ede2adf317abab25652a14eef5e8258a680e4" data-ga-click="News feed, event click, Event click type:PushEvent target:sha">778ede2</a></code>
          <div class="message">
            <blockquote>
              零回复的主题不显示招聘栏目
            </blockquote>
          </div>
        </li>
      </ul>
    </div>
</div>

2015年五月6日晚上 8:21:08
alsotang commented on issue cnodejs/nodeclub#522
<!-- issue_comment -->
<span class="mega-octicon octicon-comment-discussion"></span>

<div class="time">
  <time datetime="2015-05-06T12:21:08Z" is="relative-time">May 6, 2015</time>
</div>

<div class="title">
  <a href="https://github.com/alsotang" data-ga-click="News feed, event click, Event click type:IssueCommentEvent target:actor">alsotang</a> <span>commented</span> on issue <a href="https://github.com/cnodejs/nodeclub/issues/522#issuecomment-99428536" data-ga-click="News feed, event click, Event click type:IssueCommentEvent target:issue-comment" title="ejs 设置多个layout怎么配置？">cnodejs/nodeclub#522</a>
</div>

<div class="details">
  <a href="https://github.com/alsotang"><img alt="@alsotang" class="gravatar" data-user="1147375" height="30" src="https://avatars0.githubusercontent.com/u/1147375?v=3&amp;s=60" width="30" /></a>
  <div class="message markdown-body">
    <blockquote>
      <p>在 render 的时候应该是可以指定 layout 的吧？特定页面指定一下就好了。 不过还是不太懂你问的是什么。 2015-05-06 16:25 GMT+08:00 stiyes <a href="mailto:notifications@github.com">notifications@github.com</a>: 
我的已经是，模板文件layout.html，再加几个模板…</p>
    </blockquote>
  </div>
</div>

2015年五月6日晚上 7:56:10
alsotang pushed to online at cnodejs/nodeclub
<!-- push -->
<span class="mega-octicon octicon-git-commit"></span>

<div class="time">
  <time datetime="2015-05-06T11:56:10Z" is="relative-time">May 6, 2015</time>
</div>

<div class="title">
  <a href="https://github.com/alsotang" data-ga-click="News feed, event click, Event click type:PushEvent target:actor">alsotang</a> <span>pushed</span> to <a href="/cnodejs/nodeclub/tree/online" data-ga-click="News feed, event click, Event click type:PushEvent target:branch">online</a> at <a href="https://github.com/cnodejs/nodeclub" data-ga-click="News feed, event click, Event click type:PushEvent target:repo">cnodejs/nodeclub</a>
</div>

<div class="details">
  <a href="https://github.com/alsotang"><img alt="@alsotang" class="gravatar" data-user="1147375" height="30" src="https://avatars0.githubusercontent.com/u/1147375?v=3&amp;s=60" width="30" /></a>

    <div class="commits pusher-is-only-committer">
      <ul>
        <li>
          <span title="alsotang">
            <img alt="@alsotang" data-user="1147375" height="16" src="https://avatars1.githubusercontent.com/u/1147375?v=3&amp;s=32" width="16" />
          </span>
          <code><a href="/cnodejs/nodeclub/commit/2de5f109e0258af4ac6fd85031ef7f5835f67f25" data-ga-click="News feed, event click, Event click type:PushEvent target:sha">2de5f10</a></code>
          <div class="message">
            <blockquote>
              coding.net
            </blockquote>
          </div>
        </li>
        <li>
          <span title="alsotang">
            <img alt="@alsotang" data-user="1147375" height="16" src="https://avatars1.githubusercontent.com/u/1147375?v=3&amp;s=32" width="16" />
          </span>
          <code><a href="/cnodejs/nodeclub/commit/adc3770aff07199d71429031e096c1ac449ec88d" data-ga-click="News feed, event click, Event click type:PushEvent target:sha">adc3770</a></code>
          <div class="message">
            <blockquote>
              coding.net
            </blockquote>
          </div>
        </li>
        <li class="more"><a href="https://github.com/cnodejs/nodeclub/compare/93829293a5...2de5f109e0" data-ga-click="News feed, event click, Event click type:PushEvent target:comparison">4 more commits &raquo;</a></li>
      </ul>
    </div>
</div>

2015年五月6日晚上 7:55:36
alsotang pushed to master at cnodejs/nodeclub
<!-- push -->
<span class="mega-octicon octicon-git-commit"></span>

<div class="time">
  <time datetime="2015-05-06T11:55:36Z" is="relative-time">May 6, 2015</time>
</div>

<div class="title">
  <a href="https://github.com/alsotang" data-ga-click="News feed, event click, Event click type:PushEvent target:actor">alsotang</a> <span>pushed</span> to <a href="/cnodejs/nodeclub/tree/master" data-ga-click="News feed, event click, Event click type:PushEvent target:branch">master</a> at <a href="https://github.com/cnodejs/nodeclub" data-ga-click="News feed, event click, Event click type:PushEvent target:repo">cnodejs/nodeclub</a>
</div>

<div class="details">
  <a href="https://github.com/alsotang"><img alt="@alsotang" class="gravatar" data-user="1147375" height="30" src="https://avatars0.githubusercontent.com/u/1147375?v=3&amp;s=60" width="30" /></a>

    <div class="commits pusher-is-only-committer">
      <ul>
        <li>
          <span title="alsotang">
            <img alt="@alsotang" data-user="1147375" height="16" src="https://avatars1.githubusercontent.com/u/1147375?v=3&amp;s=32" width="16" />
          </span>
          <code><a href="/cnodejs/nodeclub/commit/f7b9a10760ff62df16a70e70909f140b3dd4ed51" data-ga-click="News feed, event click, Event click type:PushEvent target:sha">f7b9a10</a></code>
          <div class="message">
            <blockquote>
              update pm2 to 0.12.13
            </blockquote>
          </div>
        </li>
      </ul>
    </div>
</div>

2015年五月6日晚上 7:54:17
alsotang pushed to online at cnodejs/nodeclub
<!-- push -->
<span class="mega-octicon octicon-git-commit"></span>

<div class="time">
  <time datetime="2015-05-06T11:54:17Z" is="relative-time">May 6, 2015</time>
</div>

<div class="title">
  <a href="https://github.com/alsotang" data-ga-click="News feed, event click, Event click type:PushEvent target:actor">alsotang</a> <span>pushed</span> to <a href="/cnodejs/nodeclub/tree/online" data-ga-click="News feed, event click, Event click type:PushEvent target:branch">online</a> at <a href="https://github.com/cnodejs/nodeclub" data-ga-click="News feed, event click, Event click type:PushEvent target:repo">cnodejs/nodeclub</a>
</div>

<div class="details">
  <a href="https://github.com/alsotang"><img alt="@alsotang" class="gravatar" data-user="1147375" height="30" src="https://avatars0.githubusercontent.com/u/1147375?v=3&amp;s=60" width="30" /></a>

    <div class="commits pusher-is-only-committer">
      <ul>
        <li>
          <span title="alsotang">
            <img alt="@alsotang" data-user="1147375" height="16" src="https://avatars1.githubusercontent.com/u/1147375?v=3&amp;s=32" width="16" />
          </span>
          <code><a href="/cnodejs/nodeclub/commit/93829293a5958263b259e512d74e26fd3d3b6140" data-ga-click="News feed, event click, Event click type:PushEvent target:sha">9382929</a></code>
          <div class="message">
            <blockquote>
              coding.net
            </blockquote>
          </div>
        </li>
      </ul>
    </div>
</div>

2015年五月6日下午 5:45:19
koa有什么优势么？昨天压测了下，结果略失望
<div class="markdown-text"><p>node版本为0.11.14，以http和koa分别写简单server服务（输出hello world），高并发高请求下，http的qps要比koa高100左右（例如c300n10000时，http的qps为1623，koa为1527；c500n15000时，http的qps为1288，koa为1152）。且单个请求的平均响应时间，http的要比koa的快。
之前把一个服务重新用koa写了下，压测的时候发现qps反而降低了。。。打击啊:(</p>
</div>

2015年五月6日下午 5:04:23
8 个你可能不知道的 Docker 知识
<blockquote>
  <p>Docker 这个工具已经出现很长一段时间了，但是可能还有很多人对 Docker 的概念不太清楚，因此这次翻译 <a rel="nofollow" href="http://blog.greenpages.com/miscellaneous-it/8-things-you-may-not-know-about-docker/">8 个你可能不知道的 Docker 知识</a> 这篇文章，和大家介绍一下生产环境中的 Docker 用例。</p>
</blockquote>

<p>自从上世纪 90 年代硬件虚拟化被主流的技术广泛普及之后，对数据中心而言，发生的最大的变革莫过于容器和容器管理工具，例如：Docker。在过去的一年内，Docker 技术已经逐渐走向成熟，并且推动了大型初创公司例如 Twitter 和 Airbnb 的发展，甚至在银行、连锁超市、甚至 NASA 的数据中心都赢得了一席之地。当我几年前第一次直到 Docker 的时候，我还对 Docker 的未来持怀疑的态度，我认为他们是把以前的 Linux 容器的概念拿出来包装了一番推向市场。但是使用 Docker 成功进行了几个项目 例如 <a rel="nofollow" href="http://www.spantree.net/">Spantree</a> 之后，我改变了我的看法：Docker 帮助我们节省了大量的时间和经历，并且已经成为我们技术团队中不可或缺的工具。</p>

<p>GitHub 上面每天都会催生出各式各样的工具、形态各异的语言和千奇百怪的概念。如果你和我一样，没有时间去把他们全部都测试一遍，甚至没有时间去亲自测试 Docker，那么你可以看一下我的这篇文章：我将会用我们在 Docker 中总结的经验来告诉你什么是 Docker、为什么 Docker 会这么火。</p>

<h2>Docker 是容器管理工具</h2>

<p>Docker 是一个轻量级、便携式、与外界隔离的容器，也是一个可以在容器中很方便地构建、传输、运行应用的引擎。和传统的虚拟化技术不同的是，Docker 引擎并不虚拟出一台虚拟机，而是直接使用宿主机的内核和硬件，直接在宿主机上运行容器内应用。也正是得益于此，Docker 容器内运行的应用和宿主机上运行的应用性能差距几乎可以忽略不计。</p>

<p>但是 Docker 本身并不是一个容器系统，而是一个基于原有的容器化工具 LXC 用来创建虚拟环境的工具。类似 LXC 的工具已经在生产环境中使用多年，Docker 则基于此提供了更加友好的镜像管理工具和部署工具。</p>

<h2>Docker 不是虚拟化引擎</h2>

<p>Docker 第一次发布的时候，很多人都拿 Docker 和虚拟机 VMware、KVM 和 VirtualBox 比较。尽管从功能上看，Docker 和虚拟化技术致力于解决的问题都差不多，但是 Docker 却是采取了另一种非常不同的方式。虚拟机是虚拟出一套硬件，虚拟机的系统进行的磁盘操作，其实都是在对虚拟出来的磁盘进行操作。当运行 CPU 密集型的任务时，是虚拟机把虚拟系统里的 CPU 指令“翻译”成宿主机的CPU指令并进行执行。两个磁盘层，两个处理器调度器，两个操作系统消耗的内存，所有虚拟出的这些都会带来相当多的性能损失，一台虚拟机所消耗的硬件资源和对应的硬件相当，一台主机上跑太多的虚拟机之后就会过载。而 Docker 就没有这种顾虑。Docker 运行应用采取的是“容器”的解决方案：使用 namespace 和 CGroup 进行资源限制，和宿主机共享内核，不虚拟磁盘，所有的容器磁盘操作其实都是对 <code>/var/lib/docker/</code> 的操作。简言之，Docker 其实只是在宿主机中运行了一个受到限制的应用程序。</p>

<p>从上面不难看出，容器和虚拟机的概念并不相同，容器也并不能取代虚拟机。在容器力所不能及的地方，虚拟机可以大显身手。例如：宿主机是 Linux，只能通过虚拟机运行 Windows，Docker 便无法做到。再例如，宿主机是 Windows，Windows 并不能直接运行 Docker，Windows上的 Docker 其实是运行在 VirtualBox 虚拟机里的。</p>

<h2>Docker 使用层级的文件系统</h2>

<p>前面提到过，Docker 和现有容器技术 LXC 等相比，优势之一就是 Docker 提供了镜像管理。对于 Docker 而言，镜像是一个静态的、只读的容器文件系统的快照。然而不仅如此，Docker 中所有的磁盘操作都是对特定的Copy-On-Write文件系统进行的。下面通过一个例子解释一下这个问题。</p>

<p>例如我们要建立一个容器运行 JAVA Web 应用，那么我们应该使用一个已经安装了 JAVA 的镜像。在 Dockerfile（一个用于生成镜像的指令文件）中，应该指明“基于 JAVA 镜像”，这样 Docker 就会去 Docker Hub Registry 上下载提前构建好的 JAVA 镜像。然后再 Dockerfile 中指明下载并解压 Apache Tomcat 软件到 <code>/opt/tomcat</code> 文件夹中。这条命令并不会对原有的 JAVA 镜像产生任何影响，而仅仅是在原有镜像上面添加了一个改动层。当一个容器启动时，容器内的所有改动层都会启动，容器会从第一层中运行 <code>/usr/bin/java</code> 命令，并且调用另外一层中的 <code>/opt/tomcat/bin</code> 命令。实际上，Dockerfile 中每一条指令都会产生一个新的改动层，即便只有一个文件被改动。如果用过 Git 就能更清楚地认识这一点，每条指令就像是每次 commit，都会留下记录。但是对于 Docker 来说，这种文件系统提供了更大的灵活性，也可以更方便地管理应用程序。</p>

<p>我们Spantree的团队有一个自己维护的含有 Tomcat 的镜像。发布新版本也非常简单：使用 Dockerfile 将新版本拷贝进镜像从而创建一个新镜像，然后给新镜像贴上版本的标签。不同版本的镜像的不同之处仅仅是一个 90 MB 大小的 WAR 文件，他们所基于的主镜像都是相同的。如果使用虚拟机去维护这些不同的版本的话，还要消耗掉很多不同的磁盘去存储相同的系统，而使用 Docker 就只需要很小的磁盘空间。即便我们同时运行这个镜像的很多实例，我们也只需要一个基础的 JAVA / TOMCAT 镜像。</p>

<h2>Docker 可以节约时间</h2>

<p>很多年前我在为一个连锁餐厅开发软件时，仅仅是为了描述如何搭建环境都需要写一个 12 页的 Word 文档。例如本地 Oracle 数据库，特定版本的 JAVA，以及其他七七八八的系统工具和共享库、软件包。整个搭建过程浪费掉了我们团队每个人几乎一天的时间，如果用金钱衡量的话，花掉了我们上万美金的时间成本。虽然客户已经对这种事情习以为常，甚至认为这是引入新成员、让成员适应环境、让自己的员工适应我们的软件所必须的成本，但是相比较起来，我们宁愿把更多的时间花在为客户构建可以增进业务的功能上面。</p>

<p>如果当时有 Docker，那么构建环境就会像使用自动化搭建工具 Puppet / Chef / Salt / Ansible 一样简单，我们也可以把整个搭建时间周期从一天缩短为几分钟。但是和这些工具不同的地方在于，Docker 可以不仅仅可以搭建整个环境，还可以将整个环境保存成磁盘文件，然后复制到别的地方。需要从源码编译 Node.js 吗？Docker 做得到。Docker 不仅仅可以构建一个 Node.js 环境，还可以将整个环境做成镜像，然后保存到任何地方。当然，由于 Docker 是一个容器，所以不用担心容器内执行的东西会对宿主机产生任何的影响。</p>

<p>现在新加入我们团队的人只需要运行 <code>docker-compose up</code> 命令，便可以喝杯咖啡，然后开始工作了。</p>

<h2>Docker 可以节省开销</h2>

<p>当然，时间就是金钱。除了时间外，Docker 还可以节省在基础设施硬件上的开销。高德纳和麦肯锡的研究表明，数据中心的利用率在 6% - 12% 左右。不仅如此，如果采用虚拟机的话，你还需要被动地监控和设置每台虚拟机的 CPU 硬盘和内存的使用率，因为采用了静态分区(static partitioning)所以资源并不能完全被利用。。而容器可以解决这个问题：容器可以在实例之间进行内存和磁盘共享。你可以在同一台主机上运行多个服务、可以不用去限制容器所消耗的资源、可以去限制资源、可以在不需要的时候停止容器，也不用担心启动已经停止的程序时会带来过多的资源消耗。凌晨三点的时候只有很少的人会去访问你的网站，同时你需要比较多的资源执行夜间的批处理任务，那么可以很简单的便实现资源的交换。</p>

<p>虚拟机所消耗的内存、硬盘、CPU 都是固定的，一般动态调整都需要重启虚拟机。而用 Docker 的话，你可以进行资源限制，得益于 CGroup，可以很方便动态调整资源限制，让然也可以不进行资源限制。Docker 容器内的应用对宿主机而言只是两个隔离的应用程序，并不是两个虚拟机，所以宿主机也可以自行去分配资源。</p>

<h2>Docker 有一个健壮的镜像托管系统</h2>

<p>前面提到过，这个托管系统就叫做 Docker Hub Registry。截止到 2015年4月29日，互联网上大约有 14000 个公共的 Docker，而大部分都被托管在 Docker Hub 上面。和 Github 已经很大程度上成为开源项目的代表一样，Docker 官方的 Docker Hub 则已经是公共 Docker 镜像的代表。这些镜像可以作为你应用和数据服务的基础。</p>

<p>也正是得益于此，你可以随意尝试最新的技术：说不定有些人就把图形化数据库的实例打包成了 Docker 镜像托管在上面。再例如 Gitlab，手工搭建 Gitlab 非常困难，译者不建议普通用户去手工搭建，而如果使用 Docker Gitlab，这个镜像则会五秒内便搭建完成。再例如特定 Ruby 版本的 Rails 应用，再例如 Linux 上的 .NET 应用，这些都可以使用简单的一条 Docker 命令搭建完成。</p>

<blockquote>
  <p>Docker 官方镜像都有 official 标签，安全性可以保证。但是第三方镜像的安全性无法保证，所以请谨慎下载第三方镜像。生产环境下可以只使用第三方提供的 Dockerfile 构建镜像。</p>
  
  <p><a rel="nofollow" href="http://www.oschina.net/p/docker-gitlab">Docker Github 介绍：5 秒内搞定一个 Gitlab</a></p>
  
  <p>关于 Linux 上的 .NET 应用和 Rails 应用，将会在以后的文章中做详细介绍。</p>
</blockquote>

<h2>Docker 可以避免产生 Bug</h2>

<p>Spantree 一直是“固定基础设置”（immutable infrastructure）的狂热爱好者。换句话说，除非有心脏出血这种漏洞，我们尽量不对系统做升级，也尽量不去改变系统的设置。当添加新服务器的时候，我们也会从头构建服务器的系统，然后直接将镜像导入，将服务器放入负载均衡的集群里，然后对要退休的服务器进行健康检查，检查完毕后移除集群。得益于 Docker 镜像可以很轻松的导入导出，我们可以最大程度地减少因为环境和版本问题导致的不兼容，即便有不兼容了也可以很轻松地回滚。当然，有了 Docker，我们在生产、测试和开发中的运行环境得到统一。以前在协同开发时，会因为每个人开发的电脑配置不同而导致“在我的电脑上是能运行的，你的怎么不行”的情况，而如今 Docker 已经帮我们解决了这个问题。</p>

<h2>Docker 目前只能运行在 Linux 上</h2>

<p>前面也提到过，Docker 使用的是经过长时间生产环境检验的技术，虽然这些技术已经都出现很长时间了，但是大部分技术都还是 Linux 独有的，例如 LXC 和 Cgroup。也就是说，截止到现在，Docker 容器内只能在 Linux 上运行 Linux 上的服务和应用。Microsoft 正在和 Docker 紧密合作，并且已经宣布了下一个版本的 Windows Server 将会支持 Docker 容器，并且命名为 Windows Docker，估计采用的技术应该是Hyper-V Container，我们有望在未来的几年内看到这个版本。</p>

<p>除此之外，类似 boot2docker 和 Docker Machine 这种工具已经可以让我们在 Mac 和 Windows 下通过虚拟机运行 Docker 了。</p>

<h2>后记</h2>

<p>悄悄的说一句，前文中提到的 <a rel="nofollow" href="http://segmentfault.com/a/1190000002711327">Docker 安装</a>、<a rel="nofollow" href="http://segmentfault.com/a/1190000002711327">Docker 操作</a>、<a rel="nofollow" href="http://segmentfault.com/a/1190000002711357">Dockerfile</a>、<a rel="nofollow" href="http://segmentfault.com/a/1190000002711379">Docker Hub</a>、搭建 Rails 环境、甚至搭建 .NET 环境，SegmentFault 正在组织编写相关的文档，欢迎关注我们，及时获取更多最新的教程。</p>

2015年五月6日下午 4:27:46
改写了memwatch的代码，支持v0.11之后的nodejs
<div class="markdown-text"><p>具体位置是
<a href="https://github.com/crystaldust/node-memwatch/tree/higher-than-v10">https://github.com/crystaldust/node-memwatch/tree/higher-than-v10</a></p>
<p>npm 安装：
<code>npm install memwatch@git://github.com/crystaldust/node-memwatch.git#higher-than-v10</code></p>
<p>小弟没怎么弄过v8下的编程，所以也是一边找资料一边学习一边修改的。欢迎大家测试拍砖。附上截图：
<img src="//dn-cnode.qbox.me/Fqg4_HFLaRvAvTqyHNzx-oCUYLcz" alt="memwatch.jpg"></p>
<p><img src="//dn-cnode.qbox.me/Fl2m1daEMnrfsMEDnklbgsAVJlhL" alt="memwatch2.jpg"></p>
</div>

2015年五月6日下午 4:00:21
websocket和HTTP使用不同端口可以吗
<div class="markdown-text"><p>比如：HTTP监听端口80，websocket想分离到专门的服务器上监听端口6180
浏览器端会存在安全限制吗？</p>
</div>

2015年五月6日下午 3:53:49
要记录用户点击不同链接的次数，是每次用户点击都去插入数据库还是有什么策略？
<div class="markdown-text"><p>要记录用户点击不同链接的次数，是每次用户点击都去插入数据库还是有什么策略？</p>
</div>

2015年五月6日下午 3:48:33
惊爆！Node.js 和 io.js 准备合并
<div class="markdown-text"><p>因为对Node.js管理方Joyent公司不满，多位核心开发者自创门户建立了分支io.js，其开发非常活跃，甚至刚刚发布了 io.js 2.0.0。
而如今，不到半年时间，两个项目突然就化敌为友了。两个互相竞争的项目如今正在Node.js基金会的名义下准备合并，合并完成之后github.org/iojs项目的所有权将转移到Node.js基金会，iojs.org 和nodejs.org域名的所有权以及相关社交媒体账号也都将转移给Node.js基金会。</p>
<p>原文：<a href="http://www.solidot.org/story?sid=43951">http://www.solidot.org/story?sid=43951</a></p>
</div>

2015年五月6日下午 3:06:36
用async并发执行几个函数，同时写入一个全局的变量，是否保证有序？
<div class="markdown-text"><p>事情是这样的，产品的同事希望在一个用户列表中，按照不同的标准选取几类用户（假设有A, Bl两种用户），然后同时呈现。但是有些用户可能同时满足2个标准，比如某个用户既符合A标准，也符合B标准，这样返回的结果如果不加限定，就会出现同一个用户出现多次的情况。</p>
<p>现在我是这么考虑的，先去找A类的用户，查找结束后，把A类用户的_id传递给第二个函数，第二个函数在查找B类用户时候，把第所有A类用户的_id都剔除掉。程序结构大概是这样：</p>
<pre class="prettyprint"><code>

var exclude = [];

async.series( [
    function( callback ) {
        db.collection(&#x27;users&#x27;).find( { /*category A的条件*/} ).toArray( function( err, users ) {
            users.forEach( function( user ) {
                exclude.push( user._id );
            } );
            callback( null, users );
        } )
    },

    function( callback ) {
        db.collection(&#x27;users&#x27;).find( { /*category B的条件*/ _id : { $not : { $in : exclude } }/*限定不包含category A的用户*/ } ).toArray( function( err, users ) {
            callback( null, users );
        } )
    }

], function( err, result ) {
    var users_A = result[0];
    var users_B = result[1];
    // Handle category A and B...   
} )

</code></pre><p>为了保证不重复，需要A执行完后在执行B。顺序执行，响应时间太长。如果改成并发执行，那么每个函数去查找用户时，都要包含{$not : { $in : exclude } }条件。关键是是否会出现这样一种情况：
第一个函数先执行回调，然后向exclude写入id，还没有写完时，第二个函数执行回调了，但是exclude还是空的，那么exclude的限定在第二个函数里其实就没有作用了。</p>
<p>小弟表达能力较差，说的不清楚的地方，还请大家指出，期待各路高手给点儿意见啊，跪谢先 m( _ _ ) m</p>
</div>

2015年五月6日下午 3:04:45
哪位大神 帮忙指点 uglifyjs 怎么批量压缩
<div class="markdown-text"><p>已安装
1、node.js
2、uglifyjs</p>
</div>

2015年五月6日下午 2:37:25
求bower转spm的回答
<div class="markdown-text"><p>项目最近因为变动，计划从bower转spm。毕竟方便很多。但是项目本身bower 的很多文件在spm上没有。大神们怎么解决的？
直接复制过去，然后依次放到spmmodules的组件对应的版本目录，直接引用还是？对spm机制不太了解。特来求教。
引用的包有点多＝，＝
求解答。</p>
<blockquote>
<pre class="prettyprint"><code>&quot;angular&quot;: &quot;~1.3.11&quot;,
</code></pre></blockquote>
<pre class="prettyprint"><code>&quot;angular-animate&quot;: &quot;~1.3.11&quot;,
&quot;angular-cookies&quot;: &quot;~1.3.11&quot;,
&quot;angular-resource&quot;: &quot;~1.3.11&quot;,
&quot;angular-sanitize&quot;: &quot;~1.3.11&quot;,
&quot;angular-touch&quot;: &quot;~1.3.11&quot;,
&quot;angular-translate&quot;: &quot;~2.5.2&quot;,
&quot;angular-translate-loader-static-files&quot;: &quot;~2.5.2&quot;,
&quot;angular-translate-storage-cookie&quot;: &quot;~2.5.2&quot;,
&quot;angular-translate-storage-local&quot;: &quot;~2.5.2&quot;,
&quot;angular-bootstrap&quot;: &quot;~0.12.0&quot;,
&quot;angular-bootstrap-nav-tree&quot;: &quot;*&quot;,
&quot;angular-ui-router&quot;: &quot;~0.2.11&quot;,
&quot;angular-ui-utils&quot;: &quot;~0.2.1&quot;,
&quot;angular-file-upload&quot;: &quot;~1.1.1&quot;,
&quot;angular-ui-select&quot;: &quot;~0.8.3&quot;,
&quot;angular-ui-calendar&quot;: &quot;latest&quot;,
&quot;angular-ui-grid&quot;: &quot;~3.0.0-rc.16&quot;,
&quot;angular-xeditable&quot;: &quot;~0.1.8&quot;,
&quot;angular-smart-table&quot;: &quot;~1.4.9&quot;,
&quot;angularjs-toaster&quot;: &quot;~0.4.8&quot;,
&quot;ng-grid&quot;: &quot;~2.0.13&quot;,
&quot;ngImgCrop&quot;: &quot;~0.2.0&quot;,
&quot;ngstorage&quot;: &quot;~0.3.0&quot;,
&quot;oclazyload&quot;: &quot;~0.5.1&quot;,
&quot;textAngular&quot;: &quot;~1.2.2&quot;,
&quot;venturocket-angular-slider&quot;: &quot;~0.3.2&quot;,
&quot;videogular&quot;: &quot;~0.7.0&quot;,
&quot;videogular-controls&quot;: &quot;~0.7.0&quot;,
&quot;videogular-buffering&quot;: &quot;~0.7.0&quot;,
&quot;videogular-overlay-play&quot;: &quot;~0.7.0&quot;,
&quot;videogular-poster&quot;: &quot;~0.7.0&quot;,
&quot;videogular-ima-ads&quot;: &quot;~0.7.0&quot;,
&quot;jquery&quot;: &quot;~2.1.3&quot;,
&quot;animate.css&quot;: &quot;~3.2.0&quot;,
&quot;bootstrap&quot;: &quot;~3.3.0&quot;,
&quot;bootstrap-filestyle&quot;: &quot;~1.1.2&quot;,
&quot;bootstrap-slider&quot;: &quot;*&quot;,
&quot;bootstrap-touchspin&quot;: &quot;~3.0.1&quot;,
&quot;bootstrap-wysiwyg&quot;: &quot;*&quot;,
&quot;bower-jvectormap&quot;: &quot;~1.2.2&quot;,
&quot;bootstrap-chosen&quot;: &quot;~1.0.0&quot;,
&quot;chosen&quot;: &quot;https://github.com/harvesthq/chosen/releases/download/v1.3.0/chosen_v1.3.0.zip&quot;,
&quot;datatables&quot;: &quot;~1.10.4&quot;,
&quot;plugins&quot;: &quot;datatables/plugins#~1.0.1&quot;,
&quot;footable&quot;: &quot;~2.0.3&quot;,
&quot;font-awesome&quot;: &quot;~4.2.0&quot;,
&quot;fullcalendar&quot;: &quot;~2.2.6&quot;,
&quot;html5sortable&quot;: &quot;*&quot;,
&quot;moment&quot;: &quot;~2.8.3&quot;,
&quot;nestable&quot;: &quot;*&quot;,
&quot;screenfull&quot;: &quot;~1.2.1&quot;,
&quot;slimscroll&quot;: &quot;~1.3.3&quot;,
&quot;simple-line-icons&quot;: &quot;~0.1.1&quot;,
&quot;jquery_appear&quot;: &quot;~0.3.3&quot;,
&quot;jquery.easy-pie-chart&quot;: &quot;~2.1.6&quot;,
&quot;jquery.sparkline&quot;: &quot;~2.1.2&quot;,
&quot;flot&quot;: &quot;~0.8.3&quot;,
&quot;flot.tooltip&quot;: &quot;~0.8.4&quot;,
&quot;flot.orderbars&quot;: &quot;*&quot;,
&quot;bootstrap-daterangepicker&quot;: &quot;~1.3.17&quot;,
&quot;bootstrap-tagsinput&quot;: &quot;~0.4.2&quot;</code></pre></div>

2015年五月6日下午 1:56:44
在本地页面通过一个按钮调用系统linux命令
<div class="markdown-text"><p>在本地页面通过一个按钮调用系统linux命令，初学node不知道怎么用
一下是一段调用系统命令的node代码，单独用 node test.js 命令测试正常，现在我想加进一个本地的HTML代码中，请问怎么添加？
var exec = require(‘child_process’).exec;</p>
<p>exec(&quot;python test.py&quot;, function(error, stdout, stderr){
if ( !error ) {
console.log(stdout);
} else {
console.log(error);
}
});</p>
</div>

2015年五月6日下午 12:44:09
正则表达式笔记（三）
<h2>String.replace</h2>

<p>细心的读者可能会发现，上篇文章我们遗漏了 <code>String.replace</code> 这个方法。<code>String.replace</code> 在 JS 中有着更加强大的用法和灵活性，所以这里剥离出来单独介绍。</p>

<h3>API</h3>

<pre><code>String.replace(searchValue, replacement)
</code></pre>

<p><code>String.replace</code> 同时支持进行正则表达式或者字符串替换，并返回一个新的字符串。因为我们的主题是正则表达式，所以接下来的内容，会以正则替换的情况为主。</p>

<p>默认情况下，<code>String.replace</code>只进行一次替换。若设置了 <code>g</code> 模式，则所有匹配到的字符串都会替换</p>

<h3>参数说明</h3>

<ul>
<li>String: 需要替换的字符串</li>
<li>searchValue: 字符串或者正则表达式</li>
<li>replacement: 字符串或者函数</li>
</ul>
<h3>用法</h3>

<p><strong>字符串替换</strong></p>

<pre><code>'I am back end developer'.replace('back','front');
//"I am front end developer"
</code></pre>

<p>直接把字符串中的 <code>back</code> 替换成 <code>front</code>。当字符串中有两个 <code>back</code>，情况回事怎样呢？</p>

<pre><code>'I am back end developer, you are back end developer'.replace('back','front');
//"I am front end developer, you are back end developer"
</code></pre>

<p>可以看到，第2个 <code>back</code>，并没有被替换。如果需要把其他 <code>back</code> 也一起替换，这个时候就需要用到正则表达式。</p>

<p><strong>正则表达式替换</strong></p>

<p>设置了 <code>g</code> 模式，全局替换。</p>

<pre><code>'I am back end developer, you are back end developer'.replace(/back/g,'front');
//"I am front end developer, you are front end developer"
</code></pre>

<p>在 <code>replacement</code> 字符串中，还有一些特殊的变量可以使用。</p>

<table>
<thead><tr>
<th>特殊变量</th>
  <th>说明</th>
</tr></thead>
<tbody>
<tr>
<td>$1,$2,$3...$n</td>
  <td>表示对应捕获分组匹配的文本</td>
</tr>
<tr>
<td>$&amp;</td>
  <td>与正则相匹配的字符串</td>
</tr>
<tr>
<td>$$</td>
  <td>'$' 字符</td>
</tr>
<tr>
<td>$`</td>
  <td>匹配字符串左边的字符</td>
</tr>
<tr>
<td>$'</td>
  <td>匹配字符串右边的字符</td>
</tr>
</tbody>
</table>
<p><strong>有趣的字符串替换</strong></p>

<p>使用 <code>$&amp;</code> 操作匹配的字符串。</p>

<pre><code>var str = '有趣的字符串替换';
str.replace(/有趣的字符串/,'($&amp;)');

//"(有趣的字符串)替换"
</code></pre>

<p>使用 <code>$$</code> 声明 <code>$</code> 字符。</p>

<pre><code>var str = '这个商品的价格是12.99';
str.replace(/\d+\.\d{2}/,'$$$&amp;');

//"这个商品的价格是$12.99"
</code></pre>

<p>使用 $` 和 $' 字符替换内容</p>

<pre><code>'abc'.replace(/b/,"$`");//aac
'abc'.replace(/b/,"$'");//acc
</code></pre>

<p>使用分组匹配组合新的字符串</p>

<pre><code>'2015-05-06'.replace(/(\d{4})-(\d{2})-(\d{2})/,"$3/$2/$1")
//"06/05/2015"
</code></pre>

<h3>函数参数</h3>

<p>当<code>replacement</code>是一个函数参数的时候，对字符串操作的灵活性将有一个质的提高。</p>

<p><strong>说明</strong></p>

<pre><code>'Stirng.replace'.replace(/(\w+)(\.)(\w+)/,function(){
    console.log(arguments) // ["Stirng.replace", "Stirng", ".", "replace", 0, "Stirng.replace"]
    return '返回值会替换掉匹配到的字符'
})
</code></pre>

<table>
<thead><tr>
<th>参数</th>
  <th>说明</th>
</tr></thead>
<tbody>
<tr>
<td>match</td>
  <td>匹配到的字符串（此例为 String.replace）</td>
</tr>
<tr>
<td>p1, p2, ...</td>
  <td>正则使用了分组匹配时分组文本，否则无此参数（此例为 "Stirng", ".", "replace"）</td>
</tr>
<tr>
<td>offset</td>
  <td>匹配字符串的对应索引位置 （此例为 0）</td>
</tr>
<tr>
<td>source</td>
  <td>原始字符串（此例为 String.replace）</td>
</tr>
</tbody>
</table>
<p><strong>案例 -- 样式属性的转换</strong></p>

<p>把驼峰字符转换为 <code>-</code> 连接符形式</p>

<pre><code>'borderTop'.replace(/[A-Z]/g,function(m){
    return '-'+ m.toLowerCase()
})

//"border-top"
</code></pre>

<p>把 <code>-</code> 连接符形式转换为驼峰形式</p>

<pre><code>'border-top'.replace(/-\w/g,function(m){
    return m.slice(1).toUpperCase()
})

//"borderTop"
</code></pre>

<h3>最后的牛刀小试</h3>

<p>交给阅读者发挥的内容：</p>

<p>需要将<code>Hello-World</code>使用正则替换成 <code>HWeolrllod</code></p>

2015年五月6日下午 12:34:48
alsotang pushed to online at cnodejs/nodeclub
<!-- push -->
<span class="mega-octicon octicon-git-commit"></span>

<div class="time">
  <time datetime="2015-05-06T04:34:48Z" is="relative-time">May 6, 2015</time>
</div>

<div class="title">
  <a href="https://github.com/alsotang" data-ga-click="News feed, event click, Event click type:PushEvent target:actor">alsotang</a> <span>pushed</span> to <a href="/cnodejs/nodeclub/tree/online" data-ga-click="News feed, event click, Event click type:PushEvent target:branch">online</a> at <a href="https://github.com/cnodejs/nodeclub" data-ga-click="News feed, event click, Event click type:PushEvent target:repo">cnodejs/nodeclub</a>
</div>

<div class="details">
  <a href="https://github.com/alsotang"><img alt="@alsotang" class="gravatar" data-user="1147375" height="30" src="https://avatars0.githubusercontent.com/u/1147375?v=3&amp;s=60" width="30" /></a>

    <div class="commits pusher-is-only-committer">
      <ul>
        <li>
          <span title="alsotang">
            <img alt="@alsotang" data-user="1147375" height="16" src="https://avatars1.githubusercontent.com/u/1147375?v=3&amp;s=32" width="16" />
          </span>
          <code><a href="/cnodejs/nodeclub/commit/5c32926e7e056355b8f64e275ee5c90402f6d6f0" data-ga-click="News feed, event click, Event click type:PushEvent target:sha">5c32926</a></code>
          <div class="message">
            <blockquote>
              coding.net
            </blockquote>
          </div>
        </li>
        <li>
          <span title="alsotang">
            <img alt="@alsotang" data-user="1147375" height="16" src="https://avatars1.githubusercontent.com/u/1147375?v=3&amp;s=32" width="16" />
          </span>
          <code><a href="/cnodejs/nodeclub/commit/432b8a4932f5b43c4dc89e18a448365e00772d61" data-ga-click="News feed, event click, Event click type:PushEvent target:sha">432b8a4</a></code>
          <div class="message">
            <blockquote>
              qiniu
            </blockquote>
          </div>
        </li>
        <li class="more"><a href="https://github.com/cnodejs/nodeclub/compare/a49c47998c...5c32926e7e" data-ga-click="News feed, event click, Event click type:PushEvent target:comparison">3 more commits &raquo;</a></li>
      </ul>
    </div>
</div>

2015年五月6日下午 12:33:48
alsotang pushed to online at cnodejs/nodeclub
<!-- push -->
<span class="mega-octicon octicon-git-commit"></span>

<div class="time">
  <time datetime="2015-05-06T04:33:48Z" is="relative-time">May 6, 2015</time>
</div>

<div class="title">
  <a href="https://github.com/alsotang" data-ga-click="News feed, event click, Event click type:PushEvent target:actor">alsotang</a> <span>pushed</span> to <a href="/cnodejs/nodeclub/tree/online" data-ga-click="News feed, event click, Event click type:PushEvent target:branch">online</a> at <a href="https://github.com/cnodejs/nodeclub" data-ga-click="News feed, event click, Event click type:PushEvent target:repo">cnodejs/nodeclub</a>
</div>

<div class="details">
  <a href="https://github.com/alsotang"><img alt="@alsotang" class="gravatar" data-user="1147375" height="30" src="https://avatars0.githubusercontent.com/u/1147375?v=3&amp;s=60" width="30" /></a>

    <div class="commits pusher-is-only-committer">
      <ul>
        <li>
          <span title="alsotang">
            <img alt="@alsotang" data-user="1147375" height="16" src="https://avatars1.githubusercontent.com/u/1147375?v=3&amp;s=32" width="16" />
          </span>
          <code><a href="/cnodejs/nodeclub/commit/a49c47998c0320496b2d94dcd5196a074632ffcd" data-ga-click="News feed, event click, Event click type:PushEvent target:sha">a49c479</a></code>
          <div class="message">
            <blockquote>
              coding.net
            </blockquote>
          </div>
        </li>
      </ul>
    </div>
</div>

2015年五月6日中午 12:08:31
推荐一款可以在iPhone和iPad上读nodejs官方文档的app
<div class="markdown-text"><h5>专门为nodejs doc开发的，比dash的阅读体验更好，比如代码的高亮，链接的处理等。目前只支持iOS8</h5>
<h5>下载地址</h5>
<p><a href="https://itunes.apple.com/cn/app/nodejs-api/id983630798?mt=8"> https://itunes.apple.com/cn/app/nodejs-api/id983630798?mt=8</a></p>
<p><img src="//dn-cnode.qbox.me/FjCqMwBHB79PK_bX8AFqj4swCQPs" alt="下载.png"></p>
<h5>页面截图</h5>
<p><img src="//dn-cnode.qbox.me/FmwAOi6THu3Vr-fljNJw_cwcWcCl" alt="首页"></p>
<p><img src="//dn-cnode.qbox.me/Fok6aNeGE4P5qK0_uZaygYyBIGWU" alt="api 详情"></p>
<p><img src="//dn-cnode.qbox.me/FsCKI2Bx3m27ElhmlYQ5JL_Ot6yt" alt="分类"></p>
</div>

2015年五月6日中午 11:58:58
[产品更新] SegmentFault 全新文章专栏上线
<p>经过半个多月的努力，全新的 SegmentFault 文章终于和大家见面了。这次的全新改版，我们提出了文章专栏的理念：</p>

<ol>
<li>所有用户都可以拥有自己的专栏</li>
<li>将更加注重和鼓励原创且具有启发性的用户内容</li>
<li>对相关的声望值做出调整<br><br>
</li>
</ol>
<h2>关于原创和启发性</h2>

<blockquote>
  <p><strong>原创的文章是自己学习和探索的结果，独立的思考会给他人更大的启发，会引导他人去发现、实现可能更加有趣的事。</strong></p>
</blockquote>

<p>故此，我们将更加注重和鼓励原创：</p>

<p>新版文章将在<a rel="nofollow" href="http://segmentfault.com/user/settings?tab=blog">专栏设置页</a>增加版权信息注明，原创文章将不再受版权问题的困扰。同时，专栏的首篇文章也将会被官方审阅，这也是对于原创优秀内容的鼓励。</p>

<p><img src="/img/bVlCQq" alt="版权信息设置.jpg"></p>

<h2>私人的，也是所有人的专栏</h2>

<p>新版文章所有用户都将可以开始撰写自己的专栏：已经开通过博客的老用户，博客将自动升级为的专栏；还没有开通博客的用户，现在可以直接<a rel="nofollow" href="http://segmentfault.com/blog/add">开通专栏</a>了。</p>

<p>我们后续会推出官方认证专栏，如果你的文章写得足够好，会出现在网站所有用户的时间线上，这便是私人的、也是所有人的专栏。</p>

<h2>相关声望值调整</h2>

<p>新版文章的声望值权重也会相应作出上调：文章被投推荐票 +10，文章被收藏 +5。另外，如果你的文章被推作官方推荐文章或者精选文章，都会有相应的声望值增加，当然，推荐与加精更多是对你内容价值的认可。</p>

<p><br><br>
其他更多的细节与优化，由你们来发现。</p>

<p>这是一个简易的技术专栏，是学习与分享知识的工具。这将是你的私人文章，请认真地撰写；这也将会是所有人的文章，热心地与大家切磋共享。</p>

<hr>
<blockquote>
  <p>相关的产品建议和反馈提交请到我们的社区建设：<a rel="nofollow" href="http://segmentfault.com/0x">0x.sf.gg</a><br>
  相关的技术 bug 提交请到我们的 GitHub Report：<a rel="nofollow" href="https://github.com/SegmentFault/report">SegmentFault Report</a></p>
</blockquote>

2015年五月6日中午 11:51:44
Cnode社区回复操作是否为bug?
<div class="markdown-text"><p>我在一个话题下添加回复完毕后，想跳回上一页页面，第一次点击浏览器的回退的按钮，却回不到上一页面，第二次点击就可以，是故意这样设计的还是？我是小白，请大神指点</p>
</div>

2015年五月6日中午 11:44:28
寻求一种方式重启node的方式
<div class="markdown-text"><p>虽然说生产环境老是重启不是很安全，但每次更新版本时都需要找PE来重启node，感觉好麻烦，有没有类似LAMP那种方式，比如我修改完php代码上线后能立即运行，nodemon启动方式不算。求大神们指点迷津。</p>
</div>

2015年五月6日中午 11:41:58
alsotang commented on commit cnodejs/nodeclub@0f6cc14f6b
<!-- commit_comment -->
<span class="mega-octicon octicon-comment-discussion"></span>

<div class="time">
  <time datetime="2015-05-06T03:41:58Z" is="relative-time">May 6, 2015</time>
</div>

<div class="title">
  <a href="https://github.com/alsotang" data-ga-click="News feed, event click, Event click type:CommitCommentEvent target:actor">alsotang</a> <span>commented</span> on commit <a href="https://github.com/cnodejs/nodeclub/commit/0f6cc14f6bcbbe6b4de3199c6896efaec637693e#commitcomment-11058600" data-ga-click="News feed, event click, Event click type:CommitCommentEvent target:commit-comment">cnodejs/nodeclub@0f6cc14f6b</a>
</div>

<div class="details">
  <a href="https://github.com/alsotang"><img alt="@alsotang" class="gravatar" data-user="1147375" height="30" src="https://avatars0.githubusercontent.com/u/1147375?v=3&amp;s=60" width="30" /></a>
  <div class="message markdown-body">
    <blockquote>
      <p>是的 2015-05-06 11:37 GMT+08:00 Jackson Tian &lt;notifications@github.com&gt;:
</p>
    </blockquote>
  </div>
</div>

2015年五月6日上午 11:01:32
[北京] NodeJS 前端后端开发攻城狮1名 8K-16K
<div class="markdown-text"><p>【关于我们】
公司成立于14年底，核心团队成员来自IBM，联想，百度，并具有10年以上的丰富经验。现从事校园生活相关的移动互联网项目，因团队高速发展需要，急招有志于用技术改变生活的nodejs 前后端攻城狮1名</p>
<p>【任职要求】
Requirements</p>
<pre class="prettyprint"><code>* Strong Javascript skills
* Knowledge of Node.js packages (Express, Async, Mongoose, Socket.io, Request, etc.)
* Experience with message and job queuing services (RabbitMQ, Redis, etc.)
* Very strong ability to design and develop scalable systems on top of Node.js
* Experience working with MongoDB, Mysql and Redis.
* Disciplined approach to testing and quality assurance, knowledge of Javascript testing tools.
* High understanding of computer science concepts such as: common data structures and algorithms, profiling/optimization
</code></pre><p>Responsibilities</p>
<pre class="prettyprint"><code>* Build and deploy robust, manageable and scalable back ends
* Integrate 3rd party services via RESTful and streaming APIs
* Design and implement RESTful interfaces that exposes our data
* Rapidly fix bugs and solve problems
* Work closely with front-end teams to create optimally integrated solutions
* Plus Point:  have experience ionic framework and wechat JS SDK
</code></pre><p>【关于职位】
NodeJS 前端&amp;后端开发工程师
工作地点：北京.海淀.上地
工作年限：3年以上
最低学历：本科
招聘人数：1
职位月薪：￥8 ,000 - 16,000
英语：读写流利，英语六级</p>
<p>【联系我们】
有意者请将您的简历直接直接发送至<a href="mailto:hr@guagua2shou.com">hr@guagua2shou.com</a>,我们会尽快回复您，谢谢！</p>
</div>

2015年五月6日上午 9:52:37
nodejs对http协议的支持
<div class="markdown-text"><p>http协议的method
安全方法：HEAD, GET, OPTIONS, and TRACE
不安全的方法：POST, PUT and DELETE
测试了一下发现其中的Trace方法返回error；
想问下各位大神。这个trace方法会返回什么。怎么开启看看。</p>
</div>

2015年五月6日上午 9:36:35
在阿里云使用npm安装pm2一直加载
<div class="markdown-text"><p><img src="//dn-cnode.qbox.me/Fj-iY-OzGKTizIW6cs_OSXdSr3J0" alt="untitled1.png"></p>
</div>

2015年五月6日早上 8:37:59
io.js前天发布了2.0.0版本
<div class="markdown-text"><p><a href="https://iojs.org/cn/releases.html">io.js v2.0.0</a>
<a href="https://github.com/iojs/io.js/blob/v2.0.0/CHANGELOG.md">changelog</a>
大版本变化。
更稳定了么？</p>
</div>

2015年五月6日早上 7:10:15
[成都]GamEver招2名手游服务器端Nodejs工程师7~15k
<div class="markdown-text"><p><strong>关于我们（热血，专注，快乐，成长，勇敢，创造力）</strong></p>
<p>我们是一群对游戏非常热爱，专注于制作精品的单纯家伙
多年的打磨学会了在商业和艺术之间寻找平衡
平均从业经验5年以上, 聚焦海外市场
行业顶尖美术和金牌制作人，资深欧美制作经验
产品专注三个核心：Creative, Passionate, Imapctive</p>
<p>公司成立于2014年1月，规模25人，现在已有一款上市产品Age of warriors,(中国区暂时还没上线）<strong>获得了美国区苹果APPSTORE三次全球首页推荐。</strong></p>
<p>我们期待的伙伴:
<strong>3d客户端程序：</strong></p>
<p>至少熟悉一种3d游戏引擎。
熟悉openGL图形管线，能独立学习制作游戏需要的shader效果
有扎实的c++编码功底
爱好技术，踏实好学，对游戏有爱</p>
<p><strong>服务器程序：</strong></p>
<p><strong>踏实靠谱，热爱游戏
不需要您一定要是技术大牛，只要你基础扎实愿意接受新技术，快速学习
1~2年编码经验，熟悉nodejs，mongodb，或者python，ruby，mysql，erlang
团队协作精神，自我管理良好，有工程师文化基因。
善于沟通，有同理心</strong></p>
<p><strong>系统/数值/UI策划:</strong></p>
<p>踏实靠谱，心态开放成熟，渴望做出富有灵魂的作品
有激情,有动力,平时热衷于各种平台的游戏
游戏经验丰富,了解各类游戏的特色与设计思路
熟悉玩家的消费行为以及游戏行为，喜欢和玩家一起交流
良好的语言沟通和书面表达能力(熟悉策划案撰写,意图表达明确,条理清晰)
严密谨慎的逻辑能力，对RPG以及SLG类游戏数值平衡有独特兴趣和偏好
或者擅长UI设计,熟悉至少一种动画关卡编辑器
有较好的英文阅读和书面日常交流能力</p>
<p><strong>游戏文案策划：</strong></p>
<p>沟通能力好，主动性责任心强。
有激情,有动力,平时热衷于各种平台的游戏。
拥有游戏经验丰富,了解各类游戏的特色与设计思路 。
熟悉玩家的群体，喜欢和玩家一起交流。
良好的语言沟通和书面表达能力(能熟练撰写有想象力的文案剧情和幽默的人物对白)。
喜欢看美剧，看小说，熟悉玩家语言。</p>
<p>具有较好的英文阅读写作能力。</p>
<p><strong>游戏UI设计美术：</strong></p>
<p>有丰富的UI设计经验，
热爱游戏，对各种题材的UI又自己独到见解
3年以上工作经验为佳。</p>
<p><strong>FlashUI美术：</strong></p>
<p>熟悉flash，懂基本as2.0
熟悉各种动画制作和特效制作。
有1到2年flash制作经验
如果有个人业余小游戏作品，那是极好的。</p>
<p><strong>我们将提供给您:</strong>
7~15k左右的基本薪资待遇(具体和能力挂钩)
每年最高4次项目奖金，年底双薪
节假日过节奖金，项目完成后的集体旅行
灵活可变的弹性上班时间，宽松自由的团队氛围
一群靠谱的伙伴，快乐生活，做好游戏
低层级公司，没有不做事混日子的伙伴。
每一个产品都会是精品设计，绝对不会开发浪费大家光阴的项目。
好的技术学习讨论氛围
macpro笔记本开发</p>
<p>如果您也对制作游戏充满热忱，渴望能有一群靠谱的伙伴一起快乐工作，一起旅行，一起开创未来！请联系<a href="mailto:xiao.wen@gamever.org">xiao.wen@gamever.org</a>
<img src="//dn-cnode.qbox.me/FmTwEfps_1aOlnLVhAb5PVfaEPq9" alt="screen696x696.jpeg"></p>
</div>

2015年五月6日早上 6:51:43
关于Express中使用req.pipe(busboy)的用途是什么？是多文件上传吗？
<div class="markdown-text"><p>大家好：</p>
<p>我在看源码时，发现req.pipe方法，但在google上没有找到解释其具体是什么含义？（我猜是不是，多文件上传的意思？）
express API上也没有找到。</p>
<p>坛子里的先闻道者，麻烦帮忙下，谢谢。</p>
<p>code:
exports.upload = function (req, res, next) {
req.busboy.on('file’, function (fieldname, file, filename, encoding, mimetype) {
store.upload(file, {filename: filename}, function (err, result) {
if (err) {
return next(err);
}
res.json({
success: true,
url: result.url,
});
});
});</p>
<p>req.pipe(req.busboy);
};</p>
</div>

2015年五月6日凌晨 12:50:57
异步流程控制：7 行代码学会 co 模块
<p>首先请原谅我的标题党(●—●)，tj 大神的 co 模块源码200多行，显然不是我等屌丝能随便几行代码就能重写的。只是当今大家都喜欢《7天学会xx语言》之类的速效仙丹，于是我也弄个类似的名字《7行代码学会co模块》来博眼球。</p>

<p>为了避免被拖出去弹小JJ，还是先放出所谓的 7 行代码给大家压压惊：</p>

<pre><code>function co(gen) {
    var it = gen();
    var ret = it.next();
    ret.value.then(function(res) {
        it.next(res);
    });
} 
</code></pre>

<h2>万恶的回调</h2>

<p>对前端工程师来说，异步回调是再熟悉不过了，浏览器中的各种交互逻辑都是通过事件回调实现的，前端逻辑越来越复杂，导致回调函数越来越多，同时 nodejs 的流行也让 javascript 在后端的复杂场景中得到应用，在 nodejs 代码中更是经常看到层层嵌套。</p>

<p>以下是一个典型的异步场景：先通过异步请求获取页面数据，然后根据页面数据请求用户信息，最后根据用户信息请求用户的产品列表。过多的回调函数嵌套，使得程序难以维护，发展成<a rel="nofollow" href="http://callbackhell.com/">万恶的回调</a>。</p>

<pre><code>javascript</code><code>$.get('/api/data', function(data) {
    console.log(data);
    $.get('/api/user', function(user) {
        console.log(user);
        $.get('/api/products', function(products) {
            console.log(products)
        });
    });
});
</code></pre>

<h2>异步流程控制</h2>

<ul>
<li><p>最原始异步流程的写法，就是类似上面例子里的回调函数嵌套法，用过的人都知道，那叫一个酸爽。</p></li>
<li><p>后来出现了 Promise ，它极大提高了代码的可维护性，消除了万恶的回调嵌套问题，并且现在已经成为 ES6 标准的一部分。</p></li>
</ul>
<pre><code>$.get('/api/data')
.then(function(data) {
    console.log(data);
    return $.get('/api/user');
})
.then(function(user) {
    console.log(user);
    return $.get('/api/products');
})
.then(function(products) {
    console.log(products);
});
</code></pre>

<ul>
<li>之后在 nodejs 圈出现了 co 模块，它基于 ES6 的 generator 和 yield ，让我们能用同步的形式编写异步代码。</li>
</ul>
<pre><code>co(function *() {
    var data = yield $.get('/api/data');
    console.log(data);
    var user = yield $.get('/api/user');
    console.log(user);
    var products = yield $.get('/api/products');
    console.log(products);
});
</code></pre>

<ul>
<li>以上的 Promise 和 generator 最初创造它的本意都不是为了解决异步流程控制。其中 Promise 是一种编程思想，用于“当xx数据准备完毕，then执行xx动作”这样的场景，不只是异步，同步代码也可以用 Promise。而 generator 在 ES6 中是迭代器生成器，被 TJ 创造性的拿来做异步流程控制了。真正的异步解决方案请大家期待 ES7 的 async 吧！本文以下主要介绍 co 模块。</li>
</ul>
<h2>co 模块</h2>

<p>上文已经简单介绍了co 模块是能让我们以同步的形式编写异步代码的 nodejs 模块，主要得益于 ES6 的 generator。nodejs &gt;= 0.11 版本可以加 <code>--harmony</code> 参数来体验 ES6 的 generator 特性，iojs 则已经默认开启了 generator 的支持。</p>

<p>要了解 co ，就不得不先简单了解下 ES6 的 generator 和 iterator。</p>

<h3>Iterator</h3>

<p>Iterator 迭代器是一个对象，知道如何从一个集合一次取出一项，而跟踪它的当前序列所在的位置，它提供了一个next()方法返回序列中的下一个项目。</p>

<pre><code>javascript</code><code>var lang = { name: 'JavaScript', birthYear: 1995 };
var it = Iterator(lang);
var pair = it.next(); 
console.log(pair); // ["name", "JavaScript"]
pair = it.next(); 
console.log(pair); // ["birthYear", 1995]
pair = it.next(); // A StopIteration exception is thrown
</code></pre>

<p>乍一看好像没什么奇特的，不就是一步步的取对象中的 key 和 value 吗，<code>for ... in</code>也能做到，但是把它跟 generator 结合起来就大有用途了。</p>

<h3>Generator</h3>

<p>Generator 生成器允许你通过写一个可以保存自己状态的的简单函数来定义一个迭代算法。<br>
Generator 是一种可以停止并在之后重新进入的函数。生成器的环境（绑定的变量）会在每次执行后被保存，下次进入时可继续使用。generator 字面上是“生成器”的意思，在 ES6 里是迭代器生成器，用于生成一个迭代器对象。</p>

<pre><code>function *gen() {
    yield 'hello';
    yield 'world';
    return true;
}
</code></pre>

<p>以上代码定义了一个简单的 generator，看起来就像一个普通的函数，区别是<code>function</code>关键字后面有个<code>*</code>号，函数体内可以使用<code>yield</code>语句进行流程控制。</p>

<pre><code>javascript</code><code>var iter = gen();
var a = iter.next();
console.log(a); // {value:'hello', done:false}
var b = iter.next();
console.log(b); // {value:'world', done:false}
var c = iter.next();
console.log(c); // {value:true, done:true}
</code></pre>

<p>当执行<code>gen()</code>的时候，并不执行 generator 函数体，而是返回一个迭代器。迭代器具有<code>next()</code>方法，每次调用 next() 方法，函数就执行到<code>yield</code>语句的地方。next() 方法返回一个对象，其中value属性表示 yield 关键词后面表达式的值，done 属性表示是否遍历结束。generator 生成器通过<code>next</code>和<code>yield</code>的配合实现流程控制，上面的代码执行了三次 next() ，generator 函数体才执行完毕。</p>

<h3>co 模块思路</h3>

<p>从上面的例子可以看出，generator 函数体可以停在 yield 语句处，直到下一次执行 next()。co 模块的思路就是利用 generator 的这个特性，将异步操作跟在 yield 后面，当异步操作完成并返回结果后，再触发下一次 next() 。当然，跟在 yield 后面的异步操作需要遵循一定的规范 thunks 和 promises。</p>

<blockquote>
  <h4>yieldables</h4>
  
  <p>The yieldable objects currently supported are:<br>
  - promises<br>
  - thunks (functions)<br>
  - array (parallel execution)<br>
  - objects (parallel execution)<br>
  - generators (delegation)<br>
  - generator functions (delegation)</p>
</blockquote>

<h2>7行代码</h2>

<p>再看看文章开头的7行代码：</p>

<pre><code>javascript</code><code>function co(gen) {
    var it = gen();
    var ret = it.next();
    ret.value.then(function(res) {
        it.next(res);
    });
}
</code></pre>

<p>首先生成一个迭代器，然后执行一遍 next()，得到的 value 是一个 Promise 对象，Promise.then() 里面再执行 next()。当然这只是一个原理性的演示，很多错误处理和循环调用 next() 的逻辑都没有写出来。</p>

<p>下面做个简单对比：<br>
传统方式，<code>sayhello</code>是一个异步函数，执行<code>helloworld</code>会先输出<code>"world"</code>再输出<code>"hello"</code>。</p>

<pre><code>function sayhello() {
    return Promise.resolve('hello').then(function(hello) {
        console.log(hello);
    });
}
function helloworld() {
    sayhello();
    console.log('world');
}
helloworld();
</code></pre>

<p>输出</p>

<pre><code>&gt; "world"
&gt; "hello"
</code></pre>

<p>co 的方式，会先输出<code>"hello"</code>再输出<code>"world"</code>。</p>

<pre><code>javascript</code><code>function co(gen) {
    var it = gen();
    var ret = it.next();
    ret.value.then(function(res) {
        it.next(res);
    });
}
function sayhello() {
    return Promise.resolve('hello').then(function(hello) {
        console.log(hello);
    });
}
co(function *helloworld() {
    yield sayhello();
    console.log('world');
});
</code></pre>

<p>输出</p>

<pre><code>javascript</code><code>&gt; "hello"
&gt; "world"
</code></pre>

<h2>消除回调金字塔</h2>

<p>假设<code>sayhello</code>/<code>sayworld</code>/<code>saybye</code>是三个异步函数，用真正的 co 模块就可以这么写：</p>

<pre><code>var co = require('co');
co(function *() {
    yield sayhello();
    yield sayworld();
    yield saybye();
});
</code></pre>

<p>输出</p>

<pre><code>javascript</code><code>&gt; "hello"
&gt; "world"
&gt; "bye"
</code></pre>

<h2>参考</h2>

<p>《es7-async》 <a rel="nofollow" href="https://github.com/jaydson/es7-async">https://github.com/jaydson/es7-async</a><br>
《Generator 函数的含义与用法》 <a rel="nofollow" href="http://www.ruanyifeng.com/blog/2015/04/generator.html">http://www.ruanyifeng.com/blog/2015/04/generator.html</a><br>
《Iterator》 <a rel="nofollow" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Iterator">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Glob...</a></p>

2015年五月6日凌晨 12:30:43
关于express中app.post的一个问题
<div class="markdown-text"><p>var express = require(‘express’);
var app = express();
app.listen(3000);
var bodyParser = require(‘body-parser’)
var hbs = require(‘hbs’);
var spawn = require(‘child_process’).spawn;</p>
<p>app.set('view engine’, ‘html’);
app.engine('html’, hbs.__express);
app.use(express.static(‘public’));
app.use(bodyParser.urlencoded({ extended: false }));</p>
<p>ls = spawn(‘某程序’);</p>
<p>app.post('/’, function(req, res) {
var info = req.body;//请求前端得到表单的值
ls.stdin.write(“calculate(“+info.xxx+”)&quot;+ “\n”);//子线程调用程序完成一些计算
ls.stdout.on('data’, function(data) {
//做一些数据的处理
res.render('…’,{data:…});//然后反馈呈现到前端页面上
});
});
这样做的话提交一次表单运行正常，第二次就会报错说Can’t set headers after they are sent，
查了之后说是回调有问题，后来把res.render去掉，console一些需要的结果，发现第一次提交表单运算后输出一次，当第二次提交表单的时候输出两次，第三次提交输出三次。。。</p>
<p>下面是把ls.stdout.on拿到post外面，这样做的话提交一次表单运算后输出一次，不会出现上面重复的问题，但是这里就不能用res.render()去把结果呈现在前端上了，因为在post外面，做不了res的反馈。。。
app.post('/’, function(req, res) {
var info = req.body;
ls.stdin.write(&quot;calculate(info.xxx+ “\n”);//子线程调用程序完成一些计算
});
ls.stdout.on('data’, function(data) {
//处理计算得到后的数据。console.log一些需要的结果，方便在终端查看结果
});</p>
<p>请教懂的小伙伴们，怎么做能一举两得呐？我是小白一枚。。。</p>
</div>

2015年五月6日凌晨 12:05:52
小白请教一个简单的session问题
<div class="markdown-text"><p>前端提交数据表单给nodejs，调用一个计算软件计算得到结果后反馈到前端页面上，在localhost:3000上能实现这个过程了，这是单用户情况。
现在要加多用户进去，用session模块，怎么设置能将调试的这台电脑作为服务器，然后让其他电脑访问完成提交数据运行计算软件得到结果的这个功能。</p>
</div>

2015年五月5日晚上 11:46:21
[MySQL]查询学生选课的情况（一）
<p>这是我工作遇到的问题，现在自己设计一个简化的类似场景，现实中这样的数据表设计可能有很多不合理的地方。<br>
首先看表结构：</p>

<pre><code>+--------+--------------+------+-----+---------+-------+
| Field  | Type         | Null | Key | Default | Extra |
+--------+--------------+------+-----+---------+-------+
| id     | varchar(38)  | NO   | PRI | NULL    |       |
| name   | varchar(255) | YES  |     | NULL    |       |
| course | varchar(300) | YES  |     | NULL    |       |
+--------+--------------+------+-----+---------+-------+
</code></pre>

<p>这里只是记录学生的ID，名字，还有选课的科目，科目有很多，在没有关联表的情况下，这么多科目只保存在一个字段中，用逗号隔开。<br>
再看一些数据：</p>

<pre><code>+--------------------------------------+--------+--------------------------------+
| id                                   | name   | course                         |
+--------------------------------------+--------+--------------------------------+
| 32268995-f33d-11e4-a31d-089e0140e076 | 张三   | Math,English,Chinese           |
| 3d670ef2-f33d-11e4-a31d-089e0140e076 | 李四   | Math,English,Chinese,Algorithm |
| 475d51a6-f33d-11e4-a31d-089e0140e076 | 李五   | Math,English,Algorithm         |
| 547fdea0-f33d-11e4-a31d-089e0140e076 | 王小明 | Math,English,Japanese          |
| 656a247a-f33d-11e4-a31d-089e0140e076 | 曹达华 | Chesses                        |
+--------------------------------------+--------+--------------------------------+
</code></pre>

<p><strong>那么如何查找到选择了<code>Math</code>课程的学生？</strong></p>

<p>想想使用关联表的时候，<code>张三</code>, <code>李四</code>, <code>李五</code>, <code>王小明</code>这四个人都一条选择了<code>Math</code>这门课的记录，还有其他不是<code>Math</code>的记录。此时要查找选择了<code>Math</code>课程的学生，一般使用<code>IN</code>语句就可以了：</p>

<pre><code>select * from student_course where course IN ('Math');
</code></pre>

<p>如果要查找选择了<code>Math</code>或<code>Algorithm</code>课程的学生呢：</p>

<pre><code>select * from student_course where course IN ('Math', 'Algorithm');
</code></pre>

<p>如此，回到原来的问题，如果我设计一个类似<code>IN</code>一样的函数，那么就可以解决这个问题了。<br>
这个流程我们可以想象出来，是这样子的：<br>
我们取<code>张三</code>的课程信息<code>Math,English,Chinese</code>，首先切割成<code>Math</code>, <code>English</code>,<code>Chinese</code>三个字段，然后分别与与查找条件做比较，类似<code>'Math'.indexOf('Math');</code>,<code>'Math'.indexOf('English');</code>...<br>
只要找到一个就认为符合查找条件。<br>
同样的，如果要查找选择了<code>Math</code>或<code>Algorithm</code>课程的学生，比较过程就变成了：<br><code>'Math,Algorithm'.indexOf('Math');</code>,<code>'Math,Algorithm'.indexOf('English');</code>...</p>

<h3>切割函数 getSplitTotalLength, getSplitString</h3>

<pre><code>CREATE DEFINER = `root`@`%` FUNCTION `getSplitTotalLength`(`f_string` varchar(500),`f_delimiter` varchar(5))
 RETURNS int(11)
BEGIN
    # 计算传入字符串能切分成多少段 
   return 1+(length(f_string) - length(replace(f_string,f_delimiter,''))); 

    RETURN 0;
END;
</code></pre>

<pre><code>CREATE DEFINER = `root`@`%` FUNCTION `getSplitString`(`f_string` varchar(500),`f_delimiter` varchar(5),`f_order` int)
 RETURNS varchar(500)
BEGIN
    #拆分传入的字符串，分隔符，顺序，返回拆分所得的新字符串
    declare result varchar(500) default '';
    set result = reverse(substring_index(reverse(substring_index(f_string,f_delimiter,f_order)),f_delimiter,1));
    RETURN result;
END;
</code></pre>

<h3>类似IN的那个函数 isInSearch</h3>

<pre><code>CREATE DEFINER=`root`@`%` FUNCTION `isInSearch`(f_course VARCHAR(300), f_string VARCHAR(300)) RETURNS INT
BEGIN

    DECLARE len INT DEFAULT 0;
    DECLARE idx INT DEFAULT 0;
    DECLARE item_code VARCHAR(300) DEFAULT '';
    DECLARE item_index INT DEFAULT 0;
    IF f_course IS NULL THEN
        RETURN 0;
    END IF;
    SELECT getSplitTotalLength(f_course, ',') INTO len;
    label: LOOP
        SET idx = idx + 1;
        IF idx &gt; len THEN
            LEAVE label;
        END IF;
        SELECT getSplitString(f_course , ',', idx) INTO item_code;
        # f_string.indexOf(item_code) &gt; -1 ?
        SELECT LOCATE(item_code, f_string) INTO item_index;
        IF item_index &gt; 0 THEN
            RETURN 1; # got one
        END IF;
    END LOOP label;
    RETURN 0;
    END;
</code></pre>

<p>这里说下<code>locate</code>函数，<code>locate(item_code, f_string)</code>，如果<code>item_code</code>是<code>f_string</code>的子串，返回的结果大于<code>0</code>，是<code>item_code</code>在<code>f_string</code>的起始下标（从1开始算起），这个一般的<code>indexOf</code>函数有些不同。</p>

<pre><code>mysql&gt; select locate('Math','Math,Algorithm');
+---------------------------------+
| locate('Math','Math,Algorithm') |
+---------------------------------+
|                               1 |
+---------------------------------+
mysql&gt; select locate('Math','Chinese,Math,Algorithm');
+-----------------------------------------+
| locate('Math','Chinese,Math,Algorithm') |
+-----------------------------------------+
|                                       9 |
+-----------------------------------------+
mysql&gt; select locate('Math','Chinese,Algorithm');
+------------------------------------+
| locate('Math','Chinese,Algorithm') |
+------------------------------------+
|                                  0 |
+------------------------------------+
</code></pre>

<p>可以看到<code>isInSearch</code>函数返回的是<code>INT</code>类似，因为<code>MySQL</code>的<code>IN</code>也是这样的机制。</p>

<pre><code>mysql&gt; select 'Math' in ('Math','Algorightm');
+---------------------------------+
| 'Math' in ('Math','Algorightm') |
+---------------------------------+
|                               1 |
+---------------------------------+
mysql&gt; select 'Math' in ('Chinese','Algorightm');
+------------------------------------+
| 'Math' in ('Chinese','Algorightm') |
+------------------------------------+
|                                  0 |
+------------------------------------+
</code></pre>

<p>如果存在返回1，不存在返回0。</p>

<h3>在SELECT语句中使用自定义的函数</h3>

<pre><code>mysql&gt; select * from student_course where isInSearch(course, 'Math');
+--------------------------------------+--------+--------------------------------+
| id                                   | name   | course                         |
+--------------------------------------+--------+--------------------------------+
| 32268995-f33d-11e4-a31d-089e0140e076 | 张三   | Math,English,Chinese           |
| 3d670ef2-f33d-11e4-a31d-089e0140e076 | 李四   | Math,English,Chinese,Algorithm |
| 475d51a6-f33d-11e4-a31d-089e0140e076 | 李五   | Math,English,Algorithm         |
| 547fdea0-f33d-11e4-a31d-089e0140e076 | 王小明 | Math,English,Japanese          |
+--------------------------------------+--------+--------------------------------+

mysql&gt; select * from student_course where isInSearch(course, 'Chinese,Japanese');
+--------------------------------------+--------+--------------------------------+
| id                                   | name   | course                         |
+--------------------------------------+--------+--------------------------------+
| 32268995-f33d-11e4-a31d-089e0140e076 | 张三   | Math,English,Chinese           |
| 3d670ef2-f33d-11e4-a31d-089e0140e076 | 李四   | Math,English,Chinese,Algorithm |
| 547fdea0-f33d-11e4-a31d-089e0140e076 | 王小明 | Math,English,Japanese          |
+--------------------------------------+--------+--------------------------------+
</code></pre>

2015年五月5日晚上 11:05:02
PHP 到 Node.js的路该如何走？
<div class="markdown-text"><p>无js基础，php出身，该通过什么方式能够快速掌握Node.js?</p>
</div>

2015年五月5日晚上 10:00:43
求大神给建立个符合要求mongodb集合
<div class="markdown-text"><p>nodejs新手，想做个社交聊天的玩具（就是图个新鲜）现在遇见难题了，跪求大神帮助
我数据库用的是mongodb,建立了个用户表
var users=new Schema(
{
email:String,//邮箱
password:String,//密码
username:String,//用户昵称
avatar:String,//头像
sex:String,//性别
auth:String,//验证码
condition:Boolean,//账号是否激活
address:String,//地址
marry:String,//婚姻状况
proclammation:String,//个性宣言
friends:[{fid:Object,//朋友id
remarks:String,//备注
group:String,//分组
allow:Boolean}]
});
我现在遇见的问题是如何通过fid获取朋友的信息，
我刚开始是这样做的
if(docs.friends.length&gt;0){
docs.friends.forEach(function(b){
users.findById(b.fid,function(err,frids){
if(err){
console.log(“加载朋友时候失败了”);
}
var arr={
&quot;userId&quot;:frids._id,
&quot;username&quot;:frids.username,
&quot;avatar&quot;:frids.avatar,
&quot;remarks&quot;: b.remarks,
&quot;group&quot;: b.group
}
frs.push(arr);</p>
<pre class="prettyprint"><code>                    });
                    });
                     res.render(&#x27;coze&#x27;,{frs:frs});
</code></pre><p>但是我对回调函数，异步又不熟悉，设计上有问题，所以最后得不到frs 里的数据,
然后我尝试这用Population，发现friends 里关联的就是users ,而friends 就在users 中，怎么办
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
我的目的其实很简单，就是实现类似QQ那样加载好友信息，同时加载备注的功能，大神给个解决方案吧
参考资料也可以的</p>
</div>

2015年五月5日晚上 8:33:45
alsotang commented on pull request cnodejs/nodeclub#521
<!-- issue_comment -->
<span class="mega-octicon octicon-comment-discussion"></span>

<div class="time">
  <time datetime="2015-05-05T12:33:45Z" is="relative-time">May 5, 2015</time>
</div>

<div class="title">
  <a href="https://github.com/alsotang" data-ga-click="News feed, event click, Event click type:IssueCommentEvent target:actor">alsotang</a> <span>commented</span> on pull request <a href="https://github.com/cnodejs/nodeclub/pull/521#issuecomment-99066593" data-ga-click="News feed, event click, Event click type:IssueCommentEvent target:issue-comment" title="security fix:wooyun-2010-0112230">cnodejs/nodeclub#521</a>
</div>

<div class="details">
  <a href="https://github.com/alsotang"><img alt="@alsotang" class="gravatar" data-user="1147375" height="30" src="https://avatars0.githubusercontent.com/u/1147375?v=3&amp;s=60" width="30" /></a>
  <div class="message markdown-body">
    <blockquote>
      <p>域名还不在我手上，想去乌云认领都难。</p>
    </blockquote>
  </div>
</div>

2015年五月5日晚上 8:29:50
alsotang pushed to master at cnodejs/nodeclub
<!-- push -->
<span class="mega-octicon octicon-git-commit"></span>

<div class="time">
  <time datetime="2015-05-05T12:29:50Z" is="relative-time">May 5, 2015</time>
</div>

<div class="title">
  <a href="https://github.com/alsotang" data-ga-click="News feed, event click, Event click type:PushEvent target:actor">alsotang</a> <span>pushed</span> to <a href="/cnodejs/nodeclub/tree/master" data-ga-click="News feed, event click, Event click type:PushEvent target:branch">master</a> at <a href="https://github.com/cnodejs/nodeclub" data-ga-click="News feed, event click, Event click type:PushEvent target:repo">cnodejs/nodeclub</a>
</div>

<div class="details">
  <a href="https://github.com/alsotang"><img alt="@alsotang" class="gravatar" data-user="1147375" height="30" src="https://avatars0.githubusercontent.com/u/1147375?v=3&amp;s=60" width="30" /></a>

    <div class="commits pusher-is-only-committer">
      <ul>
        <li>
          <span title="alsotang">
            <img alt="@alsotang" data-user="1147375" height="16" src="https://avatars1.githubusercontent.com/u/1147375?v=3&amp;s=32" width="16" />
          </span>
          <code><a href="/cnodejs/nodeclub/commit/5e6cdd627a520bd6aaaf7e1c17f2aae776fe880f" data-ga-click="News feed, event click, Event click type:PushEvent target:sha">5e6cdd6</a></code>
          <div class="message">
            <blockquote>
              fix travis
            </blockquote>
          </div>
        </li>
      </ul>
    </div>
</div>

2015年五月5日晚上 8:27:08
alsotang commented on pull request cnodejs/nodeclub#521
<!-- issue_comment -->
<span class="mega-octicon octicon-comment-discussion"></span>

<div class="time">
  <time datetime="2015-05-05T12:27:08Z" is="relative-time">May 5, 2015</time>
</div>

<div class="title">
  <a href="https://github.com/alsotang" data-ga-click="News feed, event click, Event click type:IssueCommentEvent target:actor">alsotang</a> <span>commented</span> on pull request <a href="https://github.com/cnodejs/nodeclub/pull/521#issuecomment-99065677" data-ga-click="News feed, event click, Event click type:IssueCommentEvent target:issue-comment" title="security fix:wooyun-2010-0112230">cnodejs/nodeclub#521</a>
</div>

<div class="details">
  <a href="https://github.com/alsotang"><img alt="@alsotang" class="gravatar" data-user="1147375" height="30" src="https://avatars0.githubusercontent.com/u/1147375?v=3&amp;s=60" width="30" /></a>
  <div class="message markdown-body">
    <blockquote>
      <p>呃。不好意思刚看到。。。已经修复了。 <a href="https://github.com/cnodejs/nodeclub/commit/0f6cc14f6bcbbe6b4de3199c6896efaec637693e" class="commit-link"><tt>0f6cc14</tt></a></p>
    </blockquote>
  </div>
</div>

2015年五月5日晚上 8:27:08
alsotang closed pull request cnodejs/nodeclub#521
<!-- pull_request -->
<span class="mega-octicon octicon-git-pull-request"></span>

<div class="time">
  <time datetime="2015-05-05T12:27:08Z" is="relative-time">May 5, 2015</time>
</div>

<div class="title">
  <a href="https://github.com/alsotang" data-ga-click="News feed, event click, Event click type:PullRequestEvent target:actor">alsotang</a> <span>closed</span> pull request <a href="https://github.com/cnodejs/nodeclub/pull/521" data-ga-click="News feed, event click, Event click type:PullRequestEvent target:pull">cnodejs/nodeclub#521</a>
</div>

<div class="details">
  <a href="https://github.com/alsotang"><img alt="@alsotang" class="gravatar" data-user="1147375" height="30" src="https://avatars0.githubusercontent.com/u/1147375?v=3&amp;s=60" width="30" /></a>
  <div class="message">
    <blockquote>security fix:wooyun-2010-0112230</blockquote>
  </div>
</div>

2015年五月5日晚上 8:22:08
How to structure models in NodeJS
<div class="markdown-text"><p>我想请问下，在nodeJS 中Model 的结构是咋样的？
我之前是做Java/C# 程序的， 在以往我的model 全部都是单独作为一个文件来存放（POJO），然后会有一个专门的数据访问类，或则一个Repository，例如：</p>
<p>– 纯model 文件
publi class User{
poublic int Id {get; set}
public string FirstName { get; set; }
public string LastName { get; set; }
…
}
– 数据访问类
public class UserRep{
public IEnumerable&lt;User&gt; All();
public User Get();
…
}</p>
<p>但是，我看网上有好些教程，大都是把 Model 的字段和方法放在同一个文件里头：
var User = function(id, firstname, lastname) {
this.Id=id;
…
}
// 先是一些静态方法
User.findById = function() {  }
// 然后还有些 实例方法
User.prototype.save = function() {}</p>
<p>这样做我感觉怪怪的， 数据， 和数据访问层不应该分开吗？还有几个疑问（我不用Mongodb, 我用的是传统的RDBS）：</p>
<ol>
<li>如何做 data validation；</li>
<li>单元测试如何集成；</li>
<li>如果使用ORM 该怎么样用；</li>
</ol>
</div>

2015年五月5日晚上 7:46:08
iojs v2.0 开启 use strong 之后。。。
<div class="markdown-text"><p>就可以和var说再见了~~一遍es6、7写下来，如果再使用<a href="http://flowtype.org/">flow</a>，那感觉基本就不是js了⊙﹏⊙b。
<a href="https://github.com/yosuke-furukawa/iojs-new-features">iojs-new-features</a></p>
</div>

2015年五月5日晚上 7:44:21
alsotang pushed to online at cnodejs/nodeclub
<!-- push -->
<span class="mega-octicon octicon-git-commit"></span>

<div class="time">
  <time datetime="2015-05-05T11:44:21Z" is="relative-time">May 5, 2015</time>
</div>

<div class="title">
  <a href="https://github.com/alsotang" data-ga-click="News feed, event click, Event click type:PushEvent target:actor">alsotang</a> <span>pushed</span> to <a href="/cnodejs/nodeclub/tree/online" data-ga-click="News feed, event click, Event click type:PushEvent target:branch">online</a> at <a href="https://github.com/cnodejs/nodeclub" data-ga-click="News feed, event click, Event click type:PushEvent target:repo">cnodejs/nodeclub</a>
</div>

<div class="details">
  <a href="https://github.com/alsotang"><img alt="@alsotang" class="gravatar" data-user="1147375" height="30" src="https://avatars0.githubusercontent.com/u/1147375?v=3&amp;s=60" width="30" /></a>

    <div class="commits pusher-is-only-committer">
      <ul>
        <li>
          <span title="alsotang">
            <img alt="@alsotang" data-user="1147375" height="16" src="https://avatars1.githubusercontent.com/u/1147375?v=3&amp;s=32" width="16" />
          </span>
          <code><a href="/cnodejs/nodeclub/commit/a0b8cb11028c5aba609f9ed45951fe81e0fdbd2f" data-ga-click="News feed, event click, Event click type:PushEvent target:sha">a0b8cb1</a></code>
          <div class="message">
            <blockquote>
              coding.net
            </blockquote>
          </div>
        </li>
        <li>
          <span title="alsotang">
            <img alt="@alsotang" data-user="1147375" height="16" src="https://avatars1.githubusercontent.com/u/1147375?v=3&amp;s=32" width="16" />
          </span>
          <code><a href="/cnodejs/nodeclub/commit/35a096f81c5abc93bdae538fc7fcd96c61ebfa19" data-ga-click="News feed, event click, Event click type:PushEvent target:sha">35a096f</a></code>
          <div class="message">
            <blockquote>
              qiniu
            </blockquote>
          </div>
        </li>
        <li class="more"><a href="https://github.com/cnodejs/nodeclub/compare/ae8b959909...a0b8cb1102" data-ga-click="News feed, event click, Event click type:PushEvent target:comparison">5 more commits &raquo;</a></li>
      </ul>
    </div>
</div>

2015年五月5日晚上 7:43:50
alsotang pushed to master at cnodejs/nodeclub
<!-- push -->
<span class="mega-octicon octicon-git-commit"></span>

<div class="time">
  <time datetime="2015-05-05T11:43:50Z" is="relative-time">May 5, 2015</time>
</div>

<div class="title">
  <a href="https://github.com/alsotang" data-ga-click="News feed, event click, Event click type:PushEvent target:actor">alsotang</a> <span>pushed</span> to <a href="/cnodejs/nodeclub/tree/master" data-ga-click="News feed, event click, Event click type:PushEvent target:branch">master</a> at <a href="https://github.com/cnodejs/nodeclub" data-ga-click="News feed, event click, Event click type:PushEvent target:repo">cnodejs/nodeclub</a>
</div>

<div class="details">
  <a href="https://github.com/alsotang"><img alt="@alsotang" class="gravatar" data-user="1147375" height="30" src="https://avatars0.githubusercontent.com/u/1147375?v=3&amp;s=60" width="30" /></a>

    <div class="commits pusher-is-only-committer">
      <ul>
        <li>
          <span title="alsotang">
            <img alt="@alsotang" data-user="1147375" height="16" src="https://avatars1.githubusercontent.com/u/1147375?v=3&amp;s=32" width="16" />
          </span>
          <code><a href="/cnodejs/nodeclub/commit/0f6cc14f6bcbbe6b4de3199c6896efaec637693e" data-ga-click="News feed, event click, Event click type:PushEvent target:sha">0f6cc14</a></code>
          <div class="message">
            <blockquote>
              mongodb 注入漏洞
            </blockquote>
          </div>
        </li>
      </ul>
    </div>
</div>

2015年五月5日晚上 7:32:41
正则表达式笔记（二）
<h2>JS 中的正则表达式</h2>

<h3>概述</h3>

<p>在 JS 中，正则表达式是个 <code>RegExp</code> 对象，具有 <code>exec</code>，<code>test</code> 方法。而在 <code>String</code> 对象中，也存在 <code>match</code>，<code>replace</code>，<code>search</code>，<code>split</code> 操作正则表达式的方法。</p>

<h3>声明</h3>

<p>JS 中的正则表达式有两种声明方式（对象字面量 / 构造函数），都会生产一个 <code>RegExp</code> 对象的实例。</p>

<pre><code>/pattern/flags
new RegExp(pattern[, flags])
</code></pre>

<h3>RegExp 对象</h3>

<p><strong>实例</strong></p>

<pre><code>var pattern = /quick\s(brown).+?(jumps)/ig;
var pattern = new RegExp("quick\\s(brown).+?(jumps)","ig");
</code></pre>

<p>实例之后的 <code>pattern</code> 对象就具有以下属性:</p>

<ul>
<li>
<code>lastIndex</code>：下次开始匹配的字符串位置，若是无设置全局模式，会始终为 0</li>
<li>
<code>ignoreCase</code>：是否设置忽略大小写模式</li>
<li>
<code>global</code>：是否设置了全局匹配模式</li>
<li>
<code>multiline</code>：是否设置了多行模式</li>
<li>
<code>source</code>：正则表达式的文本内容</li>
</ul>
<p>注意使用构造函数声明正则表达式的时候，需合理使用转义符。</p>

<p><strong>方法</strong></p>

<p><code>RegExp.exec</code> 检索字符串中指定的值。返回一个结果数组。该方法总是返回单词匹配的结果。</p>

<p>在正则表达式设置了 <code>g</code> 模式的情况下，会同时更新 <code>RegExp</code> 对象的 <code>lastIndex</code> 属性。</p>

<pre><code>var result = re.exec('The Quick Brown Fox Jumps Over The Lazy Dog');
// console.log(result)
// ["Quick Brown Fox Jumps", "Brown", "Jumps"]

var pattern = /ab*/g;
var str = 'abbcdefabh';
var matchArray;
while ((matchArray = pattern.exec(str)) !== null) {
  var msg = 'Found ' + matchArray[0] + '. ';
  msg += 'Next match starts at ' + pattern.lastIndex;
  //console.log(msg);
  // Found abb. Next match starts at 3
  // Found ab. Next match starts at 9
}
</code></pre>

<p>使用循环的时候，不要把正则表达式的操作放置在循环体中（这样每次都会重新生成 <code>RegExp</code> 对象），同时必须设置全局模式，可能会造成死循环。</p>

<p><code>RegExp.test</code> 执行检索字符串中指定值的操作。返回 <code>true</code> 或 <code>false</code>。</p>

<pre><code>var pattern = /^\d{4}-\d{2}-\d{2}$/;
var result = re.test('2010-12-20');

console.log(result)
// true
</code></pre>

<p>在正则表达式设置了 <code>g</code> 模式的情况下，跟 <code>RegExp.exec</code> 一样，会同时更新 <code>RegExp</code> 对象的 <code>lastIndex</code> 属性。</p>

<pre><code>var pattern = /^\d{4}-\d{2}-\d{2}$/g;
pattern.test('2010-12-20'); // true
pattern.test('2010-12-20'); // false
</code></pre>

<p><code>RegExp.test</code> 在匹配成功之后，各个捕获分组的文本会保存下来，用 <code>RegExp.$1</code>，<code>RegExp.$2</code>··· 就可以获得，不过，保存整个表达式匹配文本的 <code>RegExp.$0</code> 并不存在。</p>

<h3>String 对象</h3>

<p><strong>方法</strong></p>

<p><code>String.match</code> 返回一个结果数组或<code>null</code>。</p>

<p>在正则表达式设置了 <code>g</code> 模式的情况下，<code>match</code> 默认返回所有可能的匹配结果。</p>

<pre><code>var str = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
var re = /[A-E]/gi;
var matches = str.match(re);

console.log(matches);
// ['A', 'B', 'C', 'D', 'E', 'a', 'b', 'c', 'd', 'e']
</code></pre>

<p>如果正则表达式没有设置 <code>g</code> 模式，那么 <code>match</code> 方法返回的结果与 <code>RegExp.exec()</code> 一致。</p>

<pre><code>var str = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
var re = /[A-E]/i;
var matches_1 = str.match(re);
var matches_2 = re.exec(str)

console.log(matches_1, matches_2)

//[ 'A',
  index: 0,
  input: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz' ]
</code></pre>

<p>该返回结果包含匹配的字符串，还有一个额外的 <code>index</code> 属性，表示匹配字符串的位置，<code>input</code> 属性即是所传入的字符串。</p>

<p><code>String.search</code> 返回第一次匹配的位置或 <code>-1</code></p>

<p>该方法用来寻找某个正则表达式在字符串中第一次匹配成功的位置，失败的时候返回 <code>-1</code>。</p>

<p>这个方法只能找到“第一次”，即使设置了 <code>g</code> 模式，结果也不会有任何变化，所以如果需要使用一个正则表达式多次验证字符串，调用该方法判断结果是否为 0，是更好的办法。</p>

<pre><code>"1234".search(/^\d+$/g) == 0 // true
"5678".search(/^\d+$/g) == 0 // true

var pattern = /^\d+$/g;
pattern.test("1234"); // true
pattern.test("5678"); // false
</code></pre>

<p><code>String.split</code> 使用一个正则表达式来切割字符串。返回数组</p>

<p>正则表达式是否设置了<code>g</code>模式对结果没有影响。</p>

<pre><code>var matchArray = "a b c".split(/\s+/);

console.log(matchArray);
// ["a", "b", "c"]
</code></pre>

<p>也可以设置第二个参数 <code>limit</code>，指定返回数组的数目。在 JS 中，该参数取值的结果如下</p>

<table>
<thead><tr>
<th>取值</th>
  <th>结果</th>
</tr></thead>
<tbody>
<tr>
<td>limit &lt; 0 || limit &gt; n</td>
  <td>等同于未指定</td>
</tr>
<tr>
<td>0&lt;=limit&lt;=n</td>
  <td>返回一个包含 n 元素的数组</td>
</tr>
</tbody>
</table>
<pre><code>var matchArray = "a b c".split(/\s+/,2);

console.log(matchArray);
// ["a", "b"]
</code></pre>

2015年五月5日晚上 7:24:48
alsotang pushed to online at cnodejs/nodeclub
<!-- push -->
<span class="mega-octicon octicon-git-commit"></span>

<div class="time">
  <time datetime="2015-05-05T11:24:48Z" is="relative-time">May 5, 2015</time>
</div>

<div class="title">
  <a href="https://github.com/alsotang" data-ga-click="News feed, event click, Event click type:PushEvent target:actor">alsotang</a> <span>pushed</span> to <a href="/cnodejs/nodeclub/tree/online" data-ga-click="News feed, event click, Event click type:PushEvent target:branch">online</a> at <a href="https://github.com/cnodejs/nodeclub" data-ga-click="News feed, event click, Event click type:PushEvent target:repo">cnodejs/nodeclub</a>
</div>

<div class="details">
  <a href="https://github.com/alsotang"><img alt="@alsotang" class="gravatar" data-user="1147375" height="30" src="https://avatars0.githubusercontent.com/u/1147375?v=3&amp;s=60" width="30" /></a>

    <div class="commits pusher-is-only-committer">
      <ul>
        <li>
          <span title="alsotang">
            <img alt="@alsotang" data-user="1147375" height="16" src="https://avatars1.githubusercontent.com/u/1147375?v=3&amp;s=32" width="16" />
          </span>
          <code><a href="/cnodejs/nodeclub/commit/ae8b95990929cd3e0df54492817f00442e4b3014" data-ga-click="News feed, event click, Event click type:PushEvent target:sha">ae8b959</a></code>
          <div class="message">
            <blockquote>
              coding.net
            </blockquote>
          </div>
        </li>
      </ul>
    </div>
</div>

2015年五月5日晚上 6:39:24
node js callback 的一些问题
<div class="markdown-text"><p>小弟最近在练习node js
但总是遇到一个问题不知道该怎么解决
是关于callback的问题
举个例子来说 mysql 模塊中對mysql下query</p>
<p>var rs;
connection.query('SELECT 1 + 1 AS solution’, function(err, rows, fields) {
if (err) throw err;
rs = rows;
console.log('The solution is: ', rows[0].solution);
});</p>
<p>根据官方文件 返回的结果 会传给rows
但我在外面宣告一个变数去里面把rows传给他
但之后console看却是undefine 不确定是不是callback函数的范围问题</p>
<p>如果我想要对结果作处理一定要在callback里面做吗?
得到的结果可以传出来吗?这个地方我一直有问题观念不是很懂
所以来这边请教一下各位</p>
</div>

2015年五月5日晚上 6:16:05
关于MongoDB 和 缓存
<div class="markdown-text"><p>MongoDB 号称查询已经非常快，而且热数据是在内存上的，那还有必要专门优化吗？</p>
</div>

2015年五月5日晚上 6:07:28
求解答socket.io client代码处理方案
<div class="markdown-text"><p>socket.io在客户端需要写相应的代码去请求server端的事件。那这样就相当于把client 的js代码暴露在浏览器，这样不就很危险，相当于用户可以通过编写js去请求我的server服务，想问问各位有什么好的处理方案。例如js客户端代码加密（初步方案而已）。</p>
</div>

2015年五月5日下午 4:49:16
在用npm start 启动项目的时候，会出现如图情况。
<div class="markdown-text"><p><img src="//dn-cnode.qbox.me/Ftkk5GXKhuZDHUQgfArd3MWs4viU" alt="cnodejs.png"></p>
<p>启动就是用express生成的项目，在线等。</p>
<p>对了，补充一下。是window7系统</p>
</div>

2015年五月5日下午 2:57:14
alsotang pushed to online at cnodejs/nodeclub
<!-- push -->
<span class="mega-octicon octicon-git-commit"></span>

<div class="time">
  <time datetime="2015-05-05T06:57:14Z" is="relative-time">May 5, 2015</time>
</div>

<div class="title">
  <a href="https://github.com/alsotang" data-ga-click="News feed, event click, Event click type:PushEvent target:actor">alsotang</a> <span>pushed</span> to <a href="/cnodejs/nodeclub/tree/online" data-ga-click="News feed, event click, Event click type:PushEvent target:branch">online</a> at <a href="https://github.com/cnodejs/nodeclub" data-ga-click="News feed, event click, Event click type:PushEvent target:repo">cnodejs/nodeclub</a>
</div>

<div class="details">
  <a href="https://github.com/alsotang"><img alt="@alsotang" class="gravatar" data-user="1147375" height="30" src="https://avatars0.githubusercontent.com/u/1147375?v=3&amp;s=60" width="30" /></a>

    <div class="commits pusher-is-only-committer">
      <ul>
        <li>
          <span title="alsotang">
            <img alt="@alsotang" data-user="1147375" height="16" src="https://avatars1.githubusercontent.com/u/1147375?v=3&amp;s=32" width="16" />
          </span>
          <code><a href="/cnodejs/nodeclub/commit/3642ce41a7834a834f933870f6e8edad8e9498ad" data-ga-click="News feed, event click, Event click type:PushEvent target:sha">3642ce4</a></code>
          <div class="message">
            <blockquote>
              qiniu
            </blockquote>
          </div>
        </li>
      </ul>
    </div>
</div>

2015年五月5日下午 2:13:42
来帮我做个小调研《Node使用情况小调查》
<div class="markdown-text"><p>问卷地址在这里：<a href="http://survey.taobao.com/survey/AgT436qK">http://survey.taobao.com/survey/AgT436qK</a></p>
<p>不用登陆。只有5个小题。么么哒。</p>
<p>调研已经结束，谢谢各位。</p>
</div>

2015年五月5日下午 2:06:55
糗百的数据迁移实践
<p>糗事百科（以下简称“糗百”）被誉为移动互联网时代的新娱乐手段，其上海量真实用户的糗事深受喜爱，每天有1亿次动态请求，峰值请求数为每秒30000次。面对如此高的并发访问量，糗百原来自建的平台越来越难以支撑，开始出现服务器过载、跨机房同步延时大、图片中心磁盘I/O成为瓶颈等问题。</p>

<p>为了解决这些刚性的服务压力，优化用户的服务体验，并考虑到七牛对静态资源存储的强大技术实力和优秀的解决方案，糗百决定将图片存储迁移到七牛平台上，并开始使用七牛提供的CDN服务。本文将结合糗百的数据迁移实践，来详细讲述如何在不中断服务的情况下，将海量数据平滑迁移到七牛平台的全过程。</p>

<p><strong>qrsync+镜像存储打造平滑迁移方案</strong></p>

<p>传统的数据迁移方案是：关掉网站原来的数据上传通道，所有数据变成只读，然后将所有数据上传到新的存储节点，再将上传入口改为新的存储节点，之后开放网站的上传功能。这样带来的问题是，数据迁移过程中，用户长时间不能进行上传操作，用户体验非常差。如何解决这个问题呢？</p>

<p>针对糗百这么大体量的应用，七牛提供的数据迁移方案——上传工具qrsync+镜像存储，很好地绕开了传统迁移方案所带来的问题。糗百先通过七牛的数据上传工具qrsync将大量冷数据传到七牛平台上，并将数据访问地址切换成七牛的域名。由于用户生成的大量热数据还在糗百自己的平台上，为了不出现数据丢失的情况，保证用户访问的流畅性，糗百选用了七牛的镜像存储服务。</p>

<p>七牛的镜像存储为整个数据迁移过程提供良好的过渡支持作用。当用户访问的数据不在七牛平台上时，镜像存储服务将回糗百源站抓取数据，并保存在七牛平台上。故此，镜像存储对每个资源只需回源一次，后续访问的时候就不再回源了。<br><img src="/img/bVlCpw" alt="图片描述"></p>

<p>随后，为了进一步缓解糗百源站的I/O压力，糗百对旧有系统做了一次版本升级，将新系统的图片存储直接放在七牛平台上。新版本的用户可以顺畅地将数据上传到七牛平台上，并实现访问，而旧系统的App版本还会有一部分用户在使用。这时，就要在一段时间内保证两套系统可用。但旧系统的App用户所产生的数据还是会被上传到糗百的自建平台中，在用户第一次访问这些数据时，镜像存储服务对糗百源站做回源，很好地确保了这部分数据的可用性。由于目前App客户端的版本更新速度比较快，因此在所有用户都更新成新版系统，源站的回源流量逐渐趋于0时，就可以将镜像功能删除了。</p>

<p>就这样，在用户毫无感知的情况下，糗百轻松实现了对图片存储的迁移，平稳地解决了图片中心磁盘I/O的瓶颈问题。</p>

<p><strong>镜像存储的使用方法</strong></p>

<p>假设源站所有的图片，放在一个叫img.example.com的子域里。那么平滑迁移的方式是：</p>

<p>1、在七牛上建立一个镜像bucket，设定源站为img.example.com。假设镜像bucket是example-img，到空间设置的域名设置中即可找到形式为7xiuqc.com1.z0.glb.clouddn.com的七牛域名；<br>
2、将所有对外使用的图片的域名改为7xiuqc.com1.z0.glb. clouddn.com；<br>
3、如果网站数据是UGC（用户产生内容）的，调整上传流程，传到七牛的镜像 bucket，这样源站就变成只读；<br>
4、使用qrsync同步工具将历史数据全部同步到七牛的镜像bucket。</p>

<p>如此就完成了整个迁移过程。此时img.example.com这个源站就可以废弃不用了。</p>

<p><strong>结语</strong></p>

<p>相信数据资源高速增长这样的“甜蜜负担”，是很多企业都会遇到的。而如何借助云服务来合理扩容，如何在不中断服务的前提下，平滑地实现数据迁移，将成为决定企业未来命运的关键一环。七牛云存储不仅能为企业用户稳定高效的底层存储平台，镜像存储等优质的服务更能在数据迁移过程中提供强大的助力。此外，完成数据迁移之后，七牛提供的丰富的图片、音视频处理功能也为包括糗百在内的诸多企业带来了很大的惊喜。后续我们将专门撰文分享这部分内容。</p>

2015年五月5日中午 11:55:15
CentOS 6.x 升级 Git
<h2>准备</h2>

<h3>说明</h3>

<p>公司服务器为centos，安装git后的默认版本是1.7.1，在执行git clone命令时报错如下：</p>

<pre><code>    fatal: HTTP request failed
</code></pre>

<p>经过一番搜索终于找到可行的办法，即为升级git版本，升级时间比较长，需要比较好的网络支持.</p>

<h3>git版本检测</h3>

<p>CentOS下使用<code>git --version</code> 检测git的版本</p>

<pre><code># git --version
git version 1.7.1
</code></pre>

<h3>系统检测</h3>

<pre><code># cat /etc/redhat-release
CentOS release 6.5 (Final)
# uname -a
Linux rmhost 2.6.32-431.el6.x86_64 #1 SMP Fri Nov 22 03:15:09 UTC 2013 x86_64 x86_64 x86_64 GNU/Linux
</code></pre>

<p>通过以上信息可知系统版本为 CentOS 6.5 64位</p>

<h2>升级</h2>

<h3>1.导入证书</h3>

<pre><code># rpm --import http://apt.sw.be/RPM-GPG-KEY.dag.txt
</code></pre>

<h3>2.安装RPMForge源</h3>

<p>在<a rel="nofollow" href="http://pkgs.repoforge.org/rpmforge-release/">这里</a>查找对应的版本,比如我这里根据系统版本选择了<code>rpmforge-release-0.5.3-1.el6.rf.x86_64.rpm</code>,右键拷贝地址, 粘贴到命令<code>rpm -i</code>命令后面执行</p>

<pre><code># rpm -i http://pkgs.repoforge.org/rpmforge-release/rpmforge-release-0.5.3-1.el6.rf.x86_64.rpm

package rpmforge-release-0.5.3-1.el6.rf.x86_64 is already installed
</code></pre>

<blockquote>
  <p>符合系统版本的文件可能有多个,选一个较新的即可.</p>
</blockquote>

<h3>3.更新rpmforge-extra源</h3>

<pre><code># yum --enablerepo=rpmforge-extras update
</code></pre>

<p>途中会有选项<code>Is this ok [y/N]:</code>询问是否下载, 如果选了y会更新所有的软件到匹配的最新版本,包括git,如果选N也可以手动安装git到最新版</p>

<blockquote>
  <p>这里建议选择N,选y需要较长时间(我当前网速下测试为一小时左右),一些软件升级后可能需要重新配置才能起作用, 比如MySQL从5.1升级到了5.5, 由于未配置直接导致我在线的两个项目无法运行, 只能手忙脚乱的赶紧修改配置,如果你不幸出了同样的问题, 可以到文章末尾找到解决办法</p>
</blockquote>

<h3>4.查找符合系统的git版本</h3>

<h5>通过下面的命令查找(推荐)</h5>

<pre><code>    # yum --enablerepo=rpmforge-extras provides git
    git-1.7.12.4-1.el6.rfx.x86_64 : Git core and tools
    Repo        : installed
    匹配来自于:
    Other       : 提供依赖满足：git
</code></pre>

<h5>或者在软件库中查找</h5>

<p>在<a rel="nofollow" href="http://pkgs.repoforge.org/git/">这里</a>找到系统能支持的git最新版本</p>

<h3>5.安装git</h3>

<pre><code># yum --enablerepo=rpmforge-extras install perl-Git-1.7.12.4-1.el6.rfx.x86_64.rpm 
# git --version
git version 1.7.12.4
</code></pre>

<h3>MySQL升级后不能启动的解决办法</h3>

<p>系统使用rpm源升级了所有软件, MySQL从5.1升级到了5.5, 启动的时候抛出异常:</p>

<pre><code>MySQL Daemon failed to start.
正在启动 mysqld：                                   [失败]
</code></pre>

<h4>原因：</h4>

<p>MySQL升级之后，由于配置文件/etc/my.cnf还是原来5.1的，对5.5已经不适用了，所以出错</p>

<h4>解决办法：</h4>

<p>用MySQL-5.5的配置文件替换原来的/etc/my.cnf,具体操作</p>

<pre><code>cp /usr/share/mysql/my-medium.cnf /etc/my.cnf
</code></pre>

<blockquote>
  <p>注意：MySQL配置模板文件共有5个：my-huge.cnf、my-innodb-heavy-4G.cnf、my-large.cnf、mymedium.cnf、my-small.cnf，根据自己的服务器硬件配置选择相应的模板文件即可</p>
</blockquote>

<h2>参考</h2>

<p>CentOS升级git：</p>

<ul>
<li><a rel="nofollow" href="http://blog.csdn.net/ljianhui/article/details/23888269">CentOS升级Git</a></li>
<li><a rel="nofollow" href="http://www.educity.cn/linux/1572933.html">CentOS升级Git</a></li>
</ul>
<p>MySQL无法启动：</p>

<ul>
<li><a rel="nofollow" href="http://www.111cn.net/sys/linux/45604.htm">linux中mysql升级后不能启动的解决方法</a></li>
</ul>

2015年五月5日中午 11:39:23
有人用过apache的ab test测试post请求么？post请求的文件正确格式是啥？
<div class="markdown-text"><p>求问，网上搜了很多都只介绍了ab test的基本用法，测post请求的还真难搜到，我想知道如果我post一个复杂的json数据（比如对象包含对象，包含数组这种结构的），post请求的file文件正确格式是啥？有什么工具或方法可以帮我把json数据转换成正确的post格式么？谢谢！</p>
</div>

2015年五月5日中午 11:37:38
【北京】Melotic招聘 Nodejs/ops工程师(15k- 30k)
<div class="markdown-text"><p>【关于我们】
Melotic成立于2014年年初，以香港为基地的数字资产交换和流通平台，在大陆、台湾、美国分别设有分公司，平台应用了革命性的金融技术，将迅速在全球多个国家开展业务。
团队已是获美国LIGHT SPEED VENTURE风投支持，CEO是斯坦福大学毕业并在美国硅谷创业多年的JACK WANG,
中英文双语工作环境，工作地点为团结湖地铁站附近的三里屯创业空间科技寺。
【关于职位】
Nodejs/ops工程师，后端工程师，国际平台，只要你有能力，一切都不是问题
工作地点：北京市
工作年限：3年以上
最低学历：本科
招聘人数：1
职位月薪：￥15,000 - 30,000
【职责&amp;要求】
岗位职责
Responsibilities</p>
<ul>
<li>Build and deploy robust, manageable and scalable back ends</li>
<li>Integrate 3rd party services via RESTful and streaming APIs</li>
<li>Design and implement RESTful interfaces that exposes our data</li>
<li>Rapidly fix bugs and solve problems</li>
<li>Work closely with front-end teams to create optimally integrated solutions</li>
</ul>
<p>任职要求
Requirements</p>
<ul>
<li>Strong Javascript skills</li>
<li>Knowledge of Node.js packages (Express, Async, Mongoose, Socket.io, Request, etc.)</li>
<li>Experience with message and job queuing services (RabbitMQ, Redis, etc.)</li>
<li>Very strong ability to design and develop scalable systems on top of Node.js</li>
<li>Experience working with MongoDB, Mysql and Redis.</li>
<li>Disciplined approach to testing and quality assurance, knowledge of Javascript testing tools.</li>
<li>High understanding of computer science concepts such as: common data structures and algorithms, profiling/optimization</li>
</ul>
<p>Desired</p>
<ul>
<li>Devops experience</li>
<li>Github profile or link to open source work</li>
<li>Comfortable working with version control using Git</li>
<li>Adequate communication skills in English</li>
</ul>
<p>【联系我们】
如果您对工作职位感兴趣，请将您的简历或情况发送到邮箱<a href="mailto:sindy@melotic.com">sindy@melotic.com</a>联系我们，我们会尽快回复~</p>
</div>

2015年五月5日中午 11:36:05
CentOS 7 安装 Gitlab
<h2>安装基本系统与依赖包</h2>

<h3>安装 Gitlab 依赖的工具</h3>

<pre><code>bash</code><code>yum -y update
yum -y groupinstall 'Development Tools'
yum -y install readline readline-devel ncurses-devel gdbm-devel glibc-devel tcl-devel openssl-devel curl-devel expat-devel db4-devel byacc sqlite-devel libyaml libyaml-devel libffi libffi-devel libxml2 libxml2-devel libxslt libxslt-devel libicu libicu-devel system-config-firewall-tui git redis ruby sudo wget crontabs logwatch logrotate perl-Time-HiRes
</code></pre>

<h3>安装 Redis</h3>

<p>访问 <a rel="nofollow" href="http://www.redis.io/download"></a><a rel="nofollow" href="http://www.redis.io/download">http://www.redis.io/download</a>，下载 <strong>Redis</strong> 源代码。</p>

<pre><code>bash</code><code>wget http://download.redis.io/releases/redis-3.0.0.tar.gz
tar zxvf redis-3.0.0.tar.gz
cd redis-3.0.0
make
</code></pre>

<blockquote>
  <p>若在编译过程中出错，则可以执行下面的命令：</p>

<pre><code>bash</code><code>sudo make test
</code></pre>
</blockquote>

<h4>安装：</h4>

<pre><code>bash</code><code>sudo make install
sudo ./utils/install_server.sh
</code></pre>

<h4>配置</h4>

<p>创建 <code>/etc/init.d/redis</code> 并使用下面的代码作为启动脚本。</p>

<p>添加如下内容：</p>

<pre><code>bash</code><code>###########################
PATH=/usr/local/bin:/sbin:/usr/bin:/bin

REDISPORT=6379
EXEC=/usr/local/bin/redis-server
REDIS_CLI=/usr/local/bin/redis-cli

PIDFILE=/var/run/redis.pid
CONF="/etc/redis/6379.conf"

case "$1" in
    start)
        if [ -f $PIDFILE ]
        then
                echo "$PIDFILE exists, process is already running or crashed"
        else
                echo "Starting Redis server..."
                $EXEC $CONF
        fi
        if [ "$?"="0" ]
        then
              echo "Redis is running..."
        fi
        ;;
    stop)
        if [ ! -f $PIDFILE ]
        then
                echo "$PIDFILE does not exist, process is not running"
        else
                PID=$(cat $PIDFILE)
                echo "Stopping ..."
                $REDIS_CLI -p $REDISPORT SHUTDOWN
                while [ -x ${PIDFILE} ]
               do
                    echo "Waiting for Redis to shutdown ..."
                    sleep 1
                done
                echo "Redis stopped"
        fi
        ;;
   restart|force-reload)
        ${0} stop
        ${0} start
        ;;
  *)
    echo "Usage: /etc/init.d/redis {start|stop|restart|force-reload}" &gt;&amp;2
        exit 1
esac
##############################
</code></pre>

<p>保存后，添加可执行权限：</p>

<pre><code>sudo chmod +x /etc/init.d/redis
</code></pre>

<p>确保 <code>redis</code> 能随系统启动：</p>

<pre><code>vi /etc/rc.d/rc.local
</code></pre>

<p>在文件末尾添加下面这行：</p>

<pre><code>service redis start
</code></pre>

<p>然后使用上面同样的命令启动 <code>redis</code> 服务：</p>

<pre><code>service redis start
</code></pre>

<h3>安装邮件服务器</h3>

<pre><code>yum -y install postfix
</code></pre>

<h3>安装Git</h3>

<p>先删除系统中原有的老版本 <code>git</code>：</p>

<pre><code>bash</code><code>yum -y remove git
yum install zlib-devel perl-CPAN gettext curl-devel expat-devel gettext-devel openssl-devel
</code></pre>

<p>从官方网站下载源代码进行：</p>

<pre><code>bash</code><code>curl --progress https://www.kernel.org/pub/software/scm/git/git-2.4.0.tar.gz | tar xz
cd git-2.4.0/
./configure
make
make prefix=/usr/local install
</code></pre>

<p>然后使用下面这个命令检测安装是否有效：</p>

<pre><code>which git
</code></pre>

<h2>安装 ruby</h2>

<p>如果 ruby 的版本低于 <code>2.0</code> 的话，则需要重新安装 <code>ruby</code>。</p>

<pre><code>bash</code><code>cd ~
curl --progress ftp://ftp.ruby-lang.org/pub/ruby/2.2/ruby-2.2.2.tar.gz | tar xz
cd ruby-2.2.2
./configure --disable-install-rdoc
make
make prefix=/usr/local install
</code></pre>

<h2>为 Gitlab 添加系统用户</h2>

<pre><code>adduser --system --shell /bin/bash --comment 'GitLab' --create-home --home-dir /home/git/ git
</code></pre>

<p>为了包含/usr/local/bin到git用户的$PATH，一个方法是编辑超级用户文件。以管理员身份运行：</p>

<pre><code>visudo
</code></pre>

<p>然后搜索：</p>

<pre><code>Defaults    secure_path = /sbin:/bin:/usr/sbin:/usr/bin
</code></pre>

<p>将其改成：</p>

<pre><code>Defaults    secure_path = /sbin:/bin:/usr/sbin:/usr/bin:/usr/local/bin
</code></pre>

<h2>安装数据库</h2>

<p>MySQL 已经不再包含在 CentOS 7 的源中，而改用了 MariaDB，先搜索 <code>MariaDB</code> 现有的包：</p>

<pre><code>rpm -qa | grep mariadb
</code></pre>

<p>然后全部删除：</p>

<pre><code>rpm -e --nodeps mariadb-*
</code></pre>

<p>然后创建 <code>/etc/yum.repos.d/MariaDB.repo</code>：</p>

<pre><code>vi /etc/yum.repos.d/MariaDB.repo
</code></pre>

<p>将以下内容添加至该文件中：</p>

<pre><code># MariaDB 10.0 CentOS repository list - created 2015-05-04 19:16 UTC
# http://mariadb.org/mariadb/repositories/
[mariadb]
name = MariaDB
baseurl = http://yum.mariadb.org/10.0/centos7-amd64
gpgkey=https://yum.mariadb.org/RPM-GPG-KEY-MariaDB
gpgcheck=1
</code></pre>

<p>然后运行下面命令安装 <code>MariaDB 10.0</code>：</p>

<pre><code>sudo yum install MariaDB-server MariaDB-client
</code></pre>

<p>然后启动 MariaDB 服务：</p>

<pre><code>service mysql start
</code></pre>

<p>接着运行 <code>mysql_secure_installation</code>：</p>

<pre><code>mysql_secure_installation
</code></pre>

<p>登录 MariaDB 并创建相应的数据库用户与数据库：</p>

<pre><code>mysql -uroot -p
CREATE USER 'git'@'localhost' IDENTIFIED BY '$password';
SET storage_engine=INNODB;
CREATE DATABASE IF NOT EXISTS `gitlabhq_production` DEFAULT CHARACTER SET `utf8` COLLATE `utf8_unicode_ci`;
GRANT SELECT, LOCK TABLES, INSERT, UPDATE, DELETE, CREATE, DROP, INDEX, ALTER ON `gitlabhq_production`.* TO 'git'@'localhost';
\q
</code></pre>

<p>尝试使用新用户连接数据库：</p>

<pre><code>sudo -u git -H mysql -u git -p -D gitlabhq_production
\q
</code></pre>

<h2>安装 Gitlab</h2>

<h3>克隆源</h3>

<pre><code>sudo -u -git cd /home/git
sudo -u git -H git clone https://gitlab.com/gitlab-org/gitlab-ce.git -b 7-10-stable gitlab
</code></pre>

<h3>配置</h3>

<pre><code>cd /home/git/gitlab

# Copy the example GitLab config
# 复制GitLab的示例配置文件
sudo -u git -H cp config/gitlab.yml.example config/gitlab.yml

# Make sure to change "localhost" to the fully-qualified domain name of your host serving GitLab where necessary
# 确保修改“localhost”为你的GitLab主机的FQDN
#
# If you want to use https make sure that you set `https` to `true`. See #using-https for all necessary details.
# 如果你想要使用https确保你设置了`https`为`true`。具体必要的细节参见#using-https
#
# If you installed Git from source, change the git bin_path to /usr/local/bin/git
# 如果你从源代码安装了Git，修改git的bin_path为/usr/local/bin/git
sudo -u git -H editor config/gitlab.yml

# Make sure GitLab can write to the log/ and tmp/ directories
# 确保GitLab可以写入log/和temp/目录
chown -R git {log,tmp}
chmod -R u+rwX  {log,tmp}

# Create directory for satellites
# 为卫星(?)创建目录
sudo -u git -H mkdir /home/git/gitlab-satellites
chmod u+rwx,g+rx,o-rwx /home/git/gitlab-satellites

# Make sure GitLab can write to the tmp/pids/ and tmp/sockets/ directories
# 确保GitLab可以写入tmp/pids/和temp/sockets/目录
chmod -R u+rwX  tmp/{pids,sockets}

# Make sure GitLab can write to the public/uploads/ directory
# 确保GitLab可以写入public/uploads/目录
chmod -R u+rwX  public/uploads

# Copy the example Unicorn config
# 复制Unicorn的示例配置文件
sudo -u git -H cp config/unicorn.rb.example config/unicorn.rb

# Enable cluster mode if you expect to have a high load instance
# Ex. change amount of workers to 3 for 2GB RAM server
# 启用集群模式如果你期望拥有一个高负载实例
# 附：修改worker的数量到3用于2GB内存的服务器
sudo -u git -H editor config/unicorn.rb

# Copy the example Rack attack config
# 复制Rack attack的示例配置文件
sudo -u git -H cp config/initializers/rack_attack.rb.example config/initializers/rack_attack.rb

# Configure Git global settings for git user, useful when editing via web
# Edit user.email according to what is set in config/gitlab.yml
# 为git用户配置Git全局设定，当通过web修改时有用
# 修改user.email根据config/gitlab.yml中的设定
sudo -u git -H git config --global user.name "GitLab"
sudo -u git -H git config --global user.email "gitlab@localhost"
sudo -u git -H git config --global core.autocrlf input
</code></pre>

<h2>数据库配置</h2>

<pre><code># MySQL only:
# 仅限MySQL：
sudo -u git cp config/database.yml.mysql config/database.yml

# MySQL and remote PostgreSQL only:
# Update username/password in config/database.yml.
# You only need to adapt the production settings (first part).
# If you followed the database guide then please do as follows:
# Change 'secure password' with the value you have given to $password
# You can keep the double quotes around the password
# 仅限MySQL和远程PostgreSQL：
# 在config/database.yml中更新用户名/密码；
# 你只需要适配生产设定（第一部分）；
# 如果你跟从数据库向导，请按以下操作：
# 修改'secure password'使用你刚才设定的$password；
# 你可以保留密码两端的双引号。
sudo -u git -H editor config/database.yml

# PostgreSQL and MySQL:
# Make config/database.yml readable to git only
# PostgreSQL和MySQL：
# 设置config/database.yml仅对git可读。
sudo -u git -H chmod o-rwx config/database.yml
</code></pre>

<h3>安装 Gems</h3>

<pre><code>cd /home/git/gitlab

# For users from China mainland only
# 仅限中国大陆用户
nano /home/git/gitlab/Gemfile
source "http://ruby.taobao.org" // 原始 source "https://rubygems.org/"

# For MySQL (note, the option says "without ... postgres")
sudo -u git -H bundle install --deployment --without development test postgres aws
</code></pre>

<h2>Install GitLab shell</h2>

<h3>安装GitLab Shell</h3>

<p>GitLab Shell是一个专门为GitLab开发的SSH访问和源管理软件。</p>

<pre><code># Go to the Gitlab installation folder:
# 转到GitLab安装目录：
cd /home/git/gitlab

# For users from China mainland only
# 仅限中国大陆用户
nano /home/git/gitlab/Gemfile
source "http://ruby.taobao.org" // 原始 source "https://rubygems.org/"

# Run the installation task for gitlab-shell (replace `REDIS_URL` if needed):
# 运行gitlab-shell的安装任务（替换`REDIS_URL`如果有需要的话）：
sudo -u git -H bundle exec rake gitlab:shell:install[v1.9.6] REDIS_URL=redis://localhost:6379 RAILS_ENV=production

# By default, the gitlab-shell config is generated from your main gitlab config.
# 默认的，gitlab-shell的配置文件是由你的gitlab主配置文件生成的。
#
# Note: When using GitLab with HTTPS please change the following:
# - Provide paths to the certificates under `ca_file` and `ca_path options.
# - The `gitlab_url` option must point to the https endpoint of GitLab.
# - In case you are using self signed certificate set `self_signed_cert` to `true`.
# See #using-https for all necessary details.
# 提示：当通过HTTPS使用GitLab时，请做出如下更改：
# - 提供证书的路径在`ca_file`和`ca_path`选项；
# - `gitlab_url`选项必须指向GitLab的https端点；
# - 如果你使用自签名的证书，设置`self-signed_cert`为`true`。
# 所有必需的具体细节参见#using-https
#
# You can review (and modify) it as follows:
# 你可以检查（并修改该）通过以下方法：
sudo -u git -H editor /home/git/gitlab-shell/config.yml

# Ensure the correct SELinux contexts are set
# Read http://wiki.centos.org/HowTos/Network/SecuringSSH
# 确保正确的SELinux上下文被设置
# 阅读http://wiki.centos.org/HowTos/Network/SecuringSSH
restorecon -Rv /home/git/.ssh
</code></pre>

<h3>初始化数据库和激活高级功能</h3>

<pre><code>sudo -u git -H bundle exec rake gitlab:setup RAILS_ENV=production
# Type 'yes' to create the database tables.
# When done you see 'Administrator account created:'
</code></pre>

<p>提示：你可以设置管理员密码通过在环境变量GITLAB_ROOT_PASSWORD中提供，例如：</p>

<pre><code>sudo -u git -H bundle exec rake gitlab:setup RAILS_ENV=production GITLAB_ROOT_PASSWORD=newpassword
</code></pre>

<h3>安装初始化脚本</h3>

<p>下载初始化脚本（将放在/etc/init.d/gitlab）：</p>

<pre><code>sudo cp lib/support/init.d/gitlab /etc/init.d/gitlab
chmod +x /etc/init.d/gitlab
chkconfig --add gitlab
</code></pre>

<p>设置GitLab开机启动：</p>

<pre><code>chkconfig gitlab on
</code></pre>

<p>设置日志翻转</p>

<pre><code>cp lib/support/logrotate/gitlab /etc/logrotate.d/gitlab
</code></pre>

<h3>检查应用状态</h3>

<pre><code>sudo -u git -H bundle exec rake gitlab:env:info RAILS_ENV=production
</code></pre>

<h3>编译静态文件</h3>

<pre><code>sudo -u git -H bundle exec rake assets:precompile RAILS_ENV=production
</code></pre>

<h3>启动实例</h3>

<pre><code>/etc/init.d/gitlab start
</code></pre>

2015年五月5日上午 11:16:04
布隆过滤器 -- 空间效率很高的数据结构
<h2>哈希 hash</h2>

<h3>原理</h3>

<p>Hash （哈希，或者散列）函数在计算机领域，尤其是数据快速查找领域，加密领域用的极广。</p>

<p><strong>其作用是将一个大的数据集映射到一个小的数据集上面（这些小的数据集叫做哈希值，或者散列值）</strong>。</p>

<p>一个应用是Hash table（散列表，也叫哈希表），是根据哈希值 (Key value) 而直接进行访问的数据结构。也就是说，它通过把哈希值映射到表中一个位置来访问记录，以加快查找的速度。下面是一个典型的 hash 函数 / 表示意图：</p>

<p><img src="/img/bVlCe5" alt="图片描述"></p>

<p>哈希函数有以下两个特点：</p>

<ul>
<li>如果两个散列值是不相同的（根据同一函数），那么这两个散列值的原始输入也是不相同的。</li>
<li>散列函数的输入和输出不是唯一对应关系的，如果两个散列值相同，两个输入值很可能是相同的。但也可能不同，这种情况称为 “散列碰撞”（或者 “散列冲突”）。</li>
</ul>
<p>缺点： 引用吴军博士的《数学之美》中所言，哈希表的空间效率还是不够高。如果用哈希表存储一亿个垃圾邮件地址，每个email地址 对应 8bytes, 而哈希表的存储效率一般只有50%，因此一个email地址需要占用16bytes. 因此一亿个email地址占用1.6GB，如果存储几十亿个email address则需要上百GB的内存。除非是超级计算机，一般的服务器是无法存储的。</p>

<p>所以要引入下面的 Bloom Filter。</p>

<h2>布隆过滤器 Bloom Filter</h2>

<h3>原理</h3>

<p>如果想判断一个元素是不是在一个集合里，一般想到的是将集合中所有元素保存起来，然后通过比较确定。链表、树、散列表（又叫哈希表，Hash table）等等数据结构都是这种思路。但是随着集合中元素的增加，我们需要的存储空间越来越大。同时检索速度也越来越慢。</p>

<p>Bloom Filter 是一种空间效率很高的随机数据结构，Bloom filter 可以看做是对 bit-map 的扩展, 它的原理是：</p>

<p>当一个元素被加入集合时，通过 <code>K</code> 个 <code>Hash 函数</code>将这个元素映射成一个<code>位阵列（Bit array）中的 K 个点</code>，把它们置为 <code>1</code>。检索时，我们只要看看这些点是不是都是 1 就（大约）知道集合中有没有它了：</p>

<ul>
<li>如果这些点有任何一个 0，则被检索元素<strong>一定不在</strong>；</li>
<li>如果都是 1，则被检索元素<strong>很可能</strong>在。</li>
</ul>
<h3>优点</h3>

<blockquote>
  <p>It tells us that the element either definitely is not in the set or may be in the set.</p>
</blockquote>

<p>它的优点是<code>空间效率</code>和<code>查询时间</code>都远远超过一般的算法，布隆过滤器存储空间和插入 / 查询时间都是常数<code>O(k)</code>。另外, 散列函数相互之间没有关系，方便由硬件并行实现。布隆过滤器不需要存储元素本身，在某些对保密要求非常严格的场合有优势。</p>

<h3>缺点</h3>

<p>但是布隆过滤器的缺点和优点一样明显。误算率是其中之一。随着存入的元素数量增加，<code>误算率</code>随之增加。但是如果元素数量太少，则使用散列表足矣。</p>

<p>(误判补救方法是：再建立一个小的白名单，存储那些可能被误判的信息。)</p>

<p>另外，一般情况下不能从布隆过滤器中<code>删除</code>元素. 我们很容易想到把位数组变成整数数组，每插入一个元素相应的计数器加 1, 这样删除元素时将计数器减掉就可以了。然而要保证安全地删除元素并非如此简单。首先我们必须保证删除的元素的确在布隆过滤器里面. 这一点单凭这个过滤器是无法保证的。另外计数器回绕也会造成问题。</p>

<h3>Example</h3>

<p>可以快速且空间效率高的判断一个元素是否属于一个集合；用来实现数据字典，或者集合求交集。</p>

<p>如： Google chrome 浏览器使用bloom filter识别恶意链接（能够用较少的存储空间表示较大的数据集合，简单的想就是把每一个URL都可以映射成为一个bit）<br>
得多，并且误判率在万分之一以下。<br>
又如： 检测垃圾邮件</p>

<pre><code>假定我们存储一亿个电子邮件地址，我们先建立一个十六亿二进制（比特），即两亿字节的向量，然后将这十六亿个二进制全部设置为零。对于每一个电子邮件地址 X，我们用八个不同的随机数产生器（F1,F2, ...,F8） 产生八个信息指纹（f1, f2, ..., f8）。再用一个随机数产生器 G 把这八个信息指纹映射到 1 到十六亿中的八个自然数 g1, g2, ...,g8。现在我们把这八个位置的二进制全部设置为一。当我们对这一亿个 email 地址都进行这样的处理后。一个针对这些 email 地址的布隆过滤器就建成了。
</code></pre>

<p>再如此题：</p>

<pre><code>A,B 两个文件，各存放 50 亿条 URL，每条 URL 占用 64 字节，内存限制是 4G，让你找出 A,B 文件共同的 URL。如果是三个乃至 n 个文件呢？

分析 ：如果允许有一定的错误率，可以使用 Bloom filter，4G 内存大概可以表示 340 亿 bit。将其中一个文件中的 url 使用 Bloom filter 映射为这 340 亿 bit，然后挨个读取另外一个文件的 url，检查是否与 Bloom filter，如果是，那么该 url 应该是共同的 url（注意会有一定的错误率）。”
</code></pre>

<p><a rel="nofollow" href="http://citeseer.ist.psu.edu/viewdoc/download;jsessionid=6CA79DD1A90B3EFD3D62ACE5523B99E7?doi=10.1.1.127.9672&amp;rep=rep1&amp;type=pdf">Network applications of Bloom Filter: a survey</a></p>

2015年五月5日上午 11:05:30
node.js通过get访问该网址，返回302？
<div class="markdown-text"><p>网址：<a href="http://search.jd.com/Search?keyword=%E7%AC%94%E8%AE%B0%E6%9C%AC&amp;enc=utf-8">http://search.jd.com/Search?keyword=%E7%AC%94%E8%AE%B0%E6%9C%AC&amp;enc=utf-8</a>
该网址是京东搜索笔记本的url；</p>
</div>

2015年五月5日上午 10:52:28
alsotang starred coocood/freecache
<!-- watch -->
<div class="simple">
  <span class="octicon octicon-star"></span>

  <div class="title">
    <a href="https://github.com/alsotang" data-ga-click="News feed, event click, Event click type:WatchEvent target:actor">alsotang</a> <span>starred</span> <a href="https://github.com/coocood/freecache" data-ga-click="News feed, event click, Event click type:WatchEvent target:repo">coocood/freecache</a>
  </div>

  <div class="time">
    <time datetime="2015-05-05T02:52:28Z" is="relative-time">May 5, 2015</time>
  </div>
</div>

2015年五月5日早上 7:55:36
命令行模式下的思维导图：mindmap
<div class="markdown-text"><h3>安装：</h3>
<p>npm install mindmap</p>
<h3>截图：</h3>
<p><img src="http://i.imgur.com/gEZsVCW.png" alt="screenshot"></p>
<h3>用法：</h3>
<pre class="prettyprint"><code>  load [mindmap name] or l [mindmap name]
    Load or create a mindmap.
  add [id] [text] or a [id] [text]
    Add a child.
  insert [id] [text] or i [id] [text]
    Insert a node.
        insert -1 Animal
        insert 10 White house
  edit [id] [text] or e [id] [text]
    Edit a node.
  delete [id] or del [id] or d [id]
    Delete a node.
  help or h
    Help information.
  exit
    Exit program.
</code></pre></div>

2015年五月4日晚上 11:57:41
请教这段代码cluster worker和net模块一起使用为何会出现阻塞？
<div class="markdown-text"><p>很神奇的是，在master里直接调用socketHandler的话ab测试下不会阻塞</p>
<p>在worker里调用，ab测试并发数为1的时候不会阻塞</p>
<p>但像下面这样写，ab测试</p>
<pre class="prettyprint"><code>ab -n 10 -c 2 http://localhost:10086
</code></pre><p>请求直接就阻塞了。。。</p>
<pre class="prettyprint"><code>var net = require(&#x27;net&#x27;);
var http = require(&#x27;http&#x27;);
var cluster = require(&#x27;cluster&#x27;);

var recevice_socket_count = 0;
var recevice_http_count = 0;

var httpServer = http.createServer(function(req,res){
    console.log(&#x27;recevice_http_count&#x27;,++recevice_http_count);
    res.write(&#x27;wow&#x27;);
    res.end();
});

function socketHandler(socket){
  console.log(&#x27;recevice_socket_count&#x27;,++recevice_socket_count);
  socket.readable = socket.writeable = true;
  httpServer.emit(&#x27;connection&#x27;,socket);
  socket.emit(&#x27;connect&#x27;);
}


if(cluster.isMaster){
  var worker = cluster.fork();
  net.createServer(function(socket){
    worker.send(&quot;socket&quot;, socket);
    //socketHandler(socket);
  }).listen(10086, function() {
    console.log(&#x27;netServer bound&#x27;);
  });
}else{

  cluster.worker.on(&quot;message&quot;, function(data, socket) {
        socketHandler(socket);
  });
}

</code></pre></div>

2015年五月4日晚上 10:43:37
做了个模板引擎 nging
<div class="markdown-text"><h3>安装：</h3>
<p>npm install nging</p>
<h3>用法：</h3>
<pre class="prettyprint language-js"><code>var app = require(&quot;express&quot;)();
var nging = require(&quot;nging&quot;);
 
function Comment() {
    this.jml = function() {
        return [&quot;div&quot;,{className:&quot;comment&quot;},
                    [&quot;h2&quot;,{className:&quot;commentAuthor&quot;, style:this.props.style},
                        this.props.author
                    ]
               ].concat(this.props.nodes);
    };
}
 
function CommentList() {
    this.jml = function() {
        var commentNodes = this.props.data.map(function (comment) {
          return [Comment, {author:comment.author}, comment.text];
        });
 
        return [&quot;div&quot;, {className:&quot;commentList&quot;}].concat(commentNodes);
    };
}
 
var comments = [
  {&quot;author&quot;: &quot;Pete Hunt&quot;, &quot;text&quot;: &quot;This is one comment&quot;},
  {&quot;author&quot;: &quot;Jordan Walke&quot;, &quot;text&quot;: &quot;This is *another* comment&quot;}
];
 
var jml1 = [&quot;div&quot;,{class:&quot;yes&quot;},[&quot;p&quot;,{style:&quot;color:red&quot;},&quot;Hello!!!&quot;,[&quot;img&quot;,{src:&quot;http://i.imgur.com/gEZsVCW.png&quot;,width:500}]]];
var jml2 = [&quot;html&quot;,[&quot;body&quot;,[&quot;div&quot;,&quot;dfe&quot;],[&quot;span&quot;,&quot;ddd&quot;]]];
 
var jml3 = [Comment, {author:&quot;John&quot;, style:&quot;color:red&quot;}, &quot;Hello!&quot;];
 
var jml4 = [&quot;html&quot;,jml3,jml3,jml3,jml3,jml3,jml3,jml3];
 
var jml5 =[&quot;form&quot;,{className:&quot;commentForm&quot;, onSubmit:&quot;this.handleSubmit&quot;},
            [&quot;input&quot;, {type:&quot;text&quot;, placeholder:&quot;Your name&quot;, ref:&quot;author&quot;}],
            [&quot;input&quot;, {type:&quot;text&quot;, placeholder:&quot;Say something...&quot;, ref:&quot;text&quot;}],
            [&quot;input&quot;, {type:&quot;submit&quot;, value:&quot;Post&quot;}]
        ];
 
var jml6 =[CommentList, {data:comments}];
 
var jml7 = [&quot;html&quot;, jml1,jml2,jml3,jml4,jml5];
 
app.get(&quot;/&quot;, function(req, res) {
    res.send(nging.render(jml7));
});
 
app.listen(8080);

</code></pre></div>

2015年五月4日晚上 10:27:23
请问有什么分析日志的好的方法或者工具么？
<div class="markdown-text"><p>比如在我的node服务里，我把每一个请求完成的响应时间都写在了本地的log文件里，我想统计所有请求的平均响应时间，是不是只能靠编写复杂的shell脚本来实现？另外关于日志文件，有什么好的管理方法么？比如定期清理过时的日志文件应该怎么做呢？</p>
</div>

2015年五月4日晚上 9:53:45
[译] Python 学习 —— __init__() 方法 2
<h3><strong>通过工厂函数对 <code>__init__()</code> 加以利用</strong></h3>

<p>我们可以通过工厂函数来构建一副完整的扑克牌。这会比枚举所有52张扑克牌要好得多，在Python中，我们有如下两种常见的工厂方法：</p>

<ul>
<li><p>定义一个函数，该函数会创建所需类的对象。</p></li>
<li><p>定义一个类，该类有创建对象的方法。这是一个完整的工厂设计模式，正如设计模式书所描述的那样。在诸如Java这样的语言中，工厂类层次结构是必须的，因为该语言不支持独立的函数。</p></li>
</ul>
<p>在Python中，类并不是<em>必须</em>的。只是当有相关的工厂非常复杂的时候才会显现出优势。Python的优势就是当一个简单的函数可以做的更好的时候我们决不强迫使用类层次结构。</p>

<blockquote>
  <p>虽然这是一本关于面向对象编程的书，但函数真是一个好东西。这在Python中是常见的也是最地道的。</p>
</blockquote>

<p>如果需要的话，我们总是可以将一个函数重写为适当的可调用对象。我们可以将一个可调用对象重构到我们的工厂类层次结构中。我们将在第五章《使用可调用对象和上下文》中学习可调用对象。</p>

<p>一般，类定义的优点是通过继承实现代码重用。工厂类的函数就是包装一些目标类层次结构和复杂对象的构造。如果我们有一个工厂类，当扩展目标类层次结构的时候，我们可以添加子类到工厂类中。这给我们提供了多态性工厂类；不同的工厂类定义具有相同的方法签名，可以交替使用。</p>

<p>这类水平的多态性对于静态编译语言如Java或C++非常有用。编译器可以解决类和方法生成代码的细节。</p>

<p>如果选择的工厂定义不能重用任何代码，则在Python中类层次结构不会有任何帮助。我们可以简单的使用具有相同签名的函数。</p>

<p>以下是我们各种<code>Card</code>子类的工厂函数：</p>

<pre><code>python</code><code>def card(rank, suit):
    if rank == 1:
        return AceCard('A', suit)
    elif 2 &lt;= rank &lt; 11: 
        return NumberCard(str(rank), suit)

    elif 11 &lt;= rank &lt; 14:
        name = {11: 'J', 12: 'Q', 13: 'K' }[rank]
        return FaceCard(name, suit)
    else:
        raise Exception("Rank out of range")
</code></pre>

<p>这个函数通过数值类型的<code>rank</code>和<code>suit</code>对象构建<code>Card</code>类。我们现在可以非常简单的构建牌了。我们已经封装构造问题到一个单一的工厂函数中，允许应用程序在不知道精确的类层次结构和多态设计是如何工作的情况下进行构建。</p>

<p>下面是一个如何通过这个工厂函数构建一副牌的示例：</p>

<pre><code>python</code><code>deck = [card(rank, suit) for rank in range(1,14) for suit in (Club, Diamond, Heart, Spade)]
</code></pre>

<p>它枚举了所有的牌值和花色来创建完整的52张牌。</p>

<h4><strong>1. 错误的工厂设计和模糊的else子句</strong></h4>

<p>注意<code>card()</code>函数里面的<code>if</code>语句结构。我们没有使用“包罗万象”的<code>else</code>子句来做任何处理；我们只是抛出异常。使用“包罗万象”的<code>else</code>子句会引出一个小小的辩论。</p>

<p>一方面，从属于<code>else</code>子句的条件不能不言而喻，因为它可能隐藏着微妙的设计错误。另一方面，一些<code>else</code>子句确实是显而易见的。</p>

<p>重要的是要避免含糊的<code>else</code>子句。</p>

<p>考虑下面工厂函数定义的变体：</p>

<pre><code>python</code><code>def card2(rank, suit):
    if rank == 1: 
        return AceCard('A', suit)
    elif 2 &lt;= rank &lt; 11: 
        return NumberCard(str(rank), suit)
    else:
        name = {11: 'J', 12: 'Q', 13: 'K'}[rank]
        return FaceCard(name, suit)
</code></pre>

<p>以下是当我们尝试创建整副牌将会发生的事情：</p>

<pre><code>python</code><code>deck2 = [card2(rank, suit) for rank in range(13) for suit in (Club, Diamond, Heart, Spade)]
</code></pre>

<p>它起作用了吗？如果<code>if</code>条件更复杂了呢？</p>

<p>一些程序员扫视的时候可以理解这个<code>if</code>语句。其他人将难以确定是否所有情况都正确执行了。</p>

<p>对于高级Python编程，我们不应该把它留给读者去演绎条件是否适用于<code>else</code>子句。对于菜鸟条件应该是显而易见的，至少也应该是显示的。</p>

<p><strong>何时使用“包罗万象”的else</strong></p>

<p>尽量的少使用。使用它只有当条件是显而易见的时候。当有疑问时，显式的并抛出异常。</p>

<p>避免含糊的<code>else</code>子句。</p>

<h4><strong>2. 简单一致的使用elif序列</strong></h4>

<p>我们的工厂函数<code>card()</code>是两种常见工厂设计模式的混合物:</p>

<ul>
<li><p><code>if-elif</code>序列</p></li>
<li><p>映射</p></li>
</ul>
<p>为了简单起见，最好是专注于这些技术的一个而不是两个。</p>

<p>我们总是可以用映射来代替<code>elif</code>条件。（是的，总是。但相反是不正确的；改变<code>elif</code>条件为映射将是具有挑战性的。）</p>

<p>以下是没有映射的<code>Card</code>工厂：</p>

<pre><code>python</code><code>def card3(rank, suit):
    if rank == 1: 
        return AceCard('A', suit)
    elif 2 &lt;= rank &lt; 11: 
        return NumberCard(str(rank), suit)
    elif rank == 11:
        return FaceCard('J', suit)
    elif rank == 12:
        return FaceCard('Q', suit)
    elif rank == 13:
        return FaceCard('K', suit)
    else:
        raise Exception("Rank out of range")
</code></pre>

<p>我们重写了<code>card()</code>工厂函数。映射已经转化为额外的<code>elif</code>子句。这个函数有个优点就是它比之前的版本更加一致。</p>

<h4><strong>3. 简单的使用映射和类对象</strong></h4>

<p>在一些示例中，我们可以使用映射来代替一连串的<code>elif</code>条件。很可能发现条件太复杂，这个时候或许只有使用一连串的<code>elif</code>条件来表达才是明智的选择。对于简单示例，无论如何，映射可以做的更好且可读性更强。</p>

<p>因为<code>class</code>是最好的对象，我们可以很容易的映射<code>rank</code>参数到已经构造好的类中。</p>

<p>以下是仅使用映射的<code>Card</code>工厂：</p>

<pre><code>python</code><code> def card4(rank, suit):
    class_= {1: AceCard, 11: FaceCard, 12: FaceCard, 13: FaceCard}.get(rank, NumberCard)
    return class_(rank, suit)
</code></pre>

<p>我们已经映射<code>rank</code>对象到类中。然后，我们传递<code>rank</code>值和<code>suit</code>值到类来创建最终的<code>Card</code>实例。</p>

<p>最好我们使用<code>defaultdict</code>类。无论如何，对于微不足道的静态映射不会比这更简单了。看起来像下面代码片段那样：</p>

<pre><code>python</code><code>defaultdict(lambda: NumberCard, {1: AceCard, 11: FaceCard, 12: FaceCard, 12: FaceCard})
</code></pre>

<p>注意：<code>defaultdict</code>类<em>默认</em>必须是零参数的函数。我们已经使用了<code>lambda</code>创建必要的函数来封装常量。这个函数，无论如何，都有一些缺陷。对于我们之前版本中缺少<code>1</code>到<code>A</code>和<code>13</code>到<code>K</code>的转换。当我们试图增加这些特性时，一定会出现问题的。</p>

<p>我们需要修改映射来提供可以和字符串版本的<code>rank</code>对象一样的<code>Card</code>子类。对于这两部分的映射我们还可以做什么？有四种常见解决方案：</p>

<ul>
<li>可以做两个并行的映射。我们不建议这样，但是会强调展示不可取的地方。</li>
<li>可以映射个二元组。这个同样也会有一些缺点。</li>
<li>可以映射到<code>partial()</code>函数。<code>partial()</code>函数是<code>functools</code>模块的一个特性。</li>
<li>可以考虑修改我们的类定义，这种映射更容易。可以在下一节将<code>__init__()</code>置入子类定义中看到。</li>
</ul>
<p>我们来看看每一个具体的例子。</p>

<h5><strong>3.1. 两个并行映射</strong></h5>

<p>以下是两个并行映射解决方案的关键代码：</p>

<pre><code>python</code><code>class_= {1: AceCard, 11: FaceCard, 12: FaceCard, 13: FaceCard}.get(rank, NumberCard)
rank_str= {1:'A', 11:'J', 12:'Q', 13:'K'}.get(rank, str(rank))
return class_(rank_str, suit)
</code></pre>

<p>这并不可取的。它涉及到重复映射键<code>1</code>、<code>11</code>、<code>12</code>和<code>13</code>序列。重复是糟糕的，因为在软件更新后并行结构依然保持这种方式。</p>

<p><strong>不要使用并行结构</strong></p>

<p>并行结构必须使用元组或一些其他合适的集合来替代。</p>

<h5><strong>3.2. 映射到元组的值</strong></h5>

<p>以下是二元组映射的关键代码：</p>

<pre><code>python</code><code>class_, rank_str= {
    1: (AceCard,'A'),
    11: (FaceCard,'J'),
    12: (FaceCard,'Q'),
    13: (FaceCard,'K'),
}.get(rank, (NumberCard, str(rank)))
return class_(rank_str, suit)
</code></pre>

<p>这是相当不错的。不需要过多的代码来分类打牌中的特殊情况。当我们需要改变<code>Card</code>类层次结构来添加额外的<code>Card</code>子类时，我们将看到它如何被修改或被扩展。</p>

<p>将<code>rank</code>值映射到一个类对象的确让人感觉奇怪，且只有类初始化所需两个参数中的其中之一。将牌值映射到一个简单的类或没有提供一些混乱参数(但不是所有)的函数对象似乎会更合理。</p>

<h5><strong>3.3. partial函数解决方案</strong></h5>

<p>相比映射到二元组函数和参数之一，我们可以创建一个<code>partial()</code>函数。这是一个已经提供一些(但不是所有)参数的函数。我们将从<code>functools</code>库中使用<code>partial()</code>函数来创建一个带有<code>rank</code>参数的partial类。</p>

<p>以下是一个映射<code>rank</code>到<code>partial()</code>函数，可用于对象创建：</p>

<pre><code>python</code><code>from functools import partial
part_class= {
   1: partial(AceCard, 'A'),
   11: partial(FaceCard, 'J'),
   12: partial(FaceCard, 'Q'),
   13: partial(FaceCard, 'K'),
}.get(rank, partial(NumberCard, str(rank)))
return part_class(suit)
</code></pre>

<p>映射将<code>rank</code>对象与<code>partial()</code>函数联系在一起，并分配给<code>part_class</code>。这个<code>partial</code>()函数可以被应用到<code>suit</code>对象来创建最终的对象。<code>partial()</code>函数是一种常见的函数式编程技术。它在我们有一个函数来替代对象方法这一特定的情况下使用。</p>

<p>不过总体而言，<code>partial()</code>函数对于大多数面向对象编程并没有什么帮助。相比创建<code>partial()</code>函数，我们可以简单地更新类的方法来接受不同组合的参数。<code>partial()</code>函数类似于给对象构造创建一个连贯的接口。</p>

<h5><strong>3.4. 连贯的工厂类接口</strong></h5>

<p>在某些情况下，我们设计的类为方法的使用定义了顺序，衡量方法的顺序很像<code>partial()</code>函数。</p>

<p>在一个对象表示法中我们可能会有<code>x.a() .b()</code>。我们可以把它当成<code>x(a, b)</code>。<code>x.a()</code>函数是等待<code>b()</code>的一类<code>partial()</code>函数。我们可以认为它就像<code>x(a)(b)</code>那样。</p>

<p>这里的想法是，Python给我们提供两种选择来管理状态。我们既可以更新对象又可以创建有状态性的（在某种程度上）<code>partial()</code>函数。由于这种等价，我们可以重写<code>partial()</code>函数到一个连贯的工厂对象中。我们使得<code>rank</code>对象的设置为一个连贯的方法来返回<code>self</code>。设置<code>suit</code>对象将真实的创建<code>Card</code>实例。</p>

<p>以下是一个连贯的<code>Card</code>工厂类，有两个方法函数，必须在特定顺序中使用：</p>

<pre><code>python</code><code>class CardFactory:
    def rank(self, rank):
        self.class_, self.rank_str= {
                1: (AceCard, 'A'),
                11: (FaceCard,'J'),
                12: (FaceCard,'Q'),
                13: (FaceCard,'K'),
        }.get(rank, (NumberCard, str(rank)))
        return self
    def suit(self, suit):
        return self.class_(self.rank_str, suit)
</code></pre>

<p><code>rank()</code>方法更新构造函数的状态，<code>suit()</code>方法真实的创建了最终的<code>Card</code>对象。</p>

<p>这个工厂类可以像下面这样使用：</p>

<pre><code>python</code><code>card8 = CardFactory()
deck8 = [card8.rank(r+1).suit(s) for r in range(13) for s in (Club, Diamond, Heart, Spade)]
</code></pre>

<p>首先，我们创建一个工厂实例，然后我们使用那个实例创建<code>Card</code>实例。这并没有实质性改变<code>__init__()</code>本身在<code>Card</code>类层次结构中如何运作的。然而，它确实改变了我们客户端应用程序创建对象的方式。</p>

2015年五月4日晚上 9:39:35
关于 this 的四类用法
<h2>this</h2>

<p>在函数执行时，this 总是指向调用该函数的对象。要判断 this 的指向，其实就是判断 this 所在的函数属于谁。</p>

<p>在《javaScript语言精粹》这本书中，把 this 出现的场景分为四类，简单的说就是：</p>

<ul>
<li>有对象就指向调用对象</li>
<li>没调用对象就指向全局对象</li>
<li>用new构造就指向新对象</li>
<li>通过 apply 或 call 或 bind 来改变 this 的所指。</li>
</ul>
<h3>1) 函数有所属对象时：指向所属对象</h3>

<p>函数有所属对象时，通常通过 <code>.</code> 表达式调用，这时 <code>this</code> 自然指向所属对象。比如下面的例子：</p>

<pre><code>js</code><code>var myObject = {value: 100};
myObject.getValue = function () {
  console.log(this.value);  // 输出 100

  // 输出 { value: 100, getValue: [Function] }，
  // 其实就是 myObject 对象本身
  console.log(this);

  return this.value;
};

console.log(myObject.getValue()); // =&gt; 100
</code></pre>

<p><code>getValue()</code> 属于对象 <code>myObject</code>，并由 <code>myOjbect</code> 进行 <code>.</code> 调用，因此 <code>this</code> 指向对象 <code>myObject</code>。</p>

<h3>2) 函数没有所属对象：指向全局对象</h3>

<pre><code>js</code><code>var myObject = {value: 100};
myObject.getValue = function () {
  var foo = function () {
    console.log(this.value) // =&gt; undefined
    console.log(this);// 输出全局对象 global
  };

  foo();

  return this.value;
};

console.log(myObject.getValue()); // =&gt; 100
</code></pre>

<p>在上述代码块中，<code>foo</code> 函数虽然定义在 <code>getValue</code> 的函数体内，但实际上它既不属于 <code>getValue</code> 也不属于 <code>myObject</code>。<code>foo</code> 并没有被绑定在任何对象上，所以当调用时，它的 <code>this</code> 指针指向了全局对象 <code>global</code>。</p>

<p>据说这是个设计错误。</p>

<h3>3) 构造器中的 this：指向新对象</h3>

<p>js 中，我们通过 <code>new</code> 关键词来调用构造函数，此时 this 会绑定在该新对象上。</p>

<pre><code>js</code><code><br>var SomeClass = function(){
  this.value = 100;
}

var myCreate = new SomeClass();

console.log(myCreate.value); // 输出100
</code></pre>

<p>顺便说一句，在 js 中，构造函数、普通函数、对象方法、闭包，这四者没有明确界线。界线都在人的心中。</p>

<h3>4) apply 和 call 调用以及 bind 绑定：指向绑定的对象</h3>

<p>apply() 方法接受两个参数第一个是函数运行的作用域，另外一个是一个参数数组(arguments)。</p>

<p>call() 方法第一个参数的意义与 apply() 方法相同，只是其他的参数需要一个个列举出来。</p>

<p>简单来说，call 的方式更接近我们平时调用函数，而 apply 需要我们传递 Array 形式的数组给它。它们是可以互相转换的。</p>

<pre><code>js</code><code>var myObject = {value: 100};

var foo = function(){
  console.log(this);
};

foo(); // 全局变量 global
foo.apply(myObject); // { value: 100 }
foo.call(myObject); // { value: 100 }

var newFoo = foo.bind(myObject);
newFoo(); // { value: 100 }
</code></pre>

2015年五月4日晚上 9:09:16
alsotang commented on commit cnodejs/nodeclub@67c098202b
<!-- commit_comment -->
<span class="mega-octicon octicon-comment-discussion"></span>

<div class="time">
  <time datetime="2015-05-04T13:09:16Z" is="relative-time">May 4, 2015</time>
</div>

<div class="title">
  <a href="https://github.com/alsotang" data-ga-click="News feed, event click, Event click type:CommitCommentEvent target:actor">alsotang</a> <span>commented</span> on commit <a href="https://github.com/cnodejs/nodeclub/commit/67c098202b0de23d790ecd4486307dbe62be916b#commitcomment-11024911" data-ga-click="News feed, event click, Event click type:CommitCommentEvent target:commit-comment">cnodejs/nodeclub@67c098202b</a>
</div>

<div class="details">
  <a href="https://github.com/alsotang"><img alt="@alsotang" class="gravatar" data-user="1147375" height="30" src="https://avatars0.githubusercontent.com/u/1147375?v=3&amp;s=60" width="30" /></a>
  <div class="message markdown-body">
    <blockquote>
      <p>无论mongodb还是redis都有自动过期的策略，session 不会一直存 在 2015年5月4日 下午8:11，yanjixiong &lt;notifications@github.com&gt;写道：
</p>
    </blockquote>
  </div>
</div>

2015年五月4日晚上 7:04:20
哪位大大能帮我看下，为啥BAE里我用mongoose close了db，然后重新open就 报错了
<div class="markdown-text"><p>报错为：  name: 'MongoError’,
message: ‘only GSSAPI, PLAIN, MONGODB-X509, SCRAM-SHA-1 or MONGODB-CR is supported by authMechanism’</p>
<p>代码:var mongoose = require(‘mongoose’);
var format = require(‘util’).format;</p>
<p>if(process.env.BAE_ENV_APPID){<br>
var host =&quot;mongo.duapp.com&quot;;
var port =&quot;8908&quot;;
var username =&quot;bfc5c2ab184a479292b3fd20b012a683&quot;;
var password =&quot;d1b72bc45df94eb4b05a4ffc9f0416af&quot;;
var dbName =&quot;aJZfHIoouaDARdxxYghA&quot;;
var constr =&quot;mongodb://&quot;+ username +&quot;:&quot;+ password +&quot;@&quot;+ host +&quot;:&quot;+ port +&quot;/&quot;+ dbName;
}else{
var constr = “<a href>mongodb://localhost/ticket</a>”
var username =null;
var password =null;</p>
<pre class="prettyprint"><code>}
</code></pre><p>//constr = &quot;<a href>mongodb://localhost/ticket</a>&quot;;</p>
<p>var options = {
db: { native_parser: true },
server: {
poolSize:4,
socketOptions: {
keepAlive: 1
}
},
user: username,
pass: password
};
db = mongoose.createConnection();
var userSchema = new mongoose.Schema({
name:String,
password:String},{
collection : ‘users’
});</p>
<p>db.open(constr,options);
var userModel = db.model('users’,userSchema);</p>
<p>function User(user){
this.name = user.name;
this.password = user.password;
}
setInterval(function(){console.log(‘closing db now’);db.close();}, 1000<em>60</em>1);
setInterval(function(){console.log(‘opening db now’);db.open(constr,options,function(err) {
if(err){console.log(err);}
});}, 1010<em>60</em>1);</p>
<p>db.on('open’,function(){
console.log('connection success open’+’mongooseConnection.readyState :’+db.readyState );</p>
<pre class="prettyprint"><code>    //setTimeout(function(){console.log(&#x27;closing db now&#x27;);mongoose.disconnect();}, 1000*60*4);
});
</code></pre><p>db.on('close’,function(err){
console.log(‘closed’);</p>
<p>});</p>
</div>

2015年五月4日晚上 6:30:53
alsotang commented on commit cnodejs/nodeclub@67c098202b
<!-- commit_comment -->
<span class="mega-octicon octicon-comment-discussion"></span>

<div class="time">
  <time datetime="2015-05-04T10:30:53Z" is="relative-time">May 4, 2015</time>
</div>

<div class="title">
  <a href="https://github.com/alsotang" data-ga-click="News feed, event click, Event click type:CommitCommentEvent target:actor">alsotang</a> <span>commented</span> on commit <a href="https://github.com/cnodejs/nodeclub/commit/67c098202b0de23d790ecd4486307dbe62be916b#commitcomment-11023204" data-ga-click="News feed, event click, Event click type:CommitCommentEvent target:commit-comment">cnodejs/nodeclub@67c098202b</a>
</div>

<div class="details">
  <a href="https://github.com/alsotang"><img alt="@alsotang" class="gravatar" data-user="1147375" height="30" src="https://avatars0.githubusercontent.com/u/1147375?v=3&amp;s=60" width="30" /></a>
  <div class="message markdown-body">
    <blockquote>
      <p>yanjixiong，看这里 <a href="https://github.com/cnodejs/nodeclub/issues/421">https://github.com/cnodejs/nodeclub/issues/421</a> redis 快 2015-05-04 13:02 GMT+08:00 yanjixiong &lt;notifications@github.com&gt;:
</p>
    </blockquote>
  </div>
</div>

2015年五月4日下午 4:23:13
如何查看cluster开启多多少个之进程？
<div class="markdown-text"><p>//fork：复制一个工作进程后触发该事件。
cluster.on(‘fork’, function (worker) {
console.log( '[master] fork: worker’ + worker.id +&quot; start&quot;);
console.log( cluster.workers.length );
});
为何每次都是undefine？应该如何查看cluster开启了多少个子进程？</p>
</div>

2015年五月4日下午 4:10:51
npm 卸载的包还可以恢复吗？
<div class="markdown-text"><p>安装了一个全局包，然后直接在源码上修改了些东西，结果手贱不小心卸载（npm uninstall）了，请问还有什么方法可以恢复这个包吗？</p>
</div>

2015年五月4日下午 4:07:07
Mongoose 使用 Population 填充'关联表'数据
<p><a rel="nofollow" href="http://mongoosejs.com/index.html">Mongoose</a> 是 <a rel="nofollow" href="http://www.mongodb.org/">MongoDB</a> 的 <strong>ODM(Object Document Mapper)</strong>。</p>

<blockquote>
  <ul>
<li>什么是<strong>ODM</strong>? 其实和<strong>ORM(Object Relational Mapper)</strong>是同类型的工具。都是将数据库的数据转化为代码对象的库，使用转化后的对象可以直接对数据库的数据进行<strong><em>CRUD(增删改查)</em></strong>。</li>
  <li>
<code>MongoDB</code> 是文档型数据库(Document Database)，不是关系型数据库(Relational Database)。而<code>Mongoose</code>可以将 <strong>MongonDB</strong> 数据库存储的文档(documents)转化为 javascript 对象，然后可以直接进行数据的增删改查。</li>
  </ul>
</blockquote>



<p>因为<code>MongoDB</code>是文档型数据库，所以它没有关系型数据库[<code>joins</code>](<a rel="nofollow" href="http://zh.wikipedia.org/wiki/%E8%BF%9E%E6%8E%A5_(SQL)">http://zh.wikipedia.org/wiki/%E8%BF%9E%E6%8E%A5_(SQL)</a>(数据库的两张表通过"外键"，建立连接关系。) 特性。也就是在建立数据的关联时会比较麻烦。为了解决这个问题，<code>Mongoose</code>封装了一个<a rel="nofollow" href="http://mongoosejs.com/docs/populate.html"><code>Population</code></a>功能。使用<code>Population</code>可以实现在一个 <strong>document</strong> 中填充其他 <strong>collection(s)</strong> 的 <strong>document(s)</strong>。</p>

<p>在定义<code>Schema</code>的时候，如果设置某个 field 关联另一个<code>Schema</code>，那么在获取 document 的时候就可以使用 Population 功能通过关联<code>Schema</code>的 field 找到关联的另一个 document，并且用被关联 document 的内容替换掉原来关联字段(field)的内容。</p>

<h2>接下来分享下:<code>Query#populate</code> <code>Model#populate</code> <code>Document#populate</code>的用法</h2>

<p><strong><em>先建立三个<code>Schema</code>和<code>Model</code>:</em></strong></p>

<pre><code>javascript</code><code>var mongoose = require('mongoose');
var Schema   = mongoose.Schema;

var UserSchema = new Schema({
    name  : { type: String, unique: true },
    posts : [{ type: Schema.Types.ObjectId, ref: 'Post' }]
});
var User = mongoose.model('User', UserSchema);

var PostSchema = new Schema({
    poster   : { type: Schema.Types.ObjectId, ref: 'User' },
    comments : [{ type: Schema.Types.ObjectId, ref: 'Comment' }],
    title    : String,
    content  : String
});
var Post = mongoose.model('Post', PostSchema);

var CommentSchema = new Schema({
    post      : { type: Schema.Types.ObjectId, ref: "Post" },
    commenter : { type: Schema.Types.ObjectId, ref: 'User' },
    content   : String
});
var Comment = mongoose.model('Comment', CommentSchema);

</code></pre>

<ul>
<li>在上述的例子中，创建了三个 Models:<code>User</code>，<code>Post</code>，<code>Comment</code>。</li>
<li>
<code>User</code> 的属性 <strong><em>posts</em></strong>，对应是一个 <strong><em>ObjectId</em></strong> 的数组。<code>ref</code>表示关联<code>Post</code>(注意: 被关联的<strong><em>model</em></strong>的 type 必须是 <code>ObjectId, Number, String, 和 Buffer</code> 才有效)。</li>
<li>
<code>Post</code>的属性 <strong><em>poster</em></strong> 和 <strong><em>comments</em></strong> 分别关联<code>User</code>和<code>Comment</code>。</li>
<li>
<code>Comment</code>的属性 <strong><em>post</em></strong> 和 <strong><em>commenter</em></strong> 分别关联<code>Post</code>和<code>User</code>。</li>
<li>三个 Models 的关系:一个 user--<strong>has many</strong>--&gt;post。一个 post--<strong>has one</strong>--&gt;user，<strong>has many</strong>--&gt;comment。一个 comment--<strong>has one</strong>--&gt;post 和 user。</li>
</ul>
<p><strong><em>创建一些数据到数据库:</em></strong></p>

<pre><code>javascript</code><code>// 连接数据库
mongoose.connect('mongodb://localhost/population-test', function (err){
    if (err) throw err;
    createData();
});

function createData() {

    var userIds    = [new ObjectId, new ObjectId, new ObjectId];
    var postIds    = [new ObjectId, new ObjectId, new ObjectId];
    var commentIds = [new ObjectId, new ObjectId, new ObjectId];

    var users    = [];
    var posts    = [];
    var comments = [];

    users.push({
        _id   : userIds[0],
        name  : 'aikin',
        posts : [postIds[0]]
    });
    users.push({
        _id   : userIds[1],
        name  : 'luna',
        posts : [postIds[1]]
    });
    users.push({
        _id   : userIds[2],
        name  : 'luajin',
        posts : [postIds[2]]
    });

    posts.push({
        _id      : postIds[0],
        title    : 'post-by-aikin',
        poster   : userIds[0],
        comments : [commentIds[0]]
    });
    posts.push({
        _id      : postIds[1],
        title    : 'post-by-luna',
        poster   : userIds[1],
        comments : [commentIds[1]]
    });
    posts.push({
        _id      : postIds[2],
        title    : 'post-by-luajin',
        poster   : userIds[2],
        comments : [commentIds[2]]
    });

    comments.push({
        _id       : commentIds[0],
        content   : 'comment-by-luna',
        commenter : userIds[1],
        post      : postIds[0]
    });
    comments.push({
        _id       : commentIds[1],
        content   : 'comment-by-luajin',
        commenter : userIds[2],
        post      : postIds[1]
    });
    comments.push({
        _id       : commentIds[2],
        content   : 'comment-by-aikin',
        commenter : userIds[1],
        post      : postIds[2]
    });

    User.create(users, function(err, docs) {
        Post.create(posts, function(err, docs) {
            Comment.create(comments, function(err, docs) {
            });
        });
    });
}
</code></pre>

<p><strong><em>数据的准备就绪后，接下来就是探索<code>populate</code>方法:</em></strong></p>

<h2><a rel="nofollow" href="http://mongoosejs.com/docs/api.html#query_Query-populate">1. Query#populate</a></h2>

<p>什么Query? Query(查询)，可以快速和简单的从<strong>MongooDB</strong>查找出相应的 document(s)。 Mongoose 封装了很多查询的方法，使得对数据库的操作变得简单啦。这里分享一下<code>populate</code>方法用法。</p>

<blockquote>
  <p><strong><em>语法：</em></strong><br><strong><code>Query.populate(path, [select], [model], [match], [options])</code></strong></p>
</blockquote>

<blockquote>
  <p><strong><em>参数：</em></strong></p>
</blockquote>

<blockquote>
  <p><strong><code>path</code></strong><br>
  　　类型：<code>String</code>或<code>Object</code>。<br>
  　　<code>String</code>类型的时， 指定要填充的关联字段，要填充多个关联字段可以以空格分隔。<br>
  　　<code>Object</code>类型的时，就是把 <strong>populate</strong> 的参数封装到一个对象里。当然也可以是个数组。下面的例子中将会实现。</p>
</blockquote>

<blockquote>
  <p><strong><code>select</code></strong><br>
  　　类型：<code>Object</code>或<code>String</code>，可选，指定填充 document 中的哪些字段。<br>
  　　<code>Object</code>类型的时，格式如:<code>{name: 1, _id: 0}</code>,为<strong>0</strong>表示不填充，为<strong>1</strong>时表示填充。<br>
  　　<code>String</code>类型的时，格式如:<code>"name -_id"</code>，用空格分隔字段，在字段名前加上<code>-</code>表示不填充。详细语法介绍 <a rel="nofollow" href="http://mongoosejs.com/docs/api.html#query_Query-select">query-select</a></p>
</blockquote>

<blockquote>
  <p><strong><code>model</code></strong><br>
  　　类型：<code>Model</code>，可选，指定关联字段的 model，如果没有指定就会使用<code>Schema</code>的<code>ref</code>。</p>
</blockquote>

<blockquote>
  <p><strong><code>match</code></strong><br>
  　　类型：<code>Object</code>，可选，指定附加的查询条件。</p>
</blockquote>

<blockquote>
  <p><strong><code>options</code></strong><br>
  　　类型：<code>Object</code>，可选，指定附加的其他查询选项，如排序以及条数限制等等。</p>
</blockquote>

<ul>
<li><strong>填充<code>User</code>的<code>posts</code>字段:</strong></li>
</ul>
<pre><code>javascript</code><code>//填充所有 users 的 posts
User.find()
    .populate('posts', 'title', null, {sort: { title: -1 }})
    .exec(function(err, docs) {
        console.log(docs[0].posts[0].title); // post-by-aikin
    });

//填充 user 'luajin'的 posts
User.findOne({name: 'luajin'})
    .populate({path: 'posts', select: { title: 1 }, options: {sort: { title: -1 }}})
    .exec(function(err, doc) {
        console.log(doc.posts[0].title);  // post-by-luajin
    });

//这里的 populate 方法传入的参数形式不同，其实实现的功能是一样的，只是表示形式不一样。

</code></pre>

<ul>
<li><strong>填充<code>Post</code>的<code>poster</code>和<code>comments</code>字段:</strong></li>
</ul>
<pre><code>javascript</code><code>Post.findOne({title: 'post-by-aikin'})
    .populate('poster comments', '-_id')
    .exec(function(err, doc) {
        console.log(doc.poster.name);           // aikin
        console.log(doc.poster._id);            // undefined

        console.log(doc.comments[0].content);  // comment-by-luna
        console.log(doc.comments[0]._id);      // undefined
    });

Post.findOne({title: 'post-by-aikin'})
    .populate({path: 'poster comments', select: '-_id'})
    .exec(function(err, doc) {
        console.log(doc.poster.name);           // aikin
        console.log(doc.poster._id);            // undefined

        console.log(doc.comments[0].content);  // comment-by-luna
        console.log(doc.comments[0]._id);      // undefined
    });

//上两种填充的方式实现的功能是一样的。就是给 populate 方法的参数不同。
//这里要注意，当两个关联的字段同时在一个 path 里面时， select 必须是 document(s)
//具有的相同字段。


//如果想要给单个关联的字段指定 select，可以传入数组的参数。如下：

Post.findOne({title: 'post-by-aikin'})
    .populate(['poster', 'comments'])
    .exec(function(err, doc) {
        console.log(doc.poster.name);          // aikin
        console.log(doc.comments[0].content);  // comment-by-luna
    });

Post.findOne({title: 'post-by-aikin'})
    .populate([
        {path:'poster',   select: '-_id'},
        {path:'comments', select: '-content'}
    ])
    .exec(function(err, doc) {
        console.log(doc.poster.name);          // aikin
        console.log(doc.poster._id);           // undefined

        console.log(doc.comments[0]._id);      // 会打印出对应的 comment id
        console.log(doc.comments[0].content);  // undefined
    });
</code></pre>

<h2><a rel="nofollow" href="http://mongoosejs.com/docs/api.html#model_Model.populate">2. Model#populate</a></h2>

<p>Model(模型)，是根据定义的 Schema 编译成的抽象的构造函数。models 的实例 documents，可以在数据库中被保存和检索。数据库所有 document 的创建和检索，都通过 models 处理。</p>

<blockquote>
  <p><strong><em>语法：</em></strong><br><strong><code>Model.populate(docs, options, [cb(err,doc)])</code></strong></p>
</blockquote>

<blockquote>
  <p><strong><em>参数：</em></strong></p>
</blockquote>

<blockquote>
  <p><strong><code>docs</code></strong><br>
  　　类型：<code>Document</code>或<code>Array</code>。单个需要被填充的 doucment 或者 document 的数组。</p>
</blockquote>

<blockquote>
  <p><strong><code>options</code></strong><br>
  　　类型：<code>Object</code>。以键值对的形式表示。<br>
  　　keys：<code>path</code> <code>select</code> <code>match</code> <code>model</code> <code>options</code>，这些键对应值的类型和功能，与上述<code>Query#populate</code>方法的参数相同。</p>
</blockquote>

<blockquote>
  <p><strong><code>[cb(err,doc)]</code></strong><br>
  　　类型：<code>Function</code>，回调函数，接收两个参数，错误<code>err</code>和填充完的<code>doc(s)</code>。</p>
</blockquote>

<ul>
<li><strong>填充<code>Post</code>的<code>poster</code>和<code>comments</code>字段以及<code>comments</code>的<code>commenter</code>字段:</strong></li>
</ul>
<pre><code>javacript</code><code>Post.find({title: 'post-by-aikin'})
    .populate('poster comments')
    .exec(function(err, docs) {

        var opts = [{
            path   : 'comments.commenter',
            select : 'name',
            model  : 'User'
        }];

        Post.populate(docs, opts, function(err, populatedDocs) {
            console.log(populatedDocs[0].poster.name);                  // aikin
            console.log(populatedDocs[0].comments[0].commenter.name);  // luna
        });
    });
</code></pre>

<h2><a rel="nofollow" href="http://mongoosejs.com/docs/api.html#document_Document-populate">3. Document#populate</a></h2>

<p>Document，每个 document 都是其 Model 的一个实例，一对一的映射着 MongoDB 的 document。</p>

<blockquote>
  <p><strong><em>语法：</em></strong><br><strong><code>Document.populate([path], [callback])</code></strong></p>
</blockquote>

<blockquote>
  <p><strong><em>参数：</em></strong></p>
</blockquote>

<blockquote>
  <p><strong><code>path</code></strong><br>
  　　类型：<code>String</code>或<code>Object。与上述</code>Query#populate`方法的 <strong>path</strong> 参数相同。</p>
</blockquote>

<blockquote>
  <p><strong><code>callback</code></strong><br>
  　　类型：<code>Function</code>。回调函数，接收两个参数，错误<code>err</code>和填充完的<code>doc(s)</code>。</p>
</blockquote>

<ul>
<li><strong>填充<code>User</code>的<code>posts</code>字段:</strong></li>
</ul>
<pre><code>javascript</code><code>User.findOne({name: 'aikin'})
    .exec(function(err, doc) {

        var opts = [{
            path   : 'posts',
            select : 'title'
        }];

        doc.populate(opts, function(err, populatedDoc) {
            console.log(populatedDoc.posts[0].title);  // post-by-aikin
        });
    });
</code></pre>

<p><strong><em>博文涉及的完整例子在 <a rel="nofollow" href="https://gist.github.com/aikin/534fae3c95039b7dee09">gist</a> 上。(ps: gist 被已墙了。)</em></strong></p>

<h2>参考</h2>

<ul>
<li><a rel="nofollow" href="http://mongoosejs.com/docs/populate.html">mongoose-api-docs</a></li>
<li><a rel="nofollow" href="http://www.ruanyifeng.com/blog/2014/07/database_implementation.html">数据库的最简单实现</a></li>
<li><a rel="nofollow" href="http://my.oschina.net/calvinchen/blog/137932">Mongoose 使用之 Population</a></li>
</ul>
<blockquote>
  <p><a rel="nofollow" href="http://ulaijn.com/2014/11/02/mongoose-population/#more">原文链接</a></p>
</blockquote>

2015年五月4日下午 4:01:58
Node crypto.final() 似乎导致与 PHP mcrypt_encrypt 两方加密结果不同？
<div class="markdown-text"><p>加密演算法我使用的是 Triple DES，而以下会出现的 key，IV 我已经先行替换了。</p>
<hr>
<p>首先我使用的是 Node.js crypto 做加密。</p>
<pre class="prettyprint"><code>var secretKey  = new Buffer(&#x27;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&#x27;, &#x27;hex&#x27;), // 48 chars
    iv         = new Buffer(&#x27;bbbbbbbbbbbbbbbb&#x27;, &#x27;hex&#x27;); // 16 chars
var str        = &#x27;This string will be encrypted.&#x27;;
var cipher     = crypto.createCipheriv(&#x27;des-ede3-cbc&#x27;, secretKey, iv),
    cryptedStr = cipher.update(str, &#x27;utf8&#x27;, &#x27;base64&#x27;) + cipher.final(&#x27;base64&#x27;);
</code></pre><p>再來是协作方的系统，使用的是 PHP 的 mcrypt。</p>
<pre class="prettyprint"><code>$key    = pack(&#x27;H*&#x27;, &quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;); 
$iv     = pack(&#x27;H*&#x27;, &quot;bbbbbbbbbbbbbbbb&quot;); 
$string = &#x27;This string will be encrypted.&#x27;;
$text   = mcrypt_encrypt(MCRYPT_3DES, $key, $string, MCRYPT_MODE_CBC, $iv);
$text_base64 = base64_encode($text);
</code></pre><hr>
<p>我遇到的问题是，明明使用相同的 Key / IV、演算法以及编码方式，但结果就是会有一部分不同。</p>
<p>而观察之下，不同处却是 <code>cipher.final()</code> 所导致？</p>
<pre class="prettyprint"><code>// Node.js output.
UKBI17EIHKNM2EU48ygsjil5r58Eo1csByAIFp9GhUw=
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    Same part

// PHP output.
UKBI17EIHKNM2EU48ygsjil5r58Eo1csAY4C0JZoyco=
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    Same part
</code></pre><hr>
<p>还请教各位大侠、前辈，究竟是为什么呢？</p>
</div>

2015年五月4日下午 3:19:38
文件归档工具——category
<div class="markdown-text"><p>我有个习惯就是定期将手机里的照片拷贝到电脑上，整理归档，然后上传到网盘。</p>
<p>整理之前是这样的：</p>
<pre class="prettyprint"><code>Camera/
├── IMG_20150425_133502.jpg
├── IMG_20150426_134524.jpg
├── IMG_20150427_123602.jpg
└── IMG_20150427_221603.jpg
...
</code></pre><p>整理之后是这样的：</p>
<pre class="prettyprint"><code>Camera/
├── 2015-04-25/
│   └── IMG_20150425_133502.jpg
├── 2015-04-26/
│   └── IMG_20150426_134524.jpg
└── 2015-04-27/
    ├── IMG_20150427_123602.jpg
    └── IMG_20150427_221603.jpg
</code></pre><p>话说以前每次都是手动整理的没用过啥软件 orz… ，由于很长时间没整理手机相册积攒了很多照片，于是昨天自己写了个归档的命令行工具。。。</p>
<p>传送门：<a href="https://github.com/nswbmw/node-category">https://github.com/nswbmw/node-category</a></p>
</div>

2015年五月4日下午 2:50:28
使用Python解析nginx日志文件
<p>项目的一个需求是解析nginx的日志文件。<br>
简单的整理如下：</p>

<hr>
<h2>日志规则描述</h2>

<p>首先要明确自己的Nginx的日志格式，这里采用默认Nginx日志格式：</p>

<pre><code> log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                   '$status $body_bytes_sent "$http_referer" '
                   '"$http_user_agent" "$http_x_forwarded_for"';
</code></pre>

<p>其中一条真实记录样例如下：</p>

<pre><code>172.22.8.207 - - [16/Dec/2014:17:57:35 +0800] "GET /report?DOmjjuS6keWJp+WculSQAgdUkAIPODExMzAwMDJDN0FC HTTP/1.1" 200 0 "-" "XXXXXXX/1.0.16; iPhone/iOS 8.1.2; ; 8DA77E2F91D0"
</code></pre>

<p>其中，客户端型号信息用<code>XXXXXXX</code>代替。</p>

<p>项目中已经按照业务规则对Nginx日志文件进行了处理命名规则如下：</p>

<pre><code>ID-ID-YYMMDD-hhmmss
</code></pre>

<p>并且所有的日志文件存放在统一路径下。</p>

<h2>解决思路</h2>

<hr>
<h3>获取所有日志文件<code>path</code>
</h3>

<p>这里使用Python的<code>glob</code>模块来获取日志文件path</p>

<pre><code>import glob


def readfile(path):
    return glob.glob(path + '*-*-*-*')
</code></pre>

<h3>获取日志文件中每一行的内容</h3>

<p>使用Python的<code>linecache</code>模块来获取文件行的内容</p>

<pre><code>import linecache


def readline(path):
    return linecache.getlines(path)
</code></pre>

<p>注意：linecache模块使用了缓存，所以存在以下问题：</p>

<ol>
<li><p>在使用linecache模块读取文件内容以后，如果文件发生了变化，那么需要使用<code>linecache.updatecache(filename)</code>来更新缓存，以获取最新变化。</p></li>
<li><p>linecache模块使用缓存，所以会耗费内存，耗费量与要解析的文件相关。最好在使用完毕后执行<code>linecache.clearcache()</code>清空一下缓存。</p></li>
</ol>
<p>当然，作为优化，这里可以利用<code>生成器</code>来进行优化。暂且按下不表。</p>

<h3>处理日志条目</h3>

<p>一条日志信息就是一个特定格式的字符串，因此使用<code>正则表达式</code>来解析，这里使用Python的<code>re</code>模块。<br>
下面，一条一条建立规则：</p>

<h4>规则</h4>

<pre><code>    ip = r"?P&lt;ip&gt;[\d.]*"
    date = r"?P&lt;date&gt;\d+"
    month = r"?P&lt;month&gt;\w+"
    year = r"?P&lt;year&gt;\d+"
    log_time = r"?P&lt;time&gt;\S+"
    method = r"?P&lt;method&gt;\S+"
    request = r"?P&lt;request&gt;\S+"
    status = r"?P&lt;status&gt;\d+"
    bodyBytesSent = r"?P&lt;bodyBytesSent&gt;\d+"
    refer = r"""?P&lt;refer&gt;
             [^\"]*
             """
    userAgent=r"""?P&lt;userAgent&gt;
                .*
               """
</code></pre>

<h3>解析</h3>

<pre><code>p = re.compile(r"(%s)\ -\ -\ \[(%s)/(%s)/(%s)\:(%s)\ [\S]+\]\ \"(%s)?[\s]?(%s)?.*?\"\ (%s)\ (%s)\ \"(%s)\"\ \"(%s).*?\"" %( ip, date, month, year, log_time, method, request, status, bodyBytesSent, refer, userAgent ), re.VERBOSE)
m = re.findall(p, logline)
</code></pre>

<p>这样，就可以得到日志条目中各个要素的原始数据。</p>

<hr>
<h3>格式及内容转化</h3>

<p>得到日志原始数据之后，需要根据业务要求，对原始数据进行格式及内容转化。<br>
这里需要处理的内容包括：时间，request，userAgent</p>

<h4>时间格式转化</h4>

<p>在日志信息原始数据中存在<code>Dec</code>这样的信息，利用Python的<code>time</code>模块可以方便的进行解析</p>

<pre><code>import time


def parsetime(date, month, year, log_time):
    time_str = '%s%s%s %s' %(year, month, date, log_time)
    return time.strptime(time_str, '%Y%b%d %H:%M:%S')
</code></pre>

<h4>解析request</h4>

<p>在日志信息原始数据中得到的<code>request</code>的内容格式为：</p>

<pre><code>/report?XXXXXX
</code></pre>

<p>这里只需要根据协议取出<code>XXXXXX</code>即可。<br>
这里仍然采用Python的<code>re</code>模块</p>

<pre><code>import re


def parserequest(rqst):
    param = r"?P&lt;param&gt;.*"
    p = re.compile(r"/report\?(%s)" %param, re.VERBOSE)
    return re.findall(p, rqst)
</code></pre>

<p>接下来需要根据业务协议解析参数内容。这里需要先利用<code>base64</code>模块解码，然后再利用<code>struct</code>模块解构内容：</p>

<pre><code>import struct
import base64


def parseparam(param):
    decodeinfo = base64.b64decode(param)
    s = struct.Struct('!x' + bytes(len(decodeinfo) - (1 + 4 + 4 + 12)) + 'xii12x')
    return s.unpack(decodeinfo)
</code></pre>

<h4>解析userAgent</h4>

<p>在日志信息原始数据中userAgent数据的格式为：</p>

<pre><code>XXX; XXX; XXX; XXX
</code></pre>

<p>根据业务要求，只需要取出最后一项即可。<br>
这里采用<code>re</code>模块来解析。</p>

<pre><code>import re


def parseuseragent(useragent):
    agent = r"?P&lt;agent&gt;.*"
    p = re.compile(r".*;.*;.*;(%s)" %agent, re.VERBOSE)
    return re.findall(p, useragent)
</code></pre>

<hr>
<p>至此，nginx日志文件解析基本完成。<br>
剩下的工作就是根据业务需要，对获得的基本信息进行处理。<br>
（完）</p>

2015年五月4日下午 12:36:05
客户-服务器程序设计方法
<h1>客户-服务器程序设计方法</h1>

<p>《unix网络编程》第一卷中将客户服务器程序设计方法讲得透彻，这篇文章将其中编码的细节略去，通过伪代码的形式展现，主要介绍各种方法的思想；</p>

<p>示例是一个经典的TCP回射程序：<br>
客户端发起连接请求，连接后发送一串数据；收到服务端的数据后输出到终端；<br>
服务端收到客户端的数据后原样回写给客户端；</p>

<p>客户端伪代码：</p>

<pre><code>sockfd = socket(AF_INET,SOCK_STREAM,0);
//与服务端建立连接
connect(sockfd);
//连接建立后从终端读入数据并发送到服务端；
//从服务端收到数据后回写到终端
while(fgets(sendline,MAXLINE,fileHandler)!= NULL){
    writen(sockfd,sendline,strlen(sendline));
    if(readline(sockfd,recvline,MAXLINE) == 0){
        cout &lt;&lt; "recive over!";
    }
    fputs(recvline,stdout);
}
</code></pre>

<p>下面介绍服务端程序处理多个客户请求的开发范式；</p>

<h2>多进程处理</h2>

<p>对于多个客户请求，服务器端采用fork的方式创建新进程来处理；</p>

<p>处理流程：<br>
1. 主进程绑定ip端口后，使用accept()等待新客户的请求；<br>
2. 每一个新的用户请求到来，都创建一个新的子进程来处理具体的客户请求；<br>
3. 子进程处理完用户请求，结束本进程；</p>

<p>服务端伪代码：</p>

<pre><code>listenFd = socket(AF_INET,SOCK_STREAM,0);
bind(listenFd,addR);
listen(listenFD);
while(true){
    //服务器端在这里阻塞等待新客户连接
    connfd = accept(listenfd); 
    if( fork() ==0){//子进程
        close(listenfd);
        while(n=read(connfd,buf,MAXLINE)&gt;0){
            writen(connfd,buf);
        }
    }
    close(connfd);
}
</code></pre>

<p>这种方法开发简单，但对操作系统而言，进程是一种昂贵的资源，对于每个新客户请求都使用一个进程处理，开销较大；<br>
对于客户请求数不多的应用适用这种方法；</p>

<h2>预先分配进程池，accept无上锁保护</h2>

<p>上一种方法中，每来一个客户都创建一个进程处理请求，完毕后再释放；<br>
不间断的创建和结束进程浪费系统资源；<br>
使用进程池预先分配进程，通过进程复用，减少进程重复创建带来的系统消耗和时间等待；</p>

<p>优点：消除新客户请求到达来创建进程的开销；<br>
缺点：需要预先估算客户请求的多少（确定进程池的大小）</p>

<p>源自Berkeley内核的系统，有以下特性：<br>
派生的所有子进程各自调用accep()监听同一个套接字，在没有用户请求时都进入睡眠；<br>
当有新客户请求到来时，所有的客户都被唤醒；内核从中选择一个进程处理请求，剩余的进程再次转入睡眠（回到进程池）；</p>

<p>利用这个特性可以由操作系统来控制进程的分配；<br>
内核调度算法会把各个连接请求均匀的分散到各个进程中；</p>

<p>处理流程：<br>
1. 主进程预先分配进程池，所有子进程阻塞在accept()调用上；<br>
2. 新用户请求到来，操作系统唤醒所有的阻塞在accpet上的进程，从其中选择一个建立连接；<br>
3. 被选中的子进程处理用户请求，其它子进程回到睡眠；<br>
4. 子进程处理完毕，再次阻塞在accept上；</p>

<p>服务端伪代码：</p>

<pre><code>listenFd = socket(AF_INET,SOCK_STREAM,0);
bind(listenFd,addR);
listen(listenFD);
for(int i = 0;i&lt; children;i++){
    if(fork() == 0){//子进程
        while(true){
            //所有子进程监听同一个套接字，等待用户请求
            int connfd = accept(listenfd);
            close(listenfd);
            //连接建立后处理用户请求，完毕后关闭连接
            while(n=read(connfd,buf,MAXLINE)&gt;0){
                writen(connfd,buf);
            }
            close(connfd);
        }
    }
}
</code></pre>

<p><strong>如何从进程池中取出进程？</strong><br>
所有的进程都通过accept()阻塞等待，等连接请求到来后，由内核从所有等待的进程中选择一个进程处理；</p>

<p><strong>处理完的进程，如何放回到池子中？</strong><br>
子进程处理完客户请求后，通过无限循环，再次阻塞在accpet()上等待新的连接请求；</p>

<p><strong>注意：</strong> 多个进程accept()阻塞会产生“惊群问题”：尽管只有一个进程将获得连接，但是所有的进程都被唤醒；这种每次有一个连接准备好却唤醒太多进程的做法会导致性能受损；</p>

<h2>预先分配进程池，accept上锁（文件锁、线程锁）</h2>

<p>上述不上锁的实现存在移植性的问题（只能在源自Berkeley的内核系统上）和惊群问题，<br>
更为通用的做法是对accept上锁；即避免让多个进程阻塞在accpet调用上，而是都阻塞在获取锁的函数中；</p>

<p>服务端伪代码：</p>

<pre><code>listenFd = socket(AF_INET,SOCK_STREAM,0);
bind(listenFd,addR);
listen(listenFD);
for(int i = 0;i&lt; children;i++){
    if(fork() == 0){
        while(true){
            my_lock_wait();//获取锁
            int connfd = accept(listenfd);
            my_lock_release();//释放锁
            close(listenfd);
            while(n=read(connfd,buf,MAXLINE)&gt;0){
                writen(connfd,buf);
            }
            close(connfd);
        }
    }
}
</code></pre>

<p>上锁可以使用文件上锁，线程上锁；<br>
- 文件上锁的方式可移植到所有的操作系统，但其涉及到文件系统操作，可能比较耗时；<br>
- 线程上锁的方式不仅适用不同线程之间的上锁，也适用于不同进程间的上锁；</p>

<p>关于上锁的编码细节详见《网络编程》第30章；</p>

<h2>预先分配进程池，传递描述符；</h2>

<p>与上面的每个进程各自accept接收监听请求不同，这个方法是在父进程中统一接收accpet()用户请求，在连接建立后，将连接描述符传递给子进程；</p>

<p>处理流程：<br>
1. 主进程阻塞在accpet上等待用户请求，所有子进程不断轮询探查是否有可用的描述符；<br>
2. 有新用户请求到来，主进程accpet建立连接后，从进程池中取出一个进程，通过字节流管道将连接描述符传递给子进程；<br>
3. 子进程收到连接描述符，处理用户请求，处理完成后向父进程发送一个字节的内容（无实际意义），告知父进程我任务已完成；<br>
4. 父进程收到子进程的单字节数据，将子进程放回到进程池；</p>

<p>服务端伪代码：</p>

<pre><code>listenFd = socket(AF_INET,SOCK_STREAM,0);
bind(listenFd,addR);
listen(listenFD);
//预先建立子进程池
for(int i = 0;i&lt; children;i++){
    //使用Unix域套接字创建一个字节流管道，用来传递描述符
    socketpair(AF_LOCAL,SOCK_STREAM,0,sockfd);
    if(fork() == 0){//预先创建子进程
        //子进程字节流到父进程
        dup2(sockfd[1],STDERR_FILENO);
        close(listenfd);
        while(true){
            //收到连接描述符
            if(read_fd(STDERR_FILENO,&amp;connfd) ==0){; 
                continue;
            }
            while(n=read(connfd,buf,MAXLINE)&gt;0){ //处理用户请求
                writen(connfd,buf);
            }
            close(connfd);
            //通知父进程处理完毕，本进程可以回到进程池
            write(STDERR_FILENO,"",1);
        }
    }
}

while(true){
    //监听listen套接字描述符和所有子进程的描述符
    select(maxfd+1,&amp;rset,NULL,NULL,NULL);
    if(FD_ISSET(listenfd,&amp;rset){//有客户连接请求
        connfd = accept(listenfd);//接收客户连接
        //从进程池中找到一个空闲的子进程
        for(int i = 0 ;i &lt; children;i++){
            if(child_status[i] == 0)
                break;
        }
        child_status[i] = 1;//子进程从进程池中分配出去
        write_fd(childfd[i],connfd);//将描述符传递到子进程中
        close(connfd);
    }
    //检查子进程的描述符，有数据，表明已经子进程请求已处理完成，回收到进程池
    for(int i = 0 ;i &lt; children;i++){
        if(FD_ISSET(childfd[i],&amp;rset)){
            if(read(childfd[i])&gt;0){
                child_status[i] = 0;
            }
        }
    }
}
</code></pre>

<h2>多线程处理</h2>

<p>为每个用户创建一个线程，这种方法比为每个用户创建一个进程要快出许多倍；</p>

<p>处理流程：<br>
1. 主线程阻塞在accpet上等待用请求；<br>
2. 有新用户请求时，主线程建立连接，然后创建一个新的线程，将连接描述符传递过去；<br>
3. 子线程处理用户请求，完毕后线程结束；</p>

<p>服务端伪代码：</p>

<pre><code>listenFd = socket(AF_INET,SOCK_STREAM,0);
bind(listenFd,addR);
listen(listenFD);
while(true){
    connfd = accept(listenfd);
        //连接建立后，创建新线程处理具体的用户请求
    pthread_create(&amp;tid,NULL,&amp;do_function,(void*)connfd);
    close(connfd);
}

--------------------
//具体的用户请求处理函数（子线程主体）
void * do_function(void * connfd){
    pthread_detach(pthread_self());
    while(n=read(connfd,buf,MAXLINE)&gt;0){
        writen(connfd,buf);
    close((int)connfd);
}
</code></pre>

<h2>预先创建线程池，每个线程各自accept</h2>

<p>处理流程：<br>
1. 主线程预先创建线程池，第一个创建的子线程获取到锁，阻塞在accept()上，其它子线程阻塞在线程锁上；<br>
2. 用户请求到来，第一个子线程建立连接后释放锁，然后处理用户请求；完成后进入线程池，等待获取锁；<br>
3. 第一个子线程释放锁之后，线程池中等待的线程有一个会获取到锁，阻塞在accept()等待用户请求；</p>

<pre><code>listenFd = socket(AF_INET,SOCK_STREAM,0);
bind(listenFd,addR);
listen(listenFD);
//预先创建线程池，将监听描述符传给每个新创建的线程
for(int i = 0 ;i &lt;threadnum;i++){
    pthread_create(&amp;tid[i],NULL,&amp;thread_function,(void*)connfd);
}

--------------------
//具体的用户请求处理
//通过锁保证任何时刻只有一个线程阻塞在accept上等待新用户的到来；其它的线程都
//在等锁；
void * thread_function(void * connfd){
    while(true){
        pthread_mutex_lock(&amp;mlock); // 线程上锁
        connfd = accept(listenfd);
        pthread_mutex_unlock(&amp;mlock);//线程解锁
        while(n=read(connfd,buf,MAXLINE)&gt;0){
            writen(connfd,buf);
        close(connfd);
    }
}
</code></pre>

<p>使用源自Berkeley的内核的Unix系统时，我们不必为调用accept而上锁，<br>
去掉上锁的两个步骤后，我们发现没有上锁的用户时间减少（因为上锁是在用户空间中执行的线程函数完成的)，而系统时间却增加很多（每一个accept到达，所有的线程都变唤醒，引发内核的惊群问题，这个是在线程内核空间中完成的）;<br>
而我们的线程都需要互斥，让内核执行派遣还不让自己通过上锁来得快；</p>

<p>这里没有必要使用文件上锁，因为单个进程中的多个线程，总是可以通过线程互斥锁来达到同样目的；（文件锁更慢）</p>

<h2>　预先创建线程池，主线程accept后传递描述符</h2>

<p>处理流程：</p>

<ol>
<li>主线程预先创建线程池，线程池中所有的线程都通过调用pthread_cond_wait()而处于睡眠状态（由于有锁的保证，是依次进入睡眠，而不会发生同时调用pthread_cond_wait引发竞争）</li>
<li>主线程阻塞在acppet调用上等待用户请求；</li>
<li>用户请求到来，主线程accpet建立建立，将连接句柄放入约定位置后，发送pthread_cond_signal激活一个等待该条件的线程；</li>
<li>线程激活后从约定位置取出连接句柄处理用户请求；完毕后再次进入睡眠（回到线程池）；</li>
</ol>
<p>激活条件等待的方式有两种：pthread_cond_signal()激活一个等待该条件的线程，存在多个等待线程时按入队顺序激活其中一个；而pthread_cond_broadcast()则激活所有等待线程。</p>

<p>注：一般应用中条件变量需要和互斥锁一同使用；<br>
在调用pthread_cond_wait()前必须由本线程加锁（pthread_mutex_lock()），而在更新条件等待队列以前，mutex保持锁定状态，并在线程挂起进入等待前解锁。在条件满足从而离开pthread_cond_wait()之前，mutex将被重新加锁，以与进入pthread_cond_wait()前的加锁动作对应。</p>

<p>服务端伪代码：</p>

<pre><code>listenFd = socket(AF_INET,SOCK_STREAM,0);
bind(listenFd,addR);
listen(listenFD);
for(int i = 0 ;i &lt;threadnum;i++){
    pthread_create(&amp;tid[i],NULL,&amp;thread_function,(void*)connfd);
}
while(true){
    connfd = accept(listenfd);
    pthread_mutex_lock(&amp;mlock); // 线程上锁
    childfd[iput] = connfd;//将描述符的句柄放到数组中传给获取到锁的线程；
    if(++iput == MAX_THREAD_NUM)
        iput= 0;
    if(iput == iget)
        err_quit("thread num not enuough!");
    pthread_cond_signal(&amp;clifd_cond);//发信号，唤醒一个睡眠线程（轮询唤醒其中的一个）
    pthread_mutex_unlock(&amp;mlock);//线程解锁
}

--------------------
void * thread_function(void * connfd){
    while(true){
        pthread_mutex_lock(&amp;mlock); // 线程上锁
        //当无没有收到连接句柄时，睡眠在条件变量上，并释放mlock锁
        //满足条件被唤醒后，重新加mlock锁
        while(iget == iput)
            pthread_cond_wait(&amp;clifd_cond,&amp;mlock);
        connfd = childfd[iget];
        if(++iget == MAX_THREAD_NUM)
            iget = 0;
        pthread_mutex_unlock(&amp;mlock);//线程解锁
        //处理用户请求
        while(n=read(connfd,buf,MAXLINE)&gt;0){
            writen(connfd,buf);
        close(connfd);
    }
}
</code></pre>

<p>测试表明这个版本的服务器要慢于每个线程各自accpet的版本，原因在于这个版本同时需要互斥锁和条件变量，而上一个版本只需要互斥锁；</p>

<p><strong>线程描述符的传递和进程描述符的传递的区别？</strong><br>
在一个进程中打开的描述符对该进程中的所有线程都是可见的，引用计数也就是1；<br>
所有线程访问这个描述符都只需要通过一个描述符的值（整型）访问；<br>
而进程间的描述符传递，传递的是描述符的引用；（好比一个文件被2个进程打开，相应的这个文件的描述符引用计数增加2）；</p>

<h2>总结</h2>

<ul>
<li>当系统负载较轻时，每个用户请求现场派生一个子进程为之服务的传统并发服务器模型就足够了；</li>
<li>相比传统的每个客户fork一次的方式，预先创建一个子进程池或线程池能够把进程控制cpu时间降低10倍以上；当然，程序会相应复杂一些，需要监视子进程个数，随着客户用户数的动态变化而增加或减少进程池；</li>
<li>让所有子进程或线程自行调用accept通常比让父进程或主线程独自调用accpet并发描述符传递给子进程或线程要简单和快速；</li>
<li>使用线程通常要快于使用进程；</li>
</ul>
<h2>参考资料</h2>

<p>《unix网络编程》第一卷 套接字联网API</p>

<p>Posted by: 大CC<br>
博客：<a rel="nofollow" href="http://blog.me115.com">blog.me115.com</a><br>
微博：<a rel="nofollow" href="http://weibo.com/bigcc115">新浪微博</a></p>

2015年五月4日下午 12:35:27
提交自己的包到bower、npm中
<p><a rel="nofollow" href="http://jslite.io/2015/05/03/%E6%8F%90%E4%BA%A4%E8%87%AA%E5%B7%B1%E5%8C%85%E5%88%B0bower%E3%80%81npm%E4%B8%AD/">转载地址</a></p>

<h1>bower</h1>

<p>Bower 是 twitter 推出的一款包管理工具，基于nodejs的模块化思想，把功能分散到各个模块中，让模块和模块之间存在联系，通过 Bower 来管理模块间的这种联系。</p>

<p><a rel="nofollow" href="http://bower.io/">bower官网</a></p>

<h2>安装Bower</h2>

<p>一旦你已经安装了上面所说的所有必要文件，键入以下命令安装Bower：</p>

<pre><code>$ npm install -g bower
</code></pre>

<p>这行命令是Bower的全局安装，-g 操作表示全局。</p>

<h2>使用bower</h2>

<ol>
<li>直接下载 git 库: <code>bower install git://github.com/JSLite/JSLite.git</code>  </li>
<li>github别名自动解析git库: <code>bower install JSLite/JSLite</code>  </li>
<li>下载线上的任意文件: <code>bower install http://foo.com/jquery.awesome-plugin.js</code>  </li>
<li>下载本地库: <code>bower install ./repos/jquery</code>
</li>
</ol>
<h2>常用命令</h2>

<p><code>$ bower install jquery --save</code> 添加依赖并更新bower.json文件<br><code>$ bower cache clean</code> 安装失败清除缓存<br><code>$ bower install storejs</code> 安装storejs<br><code>$ bower uninstall storejs</code> 卸载storejs</p>

<h2>注册</h2>

<h3>添加配置文件</h3>

<p>bower.json文件的使用可以让包的安装更容易，你可以在应用程序的根目录下创建一个名为 <code>bower.json</code> 的文件，并定义它的依赖关系。使用<code>bower init</code> 命令来创建<code>bower.json</code>文件：</p>

<pre><code>$ bower init
? name: store.js
? version: 1.0.1
? description: "本地存储localstorage的封装，提供简单的AIP"
? authors: (kenny.wang &lt;wowohoo@qq.co&gt;)
? license: MIT
? homepage:
? set currently installed components as dependencies?: Yes
? add commonly ignored files to ignore list?: Yes
? would you like to mark this package as private which prevents it from being accidentally publis? would you like to mark this package as private which prevents it from being accidentally published to the registry?: No

{
  name: 'store.js',
  main: 'store.js',
  version: '1.0.1',
  authors: [
    '(kenny.wang &lt;wowohoo@qq.co&gt;)'
  ],
  description: '"本地存储localstorage的封装，提供简单的AIP"',
  moduleType: [
    'amd',
    'node'
  ],
  keywords: [
    'storejs'
  ],
  license: 'MIT',
  ignore: [
    '**/.*',
    'node_modules',
    'bower_components',
    'test',
    'tests'
  ]
}

? Looks good?: Yes
</code></pre>

<h3>注册自己的包</h3>

<p>可以注册自己的包，这样其他人也可以使用了，这个操作只是在服务器上保存了一个隐射，服务器本身不托管代码。</p>

<pre><code>bower register storejs git://github.com/jaywcjlove/store.js.git
</code></pre>

<h1>npm</h1>

<p>npm全称Node Package Manager，是node.js的模块依赖管理工具。使用github管理NPM包的代码，并定期提交至NPM服务器；<br><a rel="nofollow" href="https://www.npmjs.com/">npm官网</a></p>

<h2>提交自己开发的NPM包</h2>

<h3>创建package.json文件</h3>

<p>package.json文件的使用可以让包的安装更容易，你可以在应用程序的根目录下创建一个名为 <code>package.json</code> 的文件，并定义它的依赖关系。使用<code>npm init</code> 命令来创建<code>package.json</code>文件：</p>

<pre><code>$ npm init
This utility will walk you through creating a package.json file.
It only covers the most common items, and tries to guess sane defaults.

See `npm help json` for definitive documentation on these fields
and exactly what they do.

Use `npm install &lt;pkg&gt; --save` afterwards to install a package and
save it as a dependency in the package.json file.

Press ^C at any time to quit.
name: (store.js)
version: (1.0.0)
description: Local storage localstorage package provides a simple API
entry point: (store.js)
test command: store.js
git repository: (https://github.com/jaywcjlove/store.js.git)
keywords: store.js
author: (kenny.wang &lt;wowohoo@qq.co&gt;)
license: (ISC) MIT
About to write to /Applications/XAMPP/xamppfiles/htdocs/git/github.com/myJS/store.js/package.json:

{
  "name": "store.js",
  "version": "1.0.0",
  "description": "Local storage localstorage package provides a simple API",
  "main": "store.js",
  "scripts": {
    "test": "store.js"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/jaywcjlove/store.js.git"
  },
  "keywords": [
    "store.js"
  ],
  "author": " &lt;wowohoo@qq.co&gt; (kenny.wang &lt;wowohoo@qq.co&gt;)",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/jaywcjlove/store.js/issues"
  },
  "homepage": "https://github.com/jaywcjlove/store.js"
}


Is this ok? (yes) yes
</code></pre>

<h2>发布到线上</h2>

<h3>添加用户</h3>

<p>按照提示输入用户名，密码和邮箱</p>

<pre><code>npm adduser
</code></pre>

<h3>登陆用户</h3>

<p>按照提示输入用户名，密码和邮箱</p>

<pre><code>npm adduser
</code></pre>

<h3>发布</h3>

<pre><code>npm publish
</code></pre>

<p>如果不带参数，则会在当前目录下查找package.json文件，按照该文件描述信息发布；<br>
如果指定目录，就会在指定目录下查找package.json文件<br>
测试是否发布成功，在官网搜索一下<a rel="nofollow" href="https://www.npmjs.com/">www.npmjs.com</a></p>

<p>注： <code>package.json</code> 中的<code>name</code>不要又特殊字符哦</p>

<h4>版本更新</h4>

<p>修改package.json里的版本号，重新npm publish</p>

<h4>取消发布</h4>

<pre><code>npm unpublish
</code></pre>

<h2>其它命令</h2>

<p><code>npm install storejs</code>  下载使用<br><code>npm config set registry https://registry.npm.taobao.org</code>  更换镜像地址<br><code>npm config get registry</code>  获取镜像地址<br><code>npm dist-tag ls jslite</code>  查看当前版本<br><code>npm dedupe</code> 尽量压平依赖树</p>

<h2>国内优秀npm镜像</h2>

<p>由于npm的源在国外，所以国内用户使用起来各种不方便。<br><a rel="nofollow" href="http://segmentfault.com/a/1190000000491162">利用kappa搭建私有NPM仓库</a></p>

<h3>淘宝npm镜像</h3>

<ol>
<li>搜索地址：<a rel="nofollow" href="http://npm.taobao.org/">http://npm.taobao.org/</a>
</li>
<li>registry地址：<a rel="nofollow" href="http://registry.npm.taobao.org/">http://registry.npm.taobao.org/</a>
</li>
</ol>
<h3>cnpmjs镜像</h3>

<ol>
<li>搜索地址：<a rel="nofollow" href="http://cnpmjs.org/">http://cnpmjs.org/</a>
</li>
<li>registry地址：<a rel="nofollow" href="http://r.cnpmjs.org/">http://r.cnpmjs.org/</a>
</li>
</ol>
<h3>临时使用</h3>

<pre><code>npm --registry https://registry.npm.taobao.org install express
</code></pre>

<h3>持久使用</h3>

<pre><code>npm config set registry https://registry.npm.taobao.org
// 配置后可通过下面方式来验证是否成功
npm config get registry
// 或
npm info express
</code></pre>

<h3>通过cnpm使用</h3>

<pre><code>npm install -g cnpm --registry=https://registry.npm.taobao.org

// 使用
cnpm install expresstall express
</code></pre>

<h1>spmjs</h1>

<p><a rel="nofollow" href="http://spmjs.io">spmjs</a></p>

<p>据说已经不更新了，日后如果有研究再补充！</p>

2015年五月4日中午 12:11:31
【北京朝外·日坛国际公寓】急招web前端一枚，快到碗里来，发简历至vivian.sheng@123lian.com
<div class="markdown-text"><p>我们的创始团队来自PwC，360等公司，在做的是帮助大家找人一起来玩体育运动的app - 找炼运动。我们的CEO是连续创业者，之前已经做过一家不大不小的公司。我们的主程去年才从美国跑到北京，因此整天挂在嘴上的都是一些很有逼格的新技术，什么React啊，Docker啊，Ansible啊。我们还有“需求一锤子敲定，不用天天改来改去的”产品经理，和她一起工作，保证是件身心愉悦的乐事。</p>
<p>我们的主程是Pivotal Labs的脑残粉，所以我们会和你：pair programming，这是我们所知对工程师来说提升很大的一种编程方法，对一个好的学习者来说，近距离观察别的程序员如何写测试，在代码中找到bug或者加新功能，是非常有效的学习过程。如果你是更资深的工程师，那就让我们从你那里学点东西吧：）当然，这过程中大屏幕的Mac是少不了的。</p>
<p>我们的办公室在朝阳门外，可以直接俯瞰日坛公园，好风景，工作也会有好心情。</p>
<p>我们需要你：
与设计师/产品经理/后端工程师沟通，完成微信和Web端应用的功能设计、开发和实现
与后端开发人员一起研讨技术实现方案，制定服务接口</p>
<p>我们的要求：
愿意在创业公司工作，有创造的意愿和热情
接触过Angular.js/React.js/Ember.js/Backbone.js等主流客户端框架中的一种
有良好的编码习惯</p>
<p>加分项：
熟悉移动端网站开发，了解兼容不同浏览器的最优前端解决方案
接触过任何一门后端语言（Node.js/Ruby/Python/PHP等）
有前端代码优化经验</p>
<p>我们的面试过程：
没有算法题，我们会和你一起编程，解决一个小问题。</p>
</div>

2015年五月4日上午 10:48:21
北京海淀【功夫熊】-Node开发者（移动互联网O2O，弹性工作，扁平化管理，战斗力爆表~）
<div class="markdown-text"><p>Node开发工程师：
主要工作：基于Node的产品研发
岗位职责：
1 参与讨论开发需求
2 负责手机web端和产品后台的研发
岗位需求：
1 熟悉Node，熟悉Mongodb
2 熟悉Html5，能够完成完整的web应用
3 学习能力强，有强烈的工作责任心，具有一定的沟通及协调能力</p>
<p>高级Node开发工程师：
主要工作：基于Node的产品研发
岗位职责：
1 参与讨论开发需求
2 负责系统后端全部体系开发
3 负责后台REST API设计及mongodb的结构设计
4 负责复杂数据的mongodb存储格式设计和算法及性能优化
岗位需求：
1 一年及以上的Node开发工作经验
2 知识体系全面，熟悉主流前后端技术，有复杂大型后端系统的开发经验
3 具备Express、async、underscore等框架的使用经验，熟悉HTTP，TCP/IP网络协议
4 有Restful API开发和NoSQL项目开发经验
5 学习能力强，有强烈的工作责任心，具有一定的沟通及协调能力</p>
<p>加分：
1 有高并发Web项目后端开发和海量数据处理经验
2 有敏捷或流行软件开发流程的经验</p>
<p>PS：O2O全新领域，百度系研发团队，战斗力爆表，弹性工作、无限量零食~~</p>
<p>公司主页：<a href="http://www.gfxiong.com">www.gfxiong.com</a>
公司简介：
功夫熊——上门推拿第一大；
O2O上门推拿互联网平台，为都市人提供专业便捷的上门服务；
推拿师全部具有5年以上工作经验，有的从迪拜阿联酋回来的，有的从中医院出来；
通过微信平台（gfxiong）即可下单预约推拿师。
2014年10月上线，100天做到行业第一，光顾过央视、东方卫视、教育电视台、台湾中天卫视等各种TV，现北京上海均已开通。</p>
<p>附上功夫熊的服务宣传链接：
<a href="http://card.maka.im/mview/viewer.html?id=AQUX7YMZ&amp;from=timeline&amp;isappinstalled=0">http://card.maka.im/mview/viewer.html?id=AQUX7YMZ&amp;from=timeline&amp;isappinstalled=0</a></p>
<p>请有意向者投递简历至邮箱：<a href="mailto:hr@gfxiong.com">hr@gfxiong.com</a>
邮件名称：姓名-Node-Cnode社区</p>
</div>

2015年五月4日上午 9:41:52
Node.js 服务器提升CPU个数和提升RAM哪个对性能的提升影响大？
<div class="markdown-text"><p>我有个疑惑。。Node.js是单线程的，意味着一个进程就只能有一个线程，也就意味着CPU一个核只能处理一个线程对吧？（如果说错了求指正。。）</p>
<p>所以说从单核CPU升级到4核CPU，意味着本来同一时刻只能处理一个用户请求变成可以同时处理4个用户同时的请求。所以性能是提升了4倍。</p>
<p>如果提升RAM，相当于提升了单个进程的处理速度，其实一样能大幅提升性能。</p>
<p>想问问大家都用什么样的server？ AWS上自己配么？我建一个供企业内部使用的dashboard website，外加一些web services，我打算买这个服务：
<a href="https://www.digitalocean.com/pricing/">https://www.digitalocean.com/pricing/</a>
4GBMemory
2 CoreProcessor
60GBSSD Disk
4TBTransfer</p>
<p>大神们有什么见解么？</p>
</div>

2015年五月4日上午 9:38:38
关于socket.io的问题
<div class="markdown-text"><p>今天在看node.js实战（吴海星 译）的时候，里面有段代码
<code>io.sockets.clients(room)</code>
这是什么意思？我在官方文档里也没找着<code>.clients</code>
谁能帮我解释一下啊？</p>
</div>

2015年五月4日早上 7:56:44
【译】PHP:40+开发工具推荐
<p>PHP是为Web开发设计的服务器脚本语言，但也是一种通用的编程语言。超过2.4亿个索引域使用PHP，包括很多重要的网站，例如Facebook、Digg和WordPress。和其它脚本语言相比，例如Python和Ruby，Web开发者有很多不错的理由皮偏爱PHP。<br>
对于PHP开发者，在互联网上有很多可用的开发工具，但是找到一个合适的PHP开发工具是很难的，需要花费很多努力和时间。今天，就为开发者介绍45个方便的PHP工具。</p>

<h3>Plates</h3>

<p><a rel="nofollow" href="http://platesphp.com/">Plates</a>是一个简单易用的PHP模板系统。Plates是为那些喜欢使用本地模板而不是编译模板的人设计的。</p>

<h3>Laravel</h3>

<p><a rel="nofollow" href="http://laravel.com/">Laravel</a>是一个有着优雅表达语言的开源框架。</p>

<h3>Parsedown</h3>

<p>一个Laravel的<a rel="nofollow" href="http://parsedown.org/">Parsedown</a>包装器，能够将markdown编译成HTML。Parsedown运行很快，并支持GitHub flavored markdown.</p>

<h3>Guzzle</h3>

<p><a rel="nofollow" href="http://docs.guzzlephp.org/en/latest/">Guzzle</a>是一个PHP版的HTTP客户端，让PHP很容易的和HTTP/1.1协议一起使用，并能减少Web服务带来的痛苦。</p>

<h3>Hoa</h3>

<p><a rel="nofollow" href="http://hoa-project.net/En/">Hoa</a>是一组PHP库，它创建了工业和研究之间的桥梁。</p>

<h3>PHP-CPP</h3>

<p><a rel="nofollow" href="http://www.php-cpp.com/">PHP-CPP</a>是一个C++写的PHP扩展库。它提供了一个良好的文档记录和易于使用的类的集合,可以使用和扩展构建本地PHP扩展。</p>

<h3>Twig</h3>

<p><a rel="nofollow" href="http://twig.sensiolabs.org/">Twig</a>是一个快速、安全和稳定的PHP模板引擎。</p>

<h3>Requests for PHP</h3>

<p><a rel="nofollow" href="http://requests.ryanmccue.info/">Requests</a>是用PHP写的HTTP库。</p>

<h3>The Prettifier</h3>

<p><a rel="nofollow" href="http://prettifier.net/">Prettifier</a>为一些编程语言，如CSS/HTMl/XML/PHP/SQL/Perl等，提供了一个在线编辑、格式和语言高亮的平台。</p>

<h3>Geocoder PHP</h3>

<p><a rel="nofollow" href="http://geocoder-php.org/Geocoder/">Geocoder</a>是一个构建geo应用很好的库，为geocoding操作提供了一个抽象层。</p>

<h3>Slim Starter</h3>

<p><a rel="nofollow" href="http://www.xsanisty.com/">Slim Starter</a>由Xsanisty创建，是创建高级Web应用的解决方案。</p>

<h3>Mink</h3>

<p><a rel="nofollow" href="http://mink.behat.org/en/latest/index.html">Mink</a>是一个PHP库，可以让你以交互的方式在浏览器中测试Web APP，它移除了两种浏览器模拟器之间的API差异，为你提供一个更准确的测试环境。</p>

<h3>Forp</h3>

<p><a rel="nofollow" href="http://anthonyterrien.com/forp/">Forp</a>是用C写的PHP分析器。Forp是轻量级的PHP扩展，它提供了一个简单的PHP数组或JSON输出，其包含了完整的脚本调用堆栈和CPU和内存使用情况。forp是非侵入性,并提供PHP注释来完成工作。</p>

<h3>Belt</h3>

<p>对PHP开发者来说，<a rel="nofollow" href="https://github.com/ilya-dev/belt">Belt</a>是一个非常有用的工具，它提供了超过60个有用的函数。</p>

<h3>Icon Generator for PHP</h3>

<p><a rel="nofollow" href="https://github.com/runmybusiness/initialcon">Icon Generator</a>允许你生成基于彩色背景的Icon图标，这和Gmail的类似。</p>

<h3>Rainloop</h3>

<p><a rel="nofollow" href="http://www.rainloop.net/">Rainloop</a>是一个免费开源的PHP Web邮件应用，它有现代的用户接口，支持SMTP + IMAP。</p>

<h3>Pattern Lab</h3>

<p><a rel="nofollow" href="http://patternlab.io/">Pattern Lab</a>不仅是一个前端框架，也是一个PHP驱动的静态网站生成器、项目模式库和前端风格指南。</p>

<h3>Composer</h3>

<p><a rel="nofollow" href="https://getcomposer.org/">Composer</a>是一个独立的PHP管理插件，在你项目的根目录创建一个组合器文件，再运行一个命令，则你所有的依赖都可以下载使用了。</p>

<h3>Directus</h3>

<p><a rel="nofollow" href="http://getdirectus.com/">Directus</a>是用Backbone.js创建的免费开源的、客户端友好的数据库GUI，它提供了丰富的功能用户快速开发和自定义数据库解决方案管理。</p>

<h3>PHP Debug Bar</h3>

<p><a rel="nofollow" href="http://phpdebugbar.com/">Debug</a>可以很容易的集成到任何项目中，并能显示来自应用任何部分的分析数据。它来自于PHP内置数据收集器的特性和受欢迎的项目。</p>

<h3>Phalcon PHP</h3>

<p><a rel="nofollow" href="http://phalconphp.com/en/">Phalcon PHP</a>是C扩展的一个Web框架，提供了高性能和低资源消耗。</p>

<h3>Pinboard</h3>

<p><a rel="nofollow" href="http://intaro.github.io/pinboard/">Pinboard</a>是一个MySQL存储引擎，为PHP的MYSQL使用情况提供了实时监控/统计数据服务的只读接口。</p>

<h3>Casebox</h3>

<p><a rel="nofollow" href="https://www.casebox.org/">Casebox</a>是一个开源的PHP/MYSQL驱动的Web应用，用于存储和管理记录、任务和文件。它有一个类似桌面的界面,我们可以创建一个unlimited-level目录用于优先存储结构化的东西。</p>

<h3>Munee</h3>

<p><a rel="nofollow" href="http://mun.ee/">Munee</a>是一个一体化库，开源处理很多与Web资源优化和操作相关的事情。Munee也有很强大的缓存功能，可以在服务器和客户端缓存资源。</p>

<h3>ImageWorkshop</h3>

<p><a rel="nofollow" href="http://phpimageworkshop.com/">ImageWorkshop</a>是一个基于GD库的开源类，可以帮助你用PHP管理图像。这个类很像PS、GIMP一类的图像编辑软件：你可以添加许多层或层组,每一层都有一个背景图像。</p>

<h3>Sylius</h3>

<p><a rel="nofollow" href="http://sylius.com/">Sylius</a>为PHP而设计的免费开源的电子商务解决方案（基于Symfony2），它能够管理任何规模的商店和复杂的产品类别。</p>

<h3>Pico</h3>

<p><a rel="nofollow" href="http://picocms.org/">Pico</a>是一个开源的CMS应用，没有多余的东西，这才是最重要的。它使用平面文件作为数据库，用PHP构建。简单的说，不用设置什么，这个APP就能运行。</p>

<h3>PHP MyFAQ</h3>

<p><a rel="nofollow" href="http://www.phpmyfaq.de/">PHP MyFAQ</a>是一个稳定开源的PHP F.A.Q. 应用，为构建一个很好的F.A.Q.系统提供了很多功能，并提供了强大的管理界面来管理类别、条目、用户和查看统计数据。A###PHP Documentor<br><a rel="nofollow" href="http://phpdoc.org/">PHP Documentor</a>能读取代码的结构,文件系统结构、类、函数和介于两者之间的,并生成文档。</p>

<h3>CakePHP</h3>

<p><a rel="nofollow" href="http://cakephp.org/">CakePHP</a>是一个开源的Web应用框架，遵循MVC模式，并有PHP编写。它仿照Ruby on Rails的概念,在MIT许可下发布的。</p>

<h3>CodeIgniter</h3>

<p><a rel="nofollow" href="http://www.codeigniter.com/">CodeIgniter</a>是一个强大的、开源的PHP框架。</p>

<h3>Monsta FTP</h3>

<p><a rel="nofollow" href="http://www.monstaftp.com/">Monsta FTP</a>是一个PHP云件，并能将FTP文件管理放置在Web浏览器中，你可以在浏览器中进行文件的拖放。</p>

<h3>XAMPP</h3>

<p><a rel="nofollow" href="https://www.apachefriends.org/index.html">XAMPP</a>是一个免费和开源的跨平台web服务器解决方案，主要包括Apache HTTP服务器、MySQL数据库、PHP和Perl编写的脚本解释器。</p>

<h3>NetBeans</h3>

<p><a rel="nofollow" href="https://netbeans.org/">NetBeans</a>是开源的，并允许你使用Java, HTML5, PHP, C/C++等快速开发桌面、移动和Web应用。</p>

<h3>Aura</h3>

<p><a rel="nofollow" href="http://auraphp.com/">Aura</a>为PHP5.4+提供了独立的库包。这些包可以单独使用,具有一致性、也能自我组合成一个完整的框架。</p>

<h3>PHPCheckstyle</h3>

<p><a rel="nofollow" href="https://phpcheckstyle.github.io/">PHPCheckstyle</a>是一个开源功能，能帮助PHP程序员保持一致的编码风格。该工具检查输入PHP源代码和报告任何违反给定的标准。</p>

<h3>PHP Mess Detector</h3>

<p><a rel="nofollow" href="http://phpmd.org/">PHP Mess Detector</a>易于配置，前端用户友好。它能检查代码中的潜在问题,包括可能的错误,次优的代码,未使用的参数,等等。</p>

<h3>Kohana</h3>

<p><a rel="nofollow" href="https://kohanaframework.org/">Kohana</a>一个基于PHP5的优雅的、开源和面向对象HMVC框架,由一群志愿者维护和开发。它的目标是迅速,安全,和轻量。</p>

<h3>Sabberworm</h3>

<p>用PHP编写的一个CSS文件解析器。<a rel="nofollow" href="http://www.sabberworm.com/blog/2010/6/10/php-css-parser">Sabberworm</a>允许提取CSS文件到一个数据结构,操纵结构和输出(优化的)CSS。</p>

<h3>Nette</h3>

<p><a rel="nofollow" href="http://nette.org/en/">Nette</a>框架是一个PHPweb开发的工具。它被设计成尽可能友好、易用。它侧重于安全性和性能，绝对是最安全的PHP开发框架之一。</p>

<h3>PHP Markdown</h3>

<p>这是一个库包，包含了<a rel="nofollow" href="https://michelf.ca/projects/php-markdown/">PHP Markdown</a>解析器和额外的功能扩展。Markdown是一个text-to-html的转换工具。</p>

<h3>Yii 2</h3>

<p><a rel="nofollow" href="http://www.yiiframework.com/">Yii 2</a>完整重写它的先前版本1.1,Yii也是最流行的PHP开发框架之一。Yii是一个高性能的PHP框架，最适合开发Web 2.0应用程序。</p>

<h3>PHP Sandbox</h3>

<p><a rel="nofollow" href="https://github.com/fieryprophet/php-sandbox">PHP Sandbox</a>利用PHPParser来防止沙箱运行不安全的代码。它利用FunctionParser分解传递到沙箱的调用,这样，即使没有转换成字符串，PHP调用也可以在沙箱中运行。</p>

<p>译文出处：<a rel="nofollow" href="http://www.ido321.com/1546.html"></a><a rel="nofollow" href="http://www.ido321.com/1546.html">http://www.ido321.com/1546.html</a></p>

<p>英文原文：<a rel="nofollow" href="http://www.developerdrive.com/2015/03/40-tools-for-writing-better-php/">40+ tools for writing better PHP</a></p>

2015年五月3日晚上 8:57:23
HT for Web的HTML5树组件延迟加载技术实现
<p><a rel="nofollow" href="http://www.hightopo.com/">HT for Web</a>的<a rel="nofollow" href="http://www.hightopo.com/">HTML5树组件</a>有延迟加载的功能，这个功能对于那些需要从服务器读取具有层级依赖关系数据时非常有用，需要获取数据的时候再向服务器发起请求，这样可减轻服务器压力，同时也减少了浏览器的等待时间，让页面的加载更加流畅，增强用户体验。<br>
进入正题，今天用来做演示的Demo是，客户端请求服务器读取系统文件目录结构，通过<a rel="nofollow" href="http://www.hightopo.com/">HT for Web</a>的HTML5树组件显示系统文件目录结构。<br>
首先，我们先来设计下服务器，这次Demo的服务器采用<a rel="nofollow" href="https://nodejs.org/">Node.js</a>，用到了Node.js的<a rel="nofollow" href="http://expressjs.com/">express</a>、<a rel="nofollow" href="http://socket.io/get-started/chat/">socket.io</a>、fs和http这四个模块，<a rel="nofollow" href="https://nodejs.org/">Node.js</a>的相关知识，我在这里就不阐述了，网上的教材一堆，这里推荐下<a rel="nofollow" href="http://socket.io/get-started/chat/">socket.io</a>的相关入门<a rel="nofollow" href="http://socket.io/get-started/chat/">http://socket.io/get-started/chat/</a>。<br>
服务端代码代码：</p>

<pre><code>var fs = require('fs'),
    express = require('express'),
    app = express(),
    server = require('http').createServer(app),
    io = require('socket.io')(server),
    root = ‘/Users/admin/Projects/ht-for-web/guide‘;

io.on('connection', function(socket){
    socket.on('explore', function(url){
        socket.emit('file', walk(url || root));
    });
});

app.use(express.static('/Users/admin/Projects/ht-for-web'));

server.listen(5000, function(){
    console.log('server is listening at port 5000');
});
</code></pre>

<p>io监听了connection事件，并获得一个socket；socket再监听一个叫explore的自定义事件，通过url参数获取到数据后，派发一个叫file的自定义事件，供客户端监听并做相应处理；通过app.use结合express.static设置项目路径；最后让server监听5000端口。<br>
到此，一个简单的服务器就搭建好了，现在可以通过<a rel="nofollow" href="http://localhost:5000">http://localhost:5000</a>来访问服务器了。等等，好像缺了点什么。对了，获取系统文件目录结构的方法忘记给了，OK，那么我们就先来看看获取整站文件的代码是怎么写的：</p>

<pre><code>function walk(pa) {
    var dirList = fs.readdirSync(pa),
        key = pa.substring(pa.lastIndexOf('/') + 1),
        obj = {
            name: key,
            path: pa,
            children: [],
            files: []
        };
    dirList.forEach(function(item) {
        var stats = fs.statSync(pa + '/' + item);
        if (stats.isDirectory()) {
            obj.children.push(walk(pa + '/' + item));
        }
        else {
            obj.files.push({name: item, dir: pa + '/' + item});
        }
    });

    return obj;
}
</code></pre>

<p>如大家所见，采用递归的方式，逐层遍历子目录，代码也没什么高深的地方，相信大家都看得懂。那我们来看看运行效果吧：<br><img src="/img/bVlAVN" alt="031953507553944.png"><br>
duang～文件目录结构出来了，是不是感觉酷酷的，这代码量不小吧。其实，代码并不多，贴出来大家瞅瞅：</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head lang="en"&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;tree-loader&lt;/title&gt;
    &lt;script src="/socket.io/socket.io.js"&gt;&lt;/script&gt;
    &lt;script src="/lib/core/ht.js"&gt;&lt;/script&gt;
    &lt;script&gt;
        var socket = io(), idMap = {};
        function init() {
            var dm = window.dm = new ht.DataModel(),
                    tree = new ht.widget.TreeView(dm);

            tree.addToDOM();

            socket.on('file', function(data) {
                var root = dm.getDataById(idMap[data.path]);
                createChildren(data.children || [], root, dm);
                createFiles(data.files || [], root, dm);
            });
            socket.emit('explore');
        }

        function createChildren(children, parent, dm) {
            children.forEach(function(child) {
                var n = createData(child, parent);
                dm.add(n);
                createChildren(child.children || [], n, dm);
                createFiles(child.files || [], n, dm);
            });
        }

        function createFiles(files, parent, dm){
            files.forEach(function(file){
                var n = createData(file, parent);
                dm.add(n);
            });
        }

        function createData(data, parent){
            var n = new ht.Data();
            n.setName(data.name);
            n.setParent(parent);
            n.a('path', data.path);
            idMap[data.path] = n.getId();
            return n;
        }
    &lt;/script&gt;
&lt;/head&gt;
&lt;body onload="init();"&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>这就是全部的HTML代码，加上空行总共也就50几行，怎么样，有没有感觉<a rel="nofollow">HT for Web</a>很强大。废话不多说，来看看这些代码都干了些什么：</p>

<ul>
<li><p>要用到<a rel="nofollow" href="http://socket.io/get-started/chat/">socket.io</a>就需要在页面引入&lt;script src=“/socket.io/socket.io.js”&gt;&lt;/script&gt;，其实在我的项目中并不存在/socket.io/socket.io.js文件，但是却能正常使用，具体什么原因，我就不多说，大家自己研究去吧；</p></li>
<li><p>最重要的是要引入<a rel="nofollow" href="http://www.hightopo.com/">HT for Web</a>的核心包&lt;script src=“/lib/core/ht.js”&gt;&lt;/script&gt;，这个包不引入的话，下面的HT for Web组件就无法使用；</p></li>
<li><p>接下来就是代码了，首先创建一个数据容器<a rel="nofollow" href="http://www.hightopo.com/">DataModel</a>，用来存放文件目录的节点数据，再创建一个<a rel="nofollow" href="http://www.hightopo.com/">TreeView</a>对象并引用刚创建到数据容器，接下来通过socket监听file事件，获取服务器返回的数据，在回调函数中通过调用createChildren和createFiles函数，创建文件目录节点对象，并添加到数据容器中，最后是向服务器发起数据请求，即通过socket派发explore事件。</p></li>
</ul>
<p>整体的思路是这样子的，当然这离我们要实现的树组件的延迟加载技术还有些差距，那么，<a rel="nofollow" href="http://www.hightopo.com/">HT for Web的HTML5树组件</a>的延迟加载技术是怎么实现的呢？不要着急，马上开始探讨。<br>
首先我们需要改造下获取文件目录的方法walk，因为前面介绍的方法中，使用的是加载整站文件目录，所以我们要将walk方法改造成只获取一级目录结构，改造起来很简单，就是将递归部分改造成获取当前节点就可以了，具体代码如下：</p>

<pre><code>obj.children.push(walk(pa + '/' + item));
// 将上面对代码改成下面的代码
obj.children.push({name: item, path: pa + '/' + item});
</code></pre>

<p>这样子服务器就只请求当前请求路径下的第一级文件目录结构。接下来就是要调整下客户端代码了，首先需要给tree设置上loader:</p>

<pre><code>tree.setLoader({
    load: function(data) {
        socket.emit('explore', data.a('path'));
        data.a('loaded', true);
    },
    isLoaded: function(data) {
        return data.a('loaded');
    }
});
</code></pre>

<p>loader包含了两个方法，load和isLoaded，这两个方法的功能分别是加载数据和判断数据是否已经加载，在load方法中，对socket派发explore事件，当前节点的path为参数，向服务器请求数据，之后将当前节点的loaded属性设置为true；在isLoaded方法中，返回当前节点的loaded属性，如果返回为true，那么<a rel="nofollow" href="http://www.hightopo.com/">tree</a>将不会在执行load方法向服务器请求数据。<br>
接下来需要移除createChildren的两个回调方法，并且在createFiles方法中为创建出来的节点的loaded属性设置成true，这样在不是目录的节点前就不会有展开的图标。createChildren和createFiles两个方法修改后的代码如下：</p>

<pre><code>function createChildren(children, parent, dm) {
    children.forEach(function(child) {
        var n = createData(child, parent);
        dm.add(n);
    });
}

function createFiles(files, parent, dm){
    files.forEach(function(file){
        var n = createData(file, parent);
        n.a('loaded', true);
        dm.add(n);
    });
}
</code></pre>

<p>如此，<a rel="nofollow" href="http://www.hightopo.com/">HT for Web的HTML5树组件</a>延迟加载技术就设计完成了，我在服务器的控制台打印出请求路径，看看这个延迟加载是不是真的，如下图：<br><img src="/img/bVlAVS" alt="031957283802225.png"><br><img src="/img/bVlAVU" alt="031958228967071.png"><br>
看吧，控制台打印的是4条记录，第一条是请求跟目录时打印的，我在浏览器中展开里三个目录，在控制台打印了其对应的目录路径。<br>
等等，现在这个目录看起来好烦，只有文字，除了位子前的展开图标可以用来区别文件和目录外，没有其他什么区别，所以我决定对其进行一番改造，让每一级目录都有图标，而且不同文件对应不同的图标，来看看效果吧：<br><img src="/img/bVlAVW" alt="031959440051625.png"><br>
怎么样，是不是一眼就能看出是什么文件，这个都是样式上面的问题，我就不再一一阐述了，直接上代码：</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head lang="en"&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;script src="/socket.io/socket.io.js"&gt;&lt;/script&gt;
    &lt;script src="/build/ht-debug.js"&gt;&lt;/script&gt;
    &lt;script&gt;
        var socket = io(), idMap = {};
        function init() {
            var icons = ['css', 'dir-open', 'dir', 'file', 'flash', 'gif', 'html', 'jar',
                'java', 'mp3', 'pdf', 'png', 'script', 'txt', 'video', 'xml', 'zip'];
            icons.forEach(function(c){
                ht.Default.setImage(c, 16, 16, '/test/wyl/images/' + c + '.png');
            });

            var dm = window.dm = new ht.DataModel(),
                    tree = new ht.widget.TreeView(dm);
            tree.setLoader({
                load: function(data) {
                    socket.emit('explore', data.a('path'));
                    data.a('loaded', true);
                },
                isLoaded: function(data) {
                    return data.a('loaded');
                }
            });
            tree.getLabelFont = function(data){
                return '13px Helvetica, Arial, sans-serif';
            };
            tree.getLabelColor = function (data) {
                return this.isSelected(data) ? 'white' : 'black';
            };
            tree.getSelectBackground = function (data) {
                return '#408EDB';
            };
            tree.getIcon = function (data) {
                var icon = data.getIcon() || 'file';
                if (data.a('isdir')) {
                    if (this.isExpanded(data)) {
                        icon = 'dir-open';
                    } else {
                        icon = 'dir';
                    }
                }
                return icon;
            };
            tree.addToDOM();

            socket.on('file', function(data) {
                var root = dm.getDataById(idMap[data.path]);
                createChildren(data.children || [], root, dm);
                createFiles(data.files || [], root, dm);
            });
            socket.emit('explore');
        }

        function createChildren(children, parent, dm) {
            children.forEach(function(child) {
                var n = createData(child, parent);
                n.a('isdir', true);
                dm.add(n);
            });
        }

        function createFiles(files, parent, dm){
            files.forEach(function(file){
                var n = createData(file, parent);
                n.a('loaded', true);
                dm.add(n);
            });
        }

        function createData(data, parent){
            var name = data.name,
                    icon = 'file';
            if (/.jar$/.test(name)) icon = 'jar';
            else if (/.css$/.test(name)) icon = 'css';
            else if (/.gif$/.test(name)) icon = 'gif';
            else if (/.png$/.test(name)) icon = 'png';
            else if (/.js$/.test(name)) icon = 'script';
            else if (/.html$/.test(name)) icon = 'html';
            else if (/.zip$/.test(name)) icon = 'zip';
            var n = new ht.Data();
            n.setName(data.name);
            n.setParent(parent);
            n.setIcon(icon);
            n.a('path', data.path);
            idMap[data.path] = n.getId();
            return n;
        }
    &lt;/script&gt;
&lt;/head&gt;
&lt;body onload="init();"&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>在最后，附上完整的服务器代码：</p>

<pre><code>var fs = require('fs'),
    express = require('express'),
    app = express(),
    server = require('http').createServer(app),
    io = require('socket.io')(server),
    root = '/Users/admin/Projects/ht-for-web/guide';

io.on('connection', function(socket){
    socket.on('explore', function(url){
        socket.emit('file', walk(url || root));
    });
});

app.use(express.static('/Users/admin/Projects/ht-for-web'));

server.listen(5000, function(){
    console.log('server is listening at port 5000');
});

function walk(pa) {
    var dirList = fs.readdirSync(pa),
        key = pa.substring(pa.lastIndexOf('/') + 1),
        obj = {
            name: key,
            path: pa,
            children: [],
            files: []
        };
    dirList.forEach(function(item) {
        var stats = fs.statSync(pa + '/' + item);
        if (stats.isDirectory()) {
            obj.children.push({name: item, path: pa + '/' + item});
        }
        else {
            obj.files.push({name: item, dir: pa + '/' + item});
        }
    });

    return obj;
}
</code></pre>

2015年五月3日晚上 8:05:17
改造了一个Markdown在线编辑器，现在它终于让我感到完美了！
<p><a rel="nofollow" href="http://segmentfault.com/">http://segmentfault.com/</a> 怎么老是莫名其妙地挂掉？网页会莫名其妙地打不开。<br>
好吧，我且不说这事了。今天我花了一天时间在改造一个Markdown 在线编辑器，终于把它改造得满符合我的想法了。哈哈，好有成就感。我曾经在网上试用了很多markdown在线编辑器，发现绝大部分都有一个毛病：在输入框里敲下Tab键，它不是自动插入一个tab制表符，而是焦点自动跳到下一个链接处了。这对经常要写代码的我简直是抓狂。好在我终于找到了一个在线编辑器 <a rel="nofollow" href="http://lab.lepture.com/editor/">http://lab.lepture.com/editor/</a>，它对Tab键的处理恰好好处。但是我觉得还不够完美，于是自己动手改造它。<br>
先说下我做了点什么修改，看图：<br><img src="/img/bVlASH" alt="图片描述"><br>
我加了一几个按钮：插入视频，插入音乐，插入代码，并为它们一一分配了快捷键。并且还为Ctrl+S分配了快速提交功能。<br>
其次是粘贴功能，这是我今天改造的重头戏。我觉得把网页上的内容粘贴到这个在线编辑器里，还得手工把它修改成Markdown代码，太费事了。于是希望能够自动完成。另外，上传图片，本来它是没有图片上传功能的，只能手工输入图片地址。费事啊！我也把这个功能集成到粘贴功能里了。<br>
首先，需要在在线编辑器中绑定<code>onPaste</code>事件。<br>
我看到那个editor.js中第1580行中有<code>onKeyPress</code>事件绑定。我先给它加了一个<code>onPaste</code>事件绑定。</p>

<pre><code>javascript</code><code>    on(d.input, "input", bind(fastPoll, cm));
    on(d.input, "keydown", operation(cm, onKeyDown));
    on(d.input, "keypress", operation(cm, onKeyPress));
    on(d.input, "paste", operation(cm,onPaste)); // 这句是我添加的
    on(d.input, "focus", bind(onFocus, cm));
    on(d.input, "blur", bind(onBlur, cm));
</code></pre>

<p>然后 ，需要写一个<code>onPaste</code>函数。我把它写在onKeyPress函数后面。<br>
我先是想实现在粘贴时自动把HTML代码转换成Markdown的功能。于是写了这么一个函数。</p>

<pre><code>javascript</code><code>   function onPaste(e){
       if(!e.clipboardData)return true;
       //IE浏览器不支持e.clipboardData对象，无奈
       if(e.clipboardData.types=='text/plain')return true;
       // 如果剪贴板中的内容是纯文本内容，直接粘贴。
       else if(e.clipboardData.types=='text/plain,text/html'){
       // 如果剪贴板中的内容是HTML内容，则需要对它进行一番改造
       var html=e.clipboardData.getData('text/html');
       html=html.replace(/&lt;html&gt;(\r?\n)+&lt;body&gt;(\r?\n)+&lt;!--StartFragment--&gt;(.*?)&lt;!--EndFragment--&gt;(\r?\n)+&lt;\/body&gt;(\r?\n)+&lt;\/html&gt;/,"$3");
       html=toMarkdown(html);
       // toMarkdown函数 http://segmentfault.com/a/1190000002723901 在这里已经写了
       var cm=this;
        _replaceSelection(cm, false, html,'');
       e.preventDefault();
       }
     }
</code></pre>

<p>这里有一个很详细的剪贴板js原生对象的介绍：<a rel="nofollow" href="http://wizard.ae.krakow.pl/~jb/localio.html">http://wizard.ae.krakow.pl/~jb/localio.html</a><br>
本来这样算是大功告成了，但是我又觉得还有点不甘心，因为我希望以后粘贴图片方便点。<br>
于是我继续修改这个<code>onPaste</code>函数，并加了一个图片上传功能。</p>

<pre><code>javascript</code><code>   function onPaste(e){
       if(!e.clipboardData)return true;
       if(e.clipboardData.types=='text/plain')return true;
       else if(e.clipboardData.types=='text/plain,text/html'){
       var html=e.clipboardData.getData('text/html');
       html=html.replace(/&lt;html&gt;(\r?\n)+&lt;body&gt;(\r?\n)+&lt;!--StartFragment--&gt;(.*?)&lt;!--EndFragment--&gt;(\r?\n)+&lt;\/body&gt;(\r?\n)+&lt;\/html&gt;/,"$3");
       html=toMarkdown(html);
       var cm=this;
        _replaceSelection(cm, false, html,'');
       e.preventDefault();
       }
       else if(e.clipboardData.types=='text/html,Files'){
        imgReader(e.clipboardData.items[1])
           e.preventDefault();
           }
        else if(e.clipboardData.types=='Files'){
           imgReader(e.clipboardData.items[0])
        }
      }

  function imgReader(item){
      if(item.kind=='file'&amp;&amp;item.type=='image/png'){
      var file = item.getAsFile(),reader = new FileReader();
      reader.onload = function( e ){
        var img = new Image();
        img.src = e.target.result;
        document.body.appendChild( img );
        // 把图片放在网页最下面，以便预览
        $.post('saveremoteimg.php',{'urls':e.target.result},function(data){
            _replaceSelection(editor.codemirror,false , '![', ']('+data+')\n');
            })
        };
    reader.readAsDataURL(file);
    }
};
</code></pre>

<p>saveremoteimg.php的源码是：</p>

<pre><code>php</code><code>&lt;?php
header('Content-Type: text/html; charset=UTF-8');
$attachDir='upload';//上传文件保存路径，结尾不要带/
$dirType=1;//1:按天存入目录 2:按月存入目录 3:按扩展名存目录  建议使用按天存
$maxAttachSize=2097152;//最大上传大小，默认是2M
$upExt="jpg,jpeg,gif,png";//上传扩展名
ini_set('date.timezone','Asia/Shanghai');//时区

//保存远程文件
function saveRemoteImg($sUrl){
    global $upExt,$maxAttachSize;
    $reExt='('.str_replace(',','|',$upExt).')';
    if(substr($sUrl,0,10)=='data:image'){//base64编码的图片，可能出现在firefox粘贴，或者某些网站上，例如google图片
        if(!preg_match('/^data:image\/'.$reExt.'/i',$sUrl,$sExt))return false;
        $sExt=$sExt[1];
        $imgContent=base64_decode(substr($sUrl,strpos($sUrl,'base64,')+7));
    }
    else{//url图片
        if(!preg_match('/\.'.$reExt.'$/i',$sUrl,$sExt))return false;
        $sExt=$sExt[1];
        $imgContent=getUrl($sUrl);
    }
    if(strlen($imgContent)&gt;$maxAttachSize)return false;//文件体积超过最大限制
    $sLocalFile=getLocalPath($sExt);
    file_put_contents($sLocalFile,$imgContent);
    //检查mime是否为图片，需要php.ini中开启gd2扩展
    $fileinfo= @getimagesize($sLocalFile);
    if(!$fileinfo||!preg_match("/image\/".$reExt."/i",$fileinfo['mime'])){
        @unlink($sLocalFile);
        return false;
    }
    return $sLocalFile;
}
//抓URL数据
function getUrl($sUrl,$jumpNums=0){
    $arrUrl = parse_url(trim($sUrl));
    if(!$arrUrl)return false;
    $host=$arrUrl['host'];
    $port=isset($arrUrl['port'])?$arrUrl['port']:80;
    $path=$arrUrl['path'].(isset($arrUrl['query'])?"?".$arrUrl['query']:"");
    $fp = @fsockopen($host,$port,$errno, $errstr, 30);
    if(!$fp)return false;
    $output="GET $path HTTP/1.0\r\nHost: $host\r\nReferer: $sUrl\r\nConnection: close\r\n\r\n";
    stream_set_timeout($fp, 60);
    @fputs($fp,$output);
    $Content='';
    while(!feof($fp))
    {
        $buffer = fgets($fp, 4096);
        $info = stream_get_meta_data($fp);
        if($info['timed_out'])return false;
        $Content.=$buffer;
    }
    @fclose($fp);
    global $jumpCount;//重定向
    if(preg_match("/^HTTP\/\d.\d (301|302)/is",$Content)&amp;&amp;$jumpNums&lt;5)
    {
        if(preg_match("/Location:(.*?)\r\n/is",$Content,$murl))return getUrl($murl[1],$jumpNums+1);
    }
    if(!preg_match("/^HTTP\/\d.\d 200/is", $Content))return false;
    $Content=explode("\r\n\r\n",$Content,2);
    $Content=$Content[1];
    if($Content)return $Content;
    else return false;
}
//创建并返回本地文件路径
function getLocalPath($sExt){
    global $dirType,$attachDir;
    switch($dirType)
    {
        case 1: $attachSubDir = 'day_'.date('ymd'); break;
        case 2: $attachSubDir = 'month_'.date('ym'); break;
        case 3: $attachSubDir = 'ext_'.$sExt; break;
    }
    $newAttachDir = $attachDir.'/'.$attachSubDir;
    if(!is_dir($newAttachDir))
    {
        @mkdir($newAttachDir, 0777);
        @fclose(fopen($newAttachDir.'/index.htm', 'w'));
    }
    PHP_VERSION &lt; '4.2.0' &amp;&amp; mt_srand((double)microtime() * 1000000);
    $newFilename=date("YmdHis").mt_rand(1000,9999).'.'.$sExt;
    $targetPath = $newAttachDir.'/'.$newFilename;
    return $targetPath;
}

$arrUrls=explode('|',$_POST['urls']);
$urlCount=count($arrUrls);
for($i=0;$i&lt;$urlCount;$i++){
    $localUrl=saveRemoteImg($arrUrls[$i]);
    if($localUrl)$arrUrls[$i]=$localUrl;
}
echo implode('|',$arrUrls);
?&gt;
</code></pre>

<p>想一想觉得还有点想改造的。在行内插入代码是需要在文字左右加两个点（键盘上Tab键上方的那个键），但是我发现在中文输入法中，它是自动打出·的，需要切换到英文输入状态才能打出想要的那个点。多敲一次键盘对我来说都是抓狂。我必须继续改造它，让它能像切换粗体或斜体那样用快捷键来实现。<br>
这倒好办。再写一个 toggleCode函数，添加在toggleItalic 函数下面：</p>

<pre><code>javascript</code><code>function toggleCode(editor) {
  var cm = editor.codemirror;
  var stat = getState(cm);

  var text;
  var start = '`';
  var end = '`';

  var startPoint = cm.getCursor('start');
  var endPoint = cm.getCursor('end');
  if (stat.code) {
    text = cm.getLine(startPoint.line);
    start = text.slice(0, startPoint.ch);
    end = text.slice(startPoint.ch);
    start = start.replace(/^(.*)?(`)(\S+.*)?$/, '$1$3');
    end = end.replace('`','');
    startPoint.ch -= 1;
    endPoint.ch -= 1;
    cm.setLine(startPoint.line, start + end);
  } else {
    text = cm.getSelection();
    cm.replaceSelection(start + text + end);

    startPoint.ch += 1;
    endPoint.ch += 1;
  }
  cm.setSelection(startPoint, endPoint);
  cm.focus();
}
</code></pre>

<p>然后在shortcuts数组中添加一项<code>'Cmd-Y': toggleCode</code>，改成这样子：</p>

<pre><code>javascript</code><code>var shortcuts = {
  'Cmd-B': toggleBold,
  'Cmd-I': toggleItalic,
  'Cmd-Y': toggleCode,  // 这项是我加的
  'Cmd-K': drawLink,
  'Cmd-Alt-I': drawImage,
  'Cmd-Q': drawCode, // 这项也是我加入的
  'Cmd-\'': toggleBlockquote,
  'Cmd-Alt-L': toggleOrderedList,
  'Cmd-L': toggleUnOrderedList,
  'Cmd-P': togglePreview
};
</code></pre>

<p>与此同时，getStatus函数需要改成这样：</p>

<pre><code>javascript</code><code>function getState(cm, pos) {
  pos = pos || cm.getCursor('start');
  var stat = cm.getTokenAt(pos);
  if (!stat.type) return {};

  var types = stat.type.split(' ');

  var ret = {}, data, text;
  for (var i = 0; i &lt; types.length; i++) {
    data = types[i];
    if (data === 'strong') {
      ret.bold = true;
    } else if (data === 'variable-2') {
      text = cm.getLine(pos.line);
      if (/^\s*\d+\.\s/.test(text)) {
        ret['ordered-list'] = true;
      } else {
        ret['unordered-list'] = true;
      }
    } else if (data === 'atom') {
      ret.quote = true;
    } else if (data === 'comment'){ // 这句是我加上去的
      ret.code = true;   // 这句也是我加上去的
    } else if (data === 'em') {
      ret.italic = true;
    }
  }
  return ret;
}
</code></pre>

<p>我觉得工具栏中没有按钮提示很不好。于是改改改~，改成下面这样：</p>

<pre><code>javascript</code><code>var toolbar = [
  {name: 'bold', action: toggleBold, shortcut:'Toggle Bold(Cmd-B)'},
  {name: 'italic', action: toggleItalic, shortcut:'Toggle Italic(Cmd-I)'},
  '|',

  {name: 'quote', action: toggleBlockquote, shortcut: 'toggle Blockquote(Cmd-\')'},
  {name: 'unordered-list', action: toggleUnOrderedList, shortcut:'Toggle UnorderList(Cmd-Alt-L)'},
  {name: 'ordered-list', action: toggleOrderedList, shortcut:'Toggle OrderList(Cmd-L)'},
  '|',

  {name: 'link', action: drawLink, shortcut:'Insert Link(Cmd-K)'},
  {name: 'image', action: drawImage, shortcut: 'Insert Image(Cmd-Alt-I)'},
  {name: 'play', action: drawVideo, shortcut: 'Insert Video'},
  {name: 'music', action: drawAudio, shortcut: 'Insert Audio'},
  {name: 'code', action: drawCode, shortcut: 'Insert Code(Cmd-Q)'},
  '|',

  {name: 'info', action: 'http://lab.lepture.com/editor/markdown'},
  {name: 'preview', action: togglePreview, shortcut: 'Toggle Preview'},
  {name: 'fullscreen', action: toggleFullScreen, shortcut: 'Toggle FullScreen'}
];

</code></pre>

<p>其实我发现原来的程序里有个小bug，就是用Ctrl+B或者Ctrl+I切换粗体、斜体的时候，第一次按Ctrl+B，会在选中块去的前后各加两个星号，而第二次按Ctrl+B的时候，前面的星号去掉了，后面的星号却没变化。我仔细看，发现原来的代码中正则表达式写错了。<br>
我修改了<code>toggleBold</code>和<code>toggleItalic</code>函数，现在总算正常了。</p>

<pre><code>javascript</code><code>function toggleBold(editor) {
  var cm = editor.codemirror;
  var stat = getState(cm);

  var text;
  var start = '**';
  var end = '**';

  var startPoint = cm.getCursor('start');
  var endPoint = cm.getCursor('end');
  if (stat.bold) {
    text = cm.getLine(startPoint.line);
    start = text.slice(0, startPoint.ch);
    end = text.slice(startPoint.ch);

    start = start.replace(/^(.*)?(\*|\_){2}(\S+.*)?$/, '$1$3');
    end = end.replace(/(\*|\_){2}/, '');// 这句是我修改过的
    startPoint.ch -= 2;
    endPoint.ch -= 2;
    cm.setLine(startPoint.line, start + end);
  } else {
    text = cm.getSelection();
    cm.replaceSelection(start + text + end);

    startPoint.ch += 2;
    endPoint.ch += 2;
  }
  cm.setSelection(startPoint, endPoint);
  cm.focus();
}

function toggleItalic(editor) {
  var cm = editor.codemirror;
  var stat = getState(cm);

  var text;
  var start = '*';
  var end = '*';

  var startPoint = cm.getCursor('start');
  var endPoint = cm.getCursor('end');
  if (stat.italic) {
    text = cm.getLine(startPoint.line);
    start = text.slice(0, startPoint.ch);
    end = text.slice(startPoint.ch);

    start = start.replace(/^(.*)?(\*|\_)(\S+.*)?$/, '$1$3');
    end = end.replace(/(\*|\_)/, ''); // 这句是我修改过的
    startPoint.ch -= 1;
    endPoint.ch -= 1;
    cm.setLine(startPoint.line, start + end);
  } else {
    text = cm.getSelection();
    cm.replaceSelection(start + text + end);

    startPoint.ch += 1;
    endPoint.ch += 1;
  }
  cm.setSelection(startPoint, endPoint);
  cm.focus();
}
</code></pre>

<p>现在很疲惫，不过总算改得令自己满意了。掌柜的站长也改进一下segmentfault.com的在线编辑器吧。</p>

2015年五月3日晚上 7:11:25
总是出问题的Crontab
<p>最近用Python写了一些数据统计的脚本，并使用crontab自动执行，但是配置crontab总是要过几个坑才行的，这里总结一下这次遇到的坑。</p>

<h2>输出</h2>

<p>要将crontab命令的输出记录到日志文件中，可以使用重定向，不仅要重定向<code>stdout</code>也要重定向<code>stderr</code>，因为Python解释器会将异常输出到<code>stderr</code>。示例：</p>

<pre><code>$HOME/path/to/script &gt; $HOME/log/file 2&gt;&amp;1
</code></pre>

<h2>环境变量</h2>

<p>crontab会以用户的身份执行配置的命令，但是不会加载用户的环境变量，crontab会设置几个默认的环境变量，例如SHELL、PATH和HOME等，一定要注意PATH可不是用户自定义的PATH。</p>

<p>我们往往会在<code>.bash_profile</code>文件中定义一些全局的环境变量，但是crontab执行时并不会加载这个文件，所以你在shell中正常执行的程序，放到crontab里就不行了，很可能就是因为找不到环境变量了。要解决这个问题只能是自己加载环境变量了，可以在shell脚本中添加<code>source $HOME/.bash_profile</code>，或者直接添加到crontab中。</p>

<pre><code>0 12 * * * source $HOME/.bash_profile &amp;&amp; $HOME/path/to/script &gt; $HOME/log/file 2&gt;&amp;1
</code></pre>

<h2>路径</h2>

<p>我们在写脚本时往往会使用相对路径，但是在crontab执行脚本时，由于工作目录不同，就会出现找不到文件或者目录不存在的问题。</p>

<p>解决方法是脚本中使用绝对路径或者在执行程序前切换工作目录，例如直接在crontab命令中切换工作目录：</p>

<pre><code>0 12 * * * source $HOME/.bash_profile &amp;&amp; cd $HOME/path/to/workdir &amp;&amp; ./script &gt; /HOME/log/file 2&gt;&amp;1
</code></pre>

<h2>编码</h2>

<p>我写的Python程序中输出了一些中文（编码是utf-8），在shell中直接执行没有问题，但是crontab执行时出现了UnicodeEncodeError的错误，Google了一下发现这个问题不仅仅是在crontab中会出现，在使用管道或者重定向的时候都会出现这个问题，原因是编码不同。</p>

<p>在终端中直接执行Python程序时，Python会将输出内容自动编码为终端所使用的编码，我使用的终端编码是utf-8，所以不会出错，输出的内容也是正常的。但是在使用管道或者重定向时，编码格式为ascii，Python会用ascii编码格式去encode输出的字符串，但是字符串的编码使用的时utf-8，所以会出现UnicodeEncodeError的错误。</p>

<p>解决方法：<br>
方法一：在程序中输出的字符串都加上<code>encode('utf-8')</code>；<br>
方法二：在crontab中加上<code>PYTHONIOENCODING=utf-8</code>，将Python的<code>stdout/stderr/stdin</code>编码设置为utf-8。</p>

2015年五月3日下午 5:22:24
关于 Monad 的学习笔记
<p>假期终于看明白了 Monad, 这个关卡卡了好几年了, 终于过了<br>
我现在只能说初步了解到 Monad, 不够深入, 打算留一点笔记下来</p>

<p>现在回头看, 如果从前学习得法的话, 最快可能几天或者几周就搞定的<br>
比如说有 Node.js 那样成熟的社区跟教程, 或者公司里有就有人教的话<br>
此前在 Haskell 中文论坛问过, 知乎问过, 微博私信问过, 英文教程也看了<br>
总体上 Monad 就成了越来越吸引我注意力的一个概念</p>

<h3>Rich Hichey 的影响</h3>

<p>我强烈推荐 Rich Hickey 的演讲, 因为我觉得他非常有智慧<br><a rel="nofollow" href="https://github.com/matthiasn/talk-transcripts/tree/master/Hickey_Rich">https://github.com/matthiasn/talk-transcripts/tree/master/Hickey_Rich</a><br>
虽然很多是我听不懂的, 但让我能从更高的层次去理解函数式编程为什么好<br>
比如说变量的问题, 他讲了好多例子, 讲清楚数据会发生改变是不可靠的<br>
还有保持简单对于系统的可靠性会带来多大改善, 为什么面向对象有问题<br>
好吧大部分是我听不懂, 但感觉很有启发</p>

<p>过程式编程是直观的, 但也是很存在问题的, 特别是学了函数式编程再回头看<br>
比如说 <code>null</code> 值的问题, 看似自然而然, 实际却是考虑不够严谨<br>
还有语句(或者说指令)按顺序执行的问题, 也很自然, 实际却考虑不足<br>
这类问题导致我们在编写代码过程中不断发现有特殊的情况需要回头考虑<br>
诚然迎合了新人学习编程所需的方便, 可代价却是对代码控制流的操作不够强大</p>

<p>我不否认有丰富经验跟能力的程序员能用过程式代码写出极为可靠的程序<br>
然而引入函数式编程强大的复合能力, 有可能让程序变得更加简短清晰<br>
而且如同 Haskell 这样搭配类型系统, 能让难以理解的过程稍微变得直观一些<br>
当然, 函数式编程所需的抽象能力真的不是为新手准备的, 这带来巨大的门槛</p>

<h3>纯函数</h3>

<p>要理解 Monad 首先要对纯函数有足够的认识, 我假设读者有了解过 Haskell<br>
相比过程式语言当中的函数(或者叫方法, procedure), Haskell 当中有很多不同:</p>

<ul>
<li>Haskell 当中能定义, 但不能赋值, 不能修改已经定义好的数据</li>
<li>纯函数传入参数相同, 返回值就一定相同, 不会有例外</li>
<li>读写文件这类 IO 操作, 也是有返回值的, 比如 <code>IO String</code>, <code>IO ()</code>
</li>
<li>Haskell 当中没有语句用于实现过程, 而是用函数模拟出来过程</li>
</ul>
<p>最后一点跟流行编程语言区别尤其大, 即便跟 Lisp 的设计也差别很大<br>
Lisp 虽然号称"一切皆表达式", 但在函数体, 在 <code>begin</code> 当中语句照样用:</p>

<pre><code>racket</code><code>(define (print-back)
  (define x (read))
  (print x))
</code></pre>

<p>比如这样的一段 Racket, 转化成 Haskell 看起来像是这样:</p>

<pre><code>haskell</code><code>printBack :: IO ()
printBack = do
  x &lt;- getLine
  print x
</code></pre>

<p>然而 <code>do</code> 表达式并不是 Haskell 真实的代码, 这是一套语法糖<br>
执行过程会被转化为 <code>&gt;&gt;=</code> 或者 <code>&gt;&gt;</code> 函数, 就像是下面这样:</p>

<pre><code>haskell</code><code>printBack = getLine &gt;&gt;= (\x -&gt; print x)
</code></pre>

<p>或者把函数放到前面来, 这样看得就更明确了:</p>

<pre><code>haskell</code><code>printBack = (&gt;&gt;=) getLine (\x -&gt; print x)
</code></pre>

<p>就是说 <code>getLine</code> 的执行结果, 还有后面的函数, 都是 <code>&gt;&gt;=</code> 这个函数的参数<br>
后边的 <code>(\x -&gt; print x)</code> 几乎就是个回调函数, 对, 类似 Callback Hell<br>
所以 <code>do</code> 表达式完全就是个障眼法, Haskell 里大量使用回调的写法<br>
同时因为回调, 所以 Haskell 不会暗地里并行执行参数里的操作, 而是有明确的先后顺序<br>
只不过 Haskell 语法灵活, 大量嵌套函数, 看起来还能跟没事一样, 看文档:<br><a rel="nofollow" href="http://en.wikibooks.org/wiki/Haskell/do_notation">http://en.wikibooks.org/wiki/Haskell/do_notation</a></p>

<p>总结一下就是纯函数编程, 过程式语言常用的招数都被废掉了<br>
整个 Haskell 的函数都往数学函数逼近, 比如 <code>f(x) = x^2 + 2*x + 1</code><br>
另外, 加上了一套代数化的类型系统, 能够容纳编程需要的各种类型</p>

<h3>IO 的特殊性</h3>

<p>IO 要特别梳理一下, 因为相较于过程式语言, 这里的 IO 处理很奇怪<br><a rel="nofollow" href="https://wiki.haskell.org/IO_inside">https://wiki.haskell.org/IO_inside</a><br>
通常编程语言的做法, 比如说常用的读取文件吧, 调用, 返回字符串, 很好理解:</p>

<pre><code>js</code><code>content = fs.readFileSync('filename', 'utf8') // Node.js
</code></pre>

<pre><code>julia</code><code>content = readall("filename") # Julia
</code></pre>

<pre><code>racket</code><code>(define content (file-&gt;string "filename")) ; Racket
</code></pre>

<p>但在纯函数语言当中有个大问题, 不是说好了参数一样, 返回值一样吗?<br>
所以在 Haskell 当中 <code>readFile</code> 返回值并不是 <code>String</code>, 而是加上了 <code>IO</code>:</p>

<pre><code>haskell</code><code>readFile :: IO String
</code></pre>

<p>结果就是处理文件内容时, 必需引入 Monad 的写法才行:</p>

<pre><code>haskell</code><code>main = do
  content &lt;- readFile "filename"
  putStr content
</code></pre>

<p>这个地方的 <code>IO String</code> 对 <code>String</code> 做了一层封装, 后面会遇到更多封装</p>

<h3>代数类型系统</h3>

<p>关于这一点, 我理解不准确, 但是举一些例子大概可以明白一些,<br>
比如这是类似加法的方式定义新的类型:</p>

<pre><code>haskell</code><code>data MySumType = Foo Bool | Bar Char
</code></pre>

<p>这是类似乘法的方式定义新的类型:</p>

<pre><code>haskell</code><code>data MyProductType = Baz (Bool, Char)
</code></pre>

<p>这是以递归的方式定义新的类型:</p>

<pre><code>haskell</code><code>data List a = Nil | Cons a (List a)
</code></pre>

<p>相比 C 或者 Go 通过 <code>struct</code> 定义新的类型, Haskell 显得很数学化<br>
因为, 如果用在 Go 里定义类型是 <code>A</code> 或者 <code>B</code>, 怎么定义? 还有递归?</p>

<p>Haskell 当中关于类型的概念, 整理在一起就是一些关键字:</p>

<ul>
<li>
<code>data</code>, <code>type</code>, <code>newtype</code> 用来定义类型或者类型的别名</li>
<li>
<code>instance</code>, <code>class</code> 用来实现类型之间的关联, 或者说定义实现类型类</li>
</ul>
<p>具体看这篇文章概括的, Haskell 当中类型, 类型类的一些操作<br><a rel="nofollow" href="http://joelburget.com/data-newtype-instance-class/">http://joelburget.com/data-newtype-instance-class/</a></p>

<p>这里的概念跟面向对象方面的, "类", "接口", "继承"有很多相似之处<br>
但是看下例子, 这在 Haskell 当中是怎样使用的,<br>
比如有一个叫做 <code>Functor</code> 的 Typeclass, 很多的 Type 都属于这个 Typeclass:</p>

<pre><code>haskell</code><code>class Functor f where  
    fmap :: (a -&gt; b) -&gt; f a -&gt; f b  
</code></pre>

<p>比如 <code>Maybe</code> Type 就是基于 <code>Functor</code> 实现, 首先用 <code>data</code> 定义 <code>Maybe</code> Type:</p>

<pre><code>haskell</code><code>data Maybe a = Just a | Nothing
    deriving (Eq, Ord)
</code></pre>

<p>然后通过 <code>instance</code> 在 <code>Maybe</code> 上实现 <code>Functor</code> 约定的函数 <code>fmap</code>:</p>

<pre><code>haskell</code><code>instance Functor Maybe where
    fmap f (Just x) = Just (f x)
    fmap f Nothing = Nothing
</code></pre>

<p>再比如 <code>[]</code> 也是, 那么首先 <code>[]</code> 大致可以这样定义<br>
然后会有 <code>[]</code> 上实现的 <code>Functor</code> 约定的 <code>fmap</code> 方法:</p>

<pre><code>haskell</code><code>data [a] = [] | a : [a] -- 演示代码, 可能有遗漏

instance Functor [] where
    fmap = map
</code></pre>

<p>还有一个例子比如说 <code>Tree</code> Type, 也可以同样实现 <code>fmap</code> 函数:</p>

<pre><code>haskell</code><code>data Tree a = Node a [Tree a]

instance Functor Tree where
    fmap f (Leaf x) = Leaf (f x)
    fmap f (Branch left right) = Branch (fmap f left) (fmap f right)
</code></pre>

<p>就是说, Haskell 当中的类型, 是通过这样一套写法定义出来的<br>
同样, <code>Monad</code> 也是个 Typeclass, 也就可以按上边这样理解<br>
单看写法, Go 的 <code>interface</code> 定义看起来相似, 至少语法上可以理解</p>

<h3>Functor, Applicative, Monad</h3>

<p>Haskell 首先是我们熟悉的 Value 还有 Function 的世界<br>
而 <code>Functor</code>, <code>Applicative</code>, <code>Monad</code> 在大谈封装的问题,<br>
就是值会被装进一个盒子当中, 然后从盒子外边用这三种手法去操作,<br><a rel="nofollow" href="http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html">http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_...</a></p>

<p>首先难以理解的是, 这层封装是什么? 为什么硬生生造出一个其他语言没有的概念?<br>
考虑到 Haskell 当中大量的 Category Theory(范畴论)的术语, 好像高等代数学到过..<br>
范畴论群论依然是我无法理解的数学语言, 所以这我依然不能解释, 究竟为什么有一层封装?<br>
没有办法, 只能先看一下这一层封装在 Haskell 当中派上了什么用场?</p>

<ul>
<li><code>Maybe</code></li>
</ul>
<p>首先 <code>Maybe</code> Type 实现了 <code>Monad</code>, 那么看下 <code>Maybe</code> 典型的场景<br>
注意下 Haskell 里 <code>1 / 0</code> 结果是 <code>Infinity</code>,, 这个大概也不是我们想要的<br>
下面是封装过的除法, <code>0</code> 不能作为被除数, 所以有了个 <code>Nothing</code>:</p>

<pre><code>haskell</code><code>divide :: (Fractional a) =&gt; a -&gt; a -&gt; Maybe a
divide a 0 = Nothing
divide a b = Just $ a / b
</code></pre>

<p>考虑一下这样一个四则运算, 上面提示了, 一个情况 <code>b</code> 可能是 <code>0</code>, 除法有问题<br>
但是作为例子, 很多 <code>x / 0</code> 在实际的编程当中我们会当成报错来处理,<br>
好, 先认为报错, 那么整个程序就退出了</p>

<pre><code>haskell</code><code>((a / b) * c) + d
</code></pre>

<p>不过, 引入 <code>Maybe</code> Type 给出了一套不同的方案, 对应有报错和没有报错的情况:</p>

<pre><code>haskell</code><code>(Just 0.5 * Just 3) + Just 4
Just 1.5 + Just 4
Just 4.5
</code></pre>

<pre><code>haskell</code><code>((Just 1 / Just 0) * Just 3) + Just 4
(Nothing * Just 3) + Just 4
Nothing + Just 4
Nothing
</code></pre>

<p>没有报错, 一切正常. 如果有报错后边的结果都是 Nothing<br>
这个就像 Railway Oriented Programming 给的那样, 增加了一套可能的流程:<br><a rel="nofollow" href="http://fsharpforfunandprofit.com/posts/recipe-part2/">http://fsharpforfunandprofit.com/posts/recipe-part2/</a><br><img src="http://fsharpforfunandprofit.com/assets/img/Recipe_Function_ErrorTrack.png" alt=""></p>

<ul>
<li><code>List</code></li>
</ul>
<p>然后, List 也实现了 <code>Monad</code>, 就来看下例子, 下面一段代码打印了什么结果</p>

<pre><code>haskell</code><code>example :: [(Int, Int, Int)]
example = do
  a &lt;- [1,2]
  b &lt;- [10,20]
  c &lt;- [100,200]
  return (a,b,c)
-- [(1,10,100),(1,10,200),(1,20,100),(1,20,200),(2,10,100),(2,10,200),(2,20,100),(2,20,200)]
</code></pre>

<p>其实是列表解析, 如果按花哨的写法写, 应该是这样:</p>

<pre><code>haskell</code><code>[(a, b, c) | a &lt;- [1,2], b &lt;- [10,20], c &lt;- [100,200]]
</code></pre>

<ul>
<li><code>(-&gt;) r</code></li>
</ul>
<p>后面的两个例子难以理解, 但是大概看一看, <code>(-&gt;) r</code> 也实现了 <code>Functor</code> Typeclass<br><code>(-&gt;) r</code> 是什么? 是函数, 一个参数的函数. 注意 Haskell 里的函数参数都是一个...</p>

<pre><code>haskell</code><code>instance Functor ((-&gt;) r) where
    fmap = (.)
</code></pre>

<p>函数作为 <code>fmap</code> 第二个参数, 最后效果居然是实现了函数复合! <code>f . g</code></p>

<pre><code>haskell</code><code>ghci&gt; :t fmap (*3) (+100)
fmap (*3) (+100) :: (Num a) =&gt; a -&gt; a
ghci&gt; fmap (*3) (+100) 1
303
</code></pre>

<ul>
<li><code>sequenceA</code></li>
</ul>
<p>更复杂的是实现了 <code>Applicative</code> Typeclass 的 <code>sequenceA</code> 函数</p>

<pre><code>haskell</code><code>sequenceA :: (Applicative f) =&gt; [f a] -&gt; f [a]  
sequenceA = foldr (liftA2 (:)) (pure [])  
</code></pre>

<p>这个函数能把别的函数组合在一起用, 还能把 IO 操作组合在一起用,<br>
而且这么密集的抽象... 3 个 IO 操作被排在一起了...</p>

<pre><code>haskell</code><code>ghci&gt; sequenceA [(&gt;4),(&lt;10),odd] 7  
[True,True,True]  
ghci&gt; and $ sequenceA [(&gt;4),(&lt;10),odd] 7  
True  

ghci&gt; sequenceA [getLine, getLine, getLine]  
heyh  
ho  
woo  
["heyh","ho","woo"]  
</code></pre>

<p>好, 回到上面的问题, <code>Functor</code>, <code>Applicative</code>, <code>Monad</code> 为什么有?<br>
之前说函数是语言一切都是函数, 一些过程式的写法写不了了,<br>
现在借助几个抽象, 好像又回来了, 而且花样还很多.. 连复合函数都构造了一遍<br>
在这样的认识之下, 再看下 <code>IO Monad</code> 做了什么, 加上 <code>do</code> 表达式:</p>

<pre><code>haskell</code><code>main :: IO ()
main = do putStrLn "What is your name: "
          name &lt;- getLine
          putStrLn name
</code></pre>

<p>完全就是在模仿面向过程的编程, 或者说把面向过程里的一些东西重新造了一遍<br>
当然我个人学到这里依然没明白设计思路, 但我知道是为什么要设计了<br>
按照教程上的说法, 我可以整理一下几个函数之间的关联的递进:</p>

<p>首先, Haskell 通常的代码可以看作是对基础类型进行操作<br>
比如我们有个函数 <code>f</code>, 有个数据 <code>x</code>, 通过 <code>call</code> 来调用:</p>

<pre><code>haskell</code><code>Prelude&gt; let call f x = f x
Prelude&gt; :t call
call :: (a -&gt; b) -&gt; a -&gt; b
</code></pre>

<p>那么 <code>call</code> 的类型声明就是 <code>(a -&gt; b) -&gt; a -&gt; b</code></p>

<ul>
<li><code>Functor</code></li>
</ul>
<pre><code>haskell</code><code>class Functor f where  
    fmap :: (a -&gt; b) -&gt; f a -&gt; f b  
</code></pre>

<p>接着是 <code>Functor</code>, 注意类型声明变成的改变, 多了一层封装:</p>

<pre><code>haskell</code><code>(a -&gt; b) -&gt; a -&gt; b -- call
(a -&gt; b) -&gt; f a -&gt; f b -- fmap
</code></pre>

<ul>
<li><code>Applicative</code></li>
</ul>
<pre><code>haskell</code><code>class (Functor f) =&gt; Applicative f where  
    pure :: a -&gt; f a  
    (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b  
</code></pre>

<p>到了 <code>Applicative</code> 呢, 又在前面加上了一层封装:</p>

<pre><code>haskell</code><code>(a -&gt; b) -&gt; a -&gt; b -- call
(a -&gt; b) -&gt; f a -&gt; f b -- fmap
f (a -&gt; b) -&gt; f a -&gt; f b  -- &lt;*&gt;
</code></pre>

<ul>
<li><code>Monad</code></li>
</ul>
<pre><code>haskell</code><code>class Monad m where  
    return :: a -&gt; m a  

    (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b  

    (&gt;&gt;) :: m a -&gt; m b -&gt; m b  
    x &gt;&gt; y = x &gt;&gt;= \_ -&gt; y  

    fail :: String -&gt; m a  
    fail msg = error msg  
</code></pre>

<p>到了 <code>Monad</code>, 参数顺序跟具体的封装又做了改进(<code>m</code> 写成 <code>f</code> 方便对比):</p>

<pre><code>haskell</code><code>(a -&gt; b) -&gt; a -&gt; b -- call
(a -&gt; b) -&gt; f a -&gt; f b -- fmap
f (a -&gt; b) -&gt; f a -&gt; f b  -- (&lt;*&gt;)
f a -&gt; (a -&gt; f b) -&gt; f b  -- (&gt;&gt;=)
</code></pre>

<p>大致上有个规律, 就是调用函数封装 <code>f</code>, 手段都是为了函数能超越封装使用<br>
而且 <code>f</code> 会是什么? 有 <code>Maybe [] ((-&gt;) r) IO</code>, 还有其他很多<br>
带来效果是什么? 有处理报错, 列表解析, 符合函数, 批量的 IO, 以及其他<br>
Haskell 用纯函数补上了操作控制流和 IO 的功能, Monad 是其中一个手段</p>

<h3>Monad 的写法</h3>

<p>然后看下 Monad 去掉 <code>do</code> 表达式语法糖的时候怎么写, 原始的代码:<br><a rel="nofollow" href="http://stackoverflow.com/q/16964732/883571">http://stackoverflow.com/q/16964732/883571</a></p>

<pre><code>haskell</code><code>do num &lt;- numberNode x
   nt1 &lt;- numberTree t1
   nt2 &lt;- numberTree t2
   return (Node num nt1 nt2)
</code></pre>

<p>去掉了语法糖, 是一串 <code>&gt;&gt;=</code> 函数连接在一起, 一层层的缩进:</p>

<pre><code>haskell</code><code>numberNode x &gt;&gt;= \num -&gt;
  numberTree t1 &gt;&gt;= \nt1 -&gt;
    numberTree t2 &gt;&gt;= \nt2 -&gt;
      return (Node num nt1 nt2)
</code></pre>

<p>还有一个 <code>Applicative</code> 的写法</p>

<pre><code>haskell</code><code>Node &lt;$&gt; numberNode x &lt;*&gt; numberTree t1 &lt;*&gt; numberTree t2
</code></pre>

<p>最后一个我得看老半天... 好吧, 总之, Haskell 就是提供了如此复杂的抽象<br><code>print("x")</code> 在过程式语言中仅仅是指令, 在 Haskell 中却被处理为纯函数的调用<br>
Haskell 将纯函数用于高阶的函数的转化以及操作, 变成很强大的控制流<br>
前面说了, 实际上只是作为参数, 跟 Node.js 使用深度的回调很相似</p>

<p>不过还记得 Railway Oriented 那张图吗, 跟 Node.js 对比一下:</p>

<pre><code>js</code><code>fs.readFile("filename", "utf8", function(err, content) {
  if (err) { throw err }
  console.log(content)
})
</code></pre>

<p>注意 <code>err</code> 的处理, Haskell 当中可没有写 <code>err</code> 而是在 <code>&gt;&gt;=</code> 内部处理掉了<br>
而且 Haskell 也不会执行到这里就吐出返回值, 而是等全部执行完再返回<br>
上边我用过 Callback Hell 打比方, 不过除了写法相似, 其他方面差别不小</p>

<h3>总结</h3>

<p>好了我不是在写 <code>Monad</code> 教程, 我也没全弄明白, 但是上边记录了我理解的思路:</p>

<ul>
<li>可变数据, 副作用, 种种不确定性是编程当中混乱的来源</li>
<li>纯函数相对于过程式代码的特殊性, 决定了它不能简单使用语句或者指令直接写程序</li>
<li>Haskell 当中的 IO 做了封装, 使之融合到纯函数当中来</li>
<li>
<code>Monad</code> 是 Haskell 当中的 Typeclass, 所以我先不去管数学中的定义</li>
<li>什么是封装, 为什么 Haskell 中函数和数据会被封装</li>
<li>
<code>Monad</code> 起到了怎样的作用, 怎样理解它的作用</li>
</ul>
<p>我之前一直在想 Monad 会是数学结构当中某种强大的概念, 群论如何如何<br>
但是回头看, 这更像是人为定义出来的方便编程语言使用的几个 Typeclass 而已<br>
当新的数据类型被需要, 还可以自己定义, 用高阶函数玩转...<br>
总之我不必为了弄懂 Monad 是什么回去把高等代数啃一遍...</p>

<p>不过呢, 过了这一关我还是不会写稍微复杂点的程序, 类型系统难点真挺多的</p>

2015年五月3日下午 2:20:47
Lumen 初体验
<h2>介绍</h2>

<p>Lumen：“为速度而生的 Laravel 框架”。</p>

<p>Lumen 是 Laravel 的作者（Taylor Otwell）的又一力作。简单、快速、优雅的它的特点，适合用于构建微服务架构和 API 应用。<br>
官网：<a rel="nofollow" href="http://lumen.laravel.com"></a><a rel="nofollow" href="http://lumen.laravel.com">http://lumen.laravel.com</a><br>
介绍：<a rel="nofollow" href="https://phphub.org/topics/701"></a><a rel="nofollow" href="https://phphub.org/topics/701">https://phphub.org/topics/701</a><br>
中文文档：<a rel="nofollow" href="http://lumen.laravel-china.org/docs"></a><a rel="nofollow" href="http://lumen.laravel-china.org/docs">http://lumen.laravel-china.org/docs</a></p>

<h2>安装</h2>

<p>使用 composer 安装：</p>

<pre><code>bash</code><code>composer create-project laravel/lumen --prefer-dist
</code></pre>

<h2>配置</h2>

<p>Lumen 默认使用 <code>.env</code> 作为配置文件。<code>.env.example</code> 是官方给出的例子，直接拷贝命名为 <code>.env</code>。</p>

<pre><code>bash</code><code>cd lumen
cp .env.example .env
</code></pre>

<h2>调试模式</h2>

<p>修改 <code>.env</code> 文件：</p>

<pre><code>bash</code><code>APP_DEBUG=true
</code></pre>

<p>如果发现还是没有效果，再修改 <code>lumen/bootstrap/app.php</code> 文件，将 <code>Dotenv::load</code> 的注释移除掉。</p>

<h2>疑问</h2>

<h3>1.为什么提示：not be found</h3>

<p>访问：<a rel="nofollow" href="http://127.0.0.1/lumen/public/">http://127.0.0.1/lumen/public/</a></p>

<p>显示：</p>

<pre><code>bash</code><code>Sorry, the page you are looking for could not be found.

NotFoundHttpException in Application.php line 1121:

in Application.php line 1121
at Application-&gt;handleDispatcherResponse(array('0')) in Application.php line 1091
at Application-&gt;dispatch(null) in Application.php line 1026
at Application-&gt;run() in index.php line 28
</code></pre>

<p>查看路由文件 <code>lumen/app/Http/routes.php</code>：</p>

<pre><code>php</code><code>$app-&gt;get('/', function() use ($app) {
    return $app-&gt;welcome();
});
</code></pre>

<p>感觉没有问题啊，和在 Laravel 中差不多的方式，那是哪里出了问题了？好的，先不管，尝试自己新定义一条路由规则试试看：</p>

<pre><code>php</code><code>$app-&gt;get('/test', function() use ($app) {
    return $app-&gt;welcome();
});
</code></pre>

<p>再访问：<a rel="nofollow" href="http://127.0.0.1/lumen/public/test">http://127.0.0.1/lumen/public/test</a></p>

<p>结果和刚才一样。</p>

<h3>2.为什么会跳转</h3>

<p>再尝试访问一下：<a rel="nofollow" href="http://127.0.0.1/lumen/public/test/">http://127.0.0.1/lumen/public/test/</a><br>
结果跳转到：<a rel="nofollow" href="http://127.0.0.1/test">http://127.0.0.1/test</a></p>

<h2>解惑</h2>

<p>我先来解释一下第 2 个问题，因为这是一个很多 Laravel 新手也经常问的问题。</p>

<p>原因何在？请看 <code>lumen/public/.htaccess</code> 文件：</p>

<pre><code>bash</code><code>RewriteRule ^(.*)/$ /$1 [L,R=301]
</code></pre>

<p>这是一条 Apache 路由重写规则（mod_rewrite 开启的情况下才有效），当请求的 URI 带有 <code>/</code>，就会匹配出 <code>$1</code>， 永久重定向（HTTP 状态码是 301）到根目录下的 <code>$1</code>。上面的例子中，匹配到 test（就是$1），就跳转至 /test 了。</p>

<p>如何来规避上面这个问题？注释这条 RewriteRule 吗？不是的。一般来说，我们应该避免使用末尾带斜杠的 URI。为什么 URI 末尾不应该带有斜杠呢？从语义是来说， <code>test/</code> 表示目录，<code>test</code> 表示资源。还有，如果在 lumen/public 目录下真的有一个 test 目录，那么访问 <a rel="nofollow" href="http://127.0.0.1/lumen/public/test/">http://127.0.0.1/lumen/public/test/</a>，就会进入到 test 目录下面来，这不是我们想要的结果。（其实如果真的存在 test 目录并且不存在文件 test，那么，URI 末尾有没有斜杠都会进入到 test 目录中来，这是 Apache 决定的。因为它如果找不到文件，就会自动在末尾加个斜杠，尝试寻找目录下的 index.html 文件等等，具体是在 httpd.conf 中配置 DirectoryIndex。好吧，扯得太远了，拽回来）<br>
总之，我还是建议 URI 末尾不要带 <code>/</code>，如果你非不听，那就注释上面那句 RewriteRule 吧，这样就不会重定向了。</p>

<p>关于第 1 个问题，我们也来分析一下发生的原因，这样才能对症下药。<br>
根据错误提示，定位到文件 <code>lumen/vendor/laravel/lumen-framework/src/Application.php</code> 中：</p>

<pre><code>php</code><code>    /**
     * Dispatch the incoming request.
     *
     * @param  SymfonyRequest|null  $request
     * @return Response
     */
    public function dispatch($request = null)
    {
        if ($request) {
            $this-&gt;instance('Illuminate\Http\Request', $request);
            $this-&gt;ranServiceBinders['registerRequestBindings'] = true;

            $method = $request-&gt;getMethod();
            $pathInfo = $request-&gt;getPathInfo();
        } else {
            $method = $this-&gt;getMethod();
            $pathInfo = $this-&gt;getPathInfo();
        }        

        try {
            if (isset($this-&gt;routes[$method.$pathInfo])) {
                return $this-&gt;handleFoundRoute([true, $this-&gt;routes[$method.$pathInfo]['action'], []]);
            }

            return $this-&gt;handleDispatcherResponse(
                $this-&gt;createDispatcher()-&gt;dispatch($method, $pathInfo)
            );
        } catch (Exception $e) {
            return $this-&gt;sendExceptionToHandler($e);
        }
    }

</code></pre>

<p>匹配不到 route 的原因就在以上代码中。假设访问：<a rel="nofollow" href="http://127.0.0.1/lumen/public">http://127.0.0.1/lumen/public</a>，那么 :</p>

<pre><code>php</code><code>var_dump($method);  // string(3) "GET"
var_dump($pathInfo);  // string(14) "/lumen/public/"
</code></pre>

<p>根据 lumen/app/Http/routes.php 中的定义，生成 <code>$this-&gt;routes</code>：</p>

<pre><code>php</code><code>var_dump(array_keys($this-&gt;routes));  // array(2) { [0]=&gt; string(4) "GET/" [1]=&gt; string(8) "GET/test" }
</code></pre>

<p>由上可知， <code>isset($this-&gt;routes[$method.$pathInfo])</code> 的结果就是 <code>false</code>，所以提示 <code>not be found</code> 了。<br>
既然已经知道了原因，那问题就好解决了。解决的前提是<strong>不要改动框架的源代码</strong>，不然日后升级框架会多么蛋疼，你都把框架代码都修改，万一出了问题你咋办？你自己拆手机，官方是不保修的哦！当然，如果你是框架开发组的，你提交代码能被大家接受并被官方合并到主干代码中了，那你就改吧。</p>

<h3>方案1：修改 DocumentRoot</h3>

<p>修改 Apache 的配置文件 <code>httpd.conf</code>，将 <code>DocumentRoot</code> 指向 <code>lumen/public</code>：</p>

<pre><code>bash</code><code>DocumentRoot "/sites/lumen/public"
</code></pre>

<p>重启 Apache。</p>

<p>但是，如果我还有其他站点也在这个 Apache 下面，改 DocumentRoot 就会导致其他的站点不能访问了。怎么办？请看<strong>方案 2</strong>。</p>

<h3>方案2：配置 Apache 虚拟主机</h3>

<p>修改 <code>httpd.conf</code>，将下面这行的注释移除：</p>

<pre><code>bash</code><code>Include etc/extra/httpd-vhosts.conf
</code></pre>

<p>修改 <code>httpd-vhosts.conf</code>：</p>

<pre><code>bash</code><code>&lt;VirtualHost *:80&gt;
    DocumentRoot "/sites"
    ServerName 127.0.0.1
&lt;/VirtualHost&gt;
&lt;VirtualHost *:80&gt;
    DocumentRoot "/sites/lumen/public"
    ServerName lumen.app
&lt;/VirtualHost&gt;
</code></pre>

<p>重启 Apache。</p>

<p>修改主机的 <code>etc/hosts</code>，添加一行：</p>

<pre><code>bash</code><code>127.0.0.1 lumen.app
</code></pre>

<p>其中 127.0.0.1 应该换成你 lumen 应用存放的机器的 ip。</p>

<p>OK，这样就可以通过访问 <a rel="nofollow" href="http://lumen.app">http://lumen.app</a> 来访问该 lumen 站点，通过 <a rel="nofollow" href="http://127.0.0.1">http://127.0.0.1</a> 来访问其他站点。</p>

<p>但是，你压根不能修改 Apache 的配置，怎么办？请看<strong>方案 3</strong>。</p>

<h3>方案3.修改路由规则中的路径</h3>

<p>改不了配置，就改代码喽（再强调一下，不是修改框架的源代码）。</p>

<p>修改路由文件 <code>lumen/app/Http/routes.php</code>：</p>

<pre><code>php</code><code>define('ROUTE_BASE', 'lumen/public/')；

$app-&gt;get(ROUTE_BASE . '/index', function() use ($app) {
    return $app-&gt;welcome();
});
$app-&gt;get(ROUTE_BASE . '/test', function() use ($app) {
    return $app-&gt;welcome();
});
</code></pre>

<p>这样，如果以后有变化的话，你只需要修改 <code>define('ROUTE_BASE', 'lumen/public/')；</code>就可以了（当然，把这个写到应用配置项中是最合适的，部署时修改配置就可以了）。</p>

<p>至于想以 <code>'lumen/public/'</code> 作为首页 URI 显然是不可以的，建议使用 <code>'lumen/pulbic/index'</code> 作为首页。如同上面代码定义的路由规则那样。</p>

<p>因为，无论你在路由规则的字符串末尾加了多少个斜杠， <code>$this-&gt;routes</code> 的键是不会带有斜杠的，最终还是不能匹配的。原因在框架源代码中 <code>lumen/vendor/laravel/lumen-framework/src/Application.php</code>：</p>

<pre><code>php</code><code>    /**
     * Add a route to the collection.
     *
     * @param  string  $method
     * @param  string  $uri
     * @param  mixed  $action
     */
    protected function addRoute($method, $uri, $action)
    {
        $action = $this-&gt;parseAction($action);

        $uri = $uri === '/' ? $uri : '/'.trim($uri, '/');

        if (isset($action['as'])) {
            $this-&gt;namedRoutes[$action['as']] = $uri;
        }

        if (isset($this-&gt;groupAttributes)) {
            if (isset($this-&gt;groupAttributes['prefix'])) {
                $uri = rtrim('/'.trim($this-&gt;groupAttributes['prefix'], '/').$uri, '/');
            }

            $action = $this-&gt;mergeGroupAttributes($action);
        }

        $this-&gt;routes[$method.$uri] = ['method' =&gt; $method, 'uri' =&gt; $uri, 'action' =&gt; $action];
    }
</code></pre>

<p>对，就是它：<code>$uri = $uri === '/' ? $uri : '/'.trim($uri, '/');</code>。<br>
所有，URI 末尾还是不带斜杠的好。</p>

2015年五月3日下午 1:07:20
求大神帮助！！！
<div class="markdown-text"><p><img src="//dn-cnode.qbox.me/FhGHAl_QvtvT4bEN1X7AXAZj9SxE" alt="Screen Shot 2015-05-03 at 1.00.20 PM.png"></p>
<p>代码：
<img src="//dn-cnode.qbox.me/FkwfMd12ADPzqCJKH9waykSCKy1G" alt="Screen Shot 2015-05-03 at 1.00.41 PM.png"></p>
<p>非常感谢</p>
</div>

2015年五月3日中午 12:25:25
node express4.0 遇到一个偶发的问题，post有时会得到404 not found报错
<div class="markdown-text"><p>在我编程OA系统中出现了一个偶发的问题，让我头痛。一个简单的数据update功能，在大多数情况下工作正常，偶尔会发生提交post数据不成功，浏览器报404 Not Found, 但nodejs没有报错，log里也没有记录。为此，我升级了mongodb到3.0， 也升级express到4.12.3，但这个问题还是存在。请各位高手帮忙诊断一下：</p>
<p>以下是Chrome控制台的记录404 Not Found信息：</p>
<pre class="prettyprint"><code>Headers
General
Remote Address:123.56.132.188:2000
Request URL:http://ff.yinova.cn:2000/kafapiaoDetail
Request Method:POST
Status Code:404 Not Found

Response Headers
Connection:keep-alive
Content-Length:28
Content-Type:text/html; charset=utf-8
Date:Sun, 03 May 2015 03:07:38 GMT
ETag:W/&quot;vXOLRVt8K03ixCcpAP5ICQ==&quot;
X-Content-Type-Options:nosniff
X-Powered-By:Express

Request Headers
POST /kafapiaoDetail HTTP/1.1
Host: ff.yinova.cn:2000
Connection: keep-alive
Content-Length: 588
Cache-Control: max-age=0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
Origin: http://ff.yinova.cn:2000
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2272.101 Safari/537.36
Content-Type: application/x-www-form-urlencoded
Referer: http://ff.yinova.cn:2000/k/554203dba9e620351d690c70
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.6
Cookie: connect.sid=s%3AJqC8e7eTZtAFxqRmX5juQ5t0.KkHhy5TSbYJF1stJm8zZGpP6sfyP2J92t2MN7a7u2tY

Form Data
item:XXXX投资有限公司
unit:会议费
price:343177
client:XX
address:北京市朝阳区XXXXXXXXXXXXXXX层
remark:发票备注
company:1
status:5
bank:1
</code></pre><hr>
<p>过了一分钟，我再次提交这个数据，就成功了。 以下是Chrome控制台的记录信息：</p>
<pre class="prettyprint"><code>Headers

General
Remote Address:123.56.132.188:2000
Request URL:http://ff.yinova.cn:2000/kafapiaoDetail
Request Method:POST
Status Code:302 Moved Temporarily

Response Headers
Connection:keep-alive
Content-Length:68
Content-Type:text/html; charset=utf-8
Date:Sun, 03 May 2015 03:24:28 GMT
Location:/kList
Vary:Accept
X-Powered-By:Express

Request Headers
Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
Accept-Encoding:gzip, deflate
Accept-Language:zh-CN,zh;q=0.8,zh-TW;q=0.6
Cache-Control:max-age=0
Connection:keep-alive
Content-Length:588
Content-Type:application/x-www-form-urlencoded
Cookie:connect.sid=s%3AJqC8e7eTZtAFxqRmX5juQ5t0.KkHhy5TSbYJF1stJm8zZGpP6sfyP2J92t2MN7a7u2tY
Host:ff.yinova.cn:2000
Origin:http://ff.yinova.cn:2000
Referer:http://ff.yinova.cn:2000/k/554203dba9e620351d690c70
User-Agent:Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2272.101 Safari/537.36

Form Data
item:XXXX投资有限公司
unit:会议费
price:343177
client:XX
address:北京市朝阳区XXXXXXXXXXXXXXX层
remark:发票备注
company:1
status:5
bank:1
oid:554203dba9e620351d690c70
</code></pre><hr>
<p>router.js 的post代码：</p>
<pre class="prettyprint"><code>router.post(&quot;/kafapiaoDetail&quot;,function(req,res) {
  var currentUser = req.session.user;
  var t = new Date();
  var y = t.getFullYear();
  var m = t.getMonth()+1;
  var d = t.getDate();
  var h = t.getHours();
  if (h &lt; 10) {h = &#x27;0&#x27;+h;}
  var minute = t.getMinutes();
  if (minute&lt;10) { min = &#x27;0&#x27;+min;}
  var insert_time = y + &#x27;-&#x27; + m + &#x27;-&#x27; +d +&#x27; &#x27;+ h +&#x27;:&#x27;+minute;
  var status = req.body.status;
  var auditor = null;
  var auditor_time = null;
  var accountant = null;
  var accountant_time = null;
  if(currentUser.type === &#x27;3&#x27;) {
    auditor = currentUser.username;
    auditor_time = insert_time;
  }
  if(currentUser.type === &#x27;2&#x27;) {
    accountant = currentUser.username;
    accountant_time = insert_time;
  }
  var newAccount = {};
  newAccount.oid = req.body.oid;
  newAccount.item = req.body.item;
  newAccount.price = req.body.price;
  newAccount.unit = req.body.unit;
  newAccount.company = req.body.company;
  newAccount.status = status;
  newAccount.remark = req.body.remark;
  newAccount.address = req.body.address;
  newAccount.mobile = req.body.mobile;
  newAccount.client = req.body.client;
  newAccount.username = currentUser.username;
  newAccount.auditor = auditor;
  newAccount.auditor_time = auditor_time;
  newAccount.accountant = accountant;
  newAccount.accountant_time = accountant_time;
  newAccount.bank =req.body.bank;
  console.log(&#x27;kafapiaoDetail Update:&#x27;);  
  console.log(newAccount); 
  Accounting.update(newAccount.oid, newAccount, function(err, result) {
      console.log(&#x27;update result:&#x27;);
      if (err) {
        req.flash(&#x27;error&#x27;, err);
        return res.redirect(&#x27;/k/&#x27;+newAccount.oid); 
      }
      if (result) {
        req.flash(&#x27;success&#x27;,&#x27;数据已更新！&#x27;);
        return res.redirect(&#x27;/kList&#x27;);
      }
      req.flash(&#x27;error&#x27;, &#x27;数据更新失败，请稍后再试！&#x27;);
      res.redirect(&#x27;/k/&#x27;+newAccount.oid); 
  });   
});
</code></pre><hr>
<p>以下是jade页面代码：</p>
<pre class="prettyprint"><code>extends bloglayout
block bcontent
  include narbar.jade
  include alert.jade
  form(method=&#x27;post&#x27; role=&#x27;form&#x27; action=&#x27;/kafapiaoDetail&#x27;)
    h2.form-signin-heading 发票审批
    - if(account.length&gt;0||typeof(account) != &#x27;undefined&#x27;)
      - for(var i=0; i&lt;account.length; i++)
        div.input-group  
          span.input-group-addon 抬头
          input(id=&#x27;item&#x27; name=&#x27;item&#x27; type=&#x27;text&#x27; class=&#x27;form-control&#x27; value=account[i].item)
        div.input-group  
          span.input-group-addon 项目
          input(id=&#x27;unit&#x27; name=&#x27;unit&#x27; type=&#x27;text&#x27; class=&#x27;form-control&#x27; value=account[i].unit)
        div.input-group  
          span.input-group-addon 金额
          input(id=&#x27;price&#x27; name=&#x27;price&#x27; type=&#x27;text&#x27; class=&#x27;form-control&#x27; value=account[i].price)
        div.input-group  
          span.input-group-addon 收件人
          input(id=&#x27;client&#x27; name=&#x27;client&#x27; type=&#x27;text&#x27; class=&#x27;form-control&#x27; value=account[i].client)
        div.input-group  
          span.input-group-addon 手机
          input(id=&#x27;mobile&#x27; name=&#x27;mobile&#x27; type=&#x27;text&#x27; class=&#x27;form-control&#x27; value=account[i].mobile)
        div.input-group  
          span.input-group-addon 地址
          input(id=&#x27;address&#x27; name=&#x27;address&#x27; type=&#x27;text&#x27; class=&#x27;form-control&#x27; value=account[i].address)
        div.input-group  
          span.input-group-addon 备注
          input(id=&#x27;remark&#x27; name=&#x27;remark&#x27; type=&#x27;text&#x27; class=&#x27;form-control&#x27; value=account[i].remark)
        div.input-group  
          span.input-group-addon 公司
          select(id=&#x27;company&#x27; name=&#x27;company&#x27; class=&#x27;form-control&#x27;)
            - if(account[i].company === &#x27;1&#x27;)
              option(value=&#x27;0&#x27;) 请选择
              option(value=&#x27;1&#x27;  selected=&#x27;selected&#x27;) 云动
              option(value=&#x27;2&#x27;) 会贰
              option(value=&#x27;3&#x27;) 会小二
              option(value=&#x27;4&#x27;) 会万
            - else if(account[i].company === &#x27;2&#x27;)
              option(value=&#x27;0&#x27;) 请选择
              option(value=&#x27;1&#x27;) 云动
              option(value=&#x27;2&#x27;  selected=&#x27;selected&#x27;) 会贰
              option(value=&#x27;3&#x27;) 会小二
              option(value=&#x27;4&#x27;) 会万
            - else if(account[i].company === &#x27;3&#x27;)
              option(value=&#x27;0&#x27;) 请选择
              option(value=&#x27;1&#x27;) 云动
              option(value=&#x27;2&#x27;) 会贰
              option(value=&#x27;3&#x27; selected=&#x27;selected&#x27;) 会小二
              option(value=&#x27;4&#x27;) 会万
            - else if(account[i].company === &#x27;4&#x27;)
              option(value=&#x27;0&#x27;) 请选择
              option(value=&#x27;1&#x27;) 云动
              option(value=&#x27;2&#x27;) 会贰
              option(value=&#x27;3&#x27;) 会小二
              option(value=&#x27;4&#x27; selected=&#x27;selected&#x27;) 会万
            - else
              option(value=&#x27;0&#x27; selected=&#x27;selected&#x27;) 请选择
              option(value=&#x27;1&#x27;) 云动
              option(value=&#x27;2&#x27;) 会贰
              option(value=&#x27;3&#x27;) 会小二
              option(value=&#x27;4&#x27;) 会万
        div.input-group  
          span.input-group-addon 状态
          select(id=&#x27;status&#x27; name=&#x27;status&#x27; class=&#x27;form-control&#x27;)
            - if(account[i].status === &#x27;1&#x27;)
              option(value=&#x27;0&#x27;) 未开票取消
              option(value=&#x27;2&#x27;) 已开票
              option(value=&#x27;3&#x27;) 当月退票
              option(value=&#x27;4&#x27;) 跨月退票
              //- if(user.type === &#x27;3&#x27;)
              option(value=&#x27;1&#x27; selected=&#x27;selected&#x27;) 新建申请
              option(value=&#x27;5&#x27;) 已审批
            - if(account[i].status === &#x27;5&#x27;)
              option(value=&#x27;0&#x27;) 未开票取消
              option(value=&#x27;2&#x27;) 已开票
              option(value=&#x27;3&#x27;) 当月退票
              option(value=&#x27;4&#x27;) 跨月退票
              //- if(user.type === &#x27;3&#x27;)
              option(value=&#x27;1&#x27;) 新建申请
              option(value=&#x27;5&#x27; selected=&#x27;selected&#x27;) 已审批
            - if(account[i].status === &#x27;2&#x27;)
              option(value=&#x27;0&#x27;) 未开票取消
              option(value=&#x27;2&#x27; selected=&#x27;selected&#x27;) 已开票
              option(value=&#x27;3&#x27;) 当月退票
              option(value=&#x27;4&#x27;) 跨月退票
              //- if(user.type === &#x27;3&#x27;)
              option(value=&#x27;1&#x27;) 新建申请
              option(value=&#x27;5&#x27;) 已审批       
            - if(account[i].status === &#x27;3&#x27;)
              option(value=&#x27;0&#x27;) 未开票取消
              option(value=&#x27;2&#x27;) 已开票
              option(value=&#x27;3&#x27; selected=&#x27;selected&#x27;) 当月退票
              option(value=&#x27;4&#x27;) 跨月退票
              //- if(user.type === &#x27;3&#x27;)
              option(value=&#x27;1&#x27;) 新建申请
              option(value=&#x27;5&#x27;) 已审批
            - if(account[i].status === &#x27;4&#x27;)
              option(value=&#x27;0&#x27;) 未开票取消
              option(value=&#x27;2&#x27;) 已开票
              option(value=&#x27;3&#x27;) 当月退票
              option(value=&#x27;4&#x27; selected=&#x27;selected&#x27;) 跨月退票
              //- if(user.type === &#x27;3&#x27;)
              option(value=&#x27;1&#x27;) 新建申请
              option(value=&#x27;5&#x27;) 已审批            
            - if(account[i].status === &#x27;0&#x27;)
              option(value=&#x27;0&#x27; selected=&#x27;selected&#x27;) 未开票取消
              option(value=&#x27;2&#x27;) 已开票
              option(value=&#x27;3&#x27;) 当月退票
              option(value=&#x27;4&#x27;) 跨月退票
              //- if(user.type === &#x27;3&#x27;)
              option(value=&#x27;1&#x27;) 新建申请
              option(value=&#x27;5&#x27;) 已审批     
        div.input-group  
          span.input-group-addon 类型
          select(id=&#x27;bank&#x27; name=&#x27;bank&#x27; class=&#x27;form-control&#x27;)
            - if(account[i].bank === &#x27;2&#x27;)
              option(value=&#x27;1&#x27;) 增值税普票
              option(value=&#x27;2&#x27; selected=&#x27;selected&#x27;) 增值税专票
            - else
              option(value=&#x27;1&#x27; selected=&#x27;selected&#x27;) 增值税普票
              option(value=&#x27;2&#x27;) 增值税专票
        input(type=&#x27;text&#x27; class=&#x27;input_hide&#x27; id=&#x27;oid&#x27; name=&#x27;oid&#x27; value=account[i]._id readonly hidden)
        button(class=&#x27;btn btn-lg btn-primary&#x27; type=&#x27;submit&#x27;) 修改
        a(href=&#x27;/kList&#x27; class=&#x27;btn btn-default&#x27; type=&#x27;button&#x27;) 返回
</code></pre></div>

2015年五月3日中午 12:01:09
关于rsyslog和loganalyzer使用
<p>系统日志太多太分散的话就需要整合，并且分析，所以就有了这样一套东西，这样就大大的减轻了系统管理员的压力，不过现在这篇只是小试牛刀，很多应用功能还是没有用到，例如自定义日志收集过滤， 日志分析图表，等等，不过原理大致都基本如下，是可以举一反三的。</p>

<p>关于rsyslog和loganalyzer的配置简略架构流程图<br><img src="http://source1.godblessyuan.com/blog_rsyslog_loganalyzer_20150502.jpg" alt=""></p>

<h1>一、rsyslog</h1>

<h2>【客户端】rsyslog配置</h2>

<h3>1.安装rsyslog</h3>

<pre><code>yum -y install rsyslog
</code></pre>

<h3>2.配置rsyslog</h3>

<pre><code>/etc/rsyslog.conf
</code></pre>

<p>配置很多，但是只需要注意几个</p>

<pre><code># rsyslog v5 configuration file

# For more information see /usr/share/doc/rsyslog-*/rsyslog_conf.html
# If you experience problems, see http://www.rsyslog.com/doc/troubleshoot.html

#### MODULES ####

$ModLoad imuxsock # provides support for local system logging (e.g. via logger command)  
$ModLoad imklog   # provides kernel logging support (previously done by rklogd)  
#$ModLoad immark  # provides --MARK-- message capability

# Provides UDP syslog reception
$ModLoad imudp  --注意这个
$UDPServerRun 514   --注意这个

# Provides TCP syslog reception
#$ModLoad imtcp
#$InputTCPServerRun 514


#### GLOBAL DIRECTIVES ####

# Use default timestamp format
$ActionFileDefaultTemplate RSYSLOG_TraditionalFileFormat

# File syncing capability is disabled by default. This feature is usually not required,
# not useful and an extreme performance hit
#$ActionFileEnableSync on

# Include all config files in /etc/rsyslog.d/
$IncludeConfig /etc/rsyslog.d/*.conf


#### RULES ####

# Log all kernel messages to the console.
# Logging much else clutters up the screen.
#kern.*                                                 /dev/console

# Log anything (except mail) of level info or higher.
# Don't log private authentication messages!
#*.info;mail.none;authpriv.none;cron.none                /var/log/messages
*.*                                                      @主rsyslog服务器ip或者host   --注意这个

# The authpriv file has restricted access.
authpriv.*                                              /var/log/secure

# Log all the mail messages in one place.
mail.*                                                  -/var/log/maillog


# Log cron stuff
cron.*                                                  /var/log/cron

# Everybody gets emergency messages
*.emerg                                                 *

# Save news errors of level crit and higher in a special file.
uucp,news.crit                                          /var/log/spooler

# Save boot messages also to boot.log
local7.*                                                /var/log/boot.log


# ### begin forwarding rule ###
# The statement between the begin ... end define a SINGLE forwarding
# rule. They belong together, do NOT split them. If you create multiple
# forwarding rules, duplicate the whole block!
# Remote Logging (we use TCP for reliable delivery)
#
# An on-disk queue is created for this action. If the remote host is
# down, messages are spooled to disk and sent when it is up again.
#$WorkDirectory /var/lib/rsyslog # where to place spool files
#$ActionQueueFileName fwdRule1 # unique name prefix for spool files
#$ActionQueueMaxDiskSpace 1g   # 1gb space limit (use as much as possible)
#$ActionQueueSaveOnShutdown on # save messages to disk on shutdown
#$ActionQueueType LinkedList   # run asynchronously
#$ActionResumeRetryCount -1    # infinite retries if host is down
# remote host is: name/ip:port, e.g. 192.168.0.1:514, port optional
#*.* @@remote-host:514
# ### end of the forwarding rule ###
</code></pre>

<blockquote>
  <p>1.$ModLoad imudp和$UDPServerRun 514 开启rsyslog的日志远程传输，使用udp模式，当然也可以使用tcp模式，而且tcp也比udp更可靠，防止日志在传输过程丢失，只是需要建立稳定连接，消耗资源，各有所长，各有所需。</p>
  
  <p>2.#<em>.info;mail.none;authpriv.none;cron.none                /var/log/messages 注释掉这个语句，改为</em>.*                                                         @主rsyslog服务器ip或者host，这是为了配置rsyslog日志传输的目标，另外rsyslog的格式是分为2个方面的，一个是facitlity一个是priority，这个需要一点篇幅来说明，详细可以参阅科普时间或者官网，目前现在这个配置的意思是将所有级别的日志都传输到某个服务器。</p>
  
  <p>3.客户端的rsyslog只需要配置这样就足够了。需要注意的是，如果开启了防火墙的话，那么记得514端口是rsyslog的传输端口，也要放开访问。</p>
</blockquote>

<h3>3.重启rsyslog服务</h3>

<pre><code>service rsyslog restart
</code></pre>

<h2>【服务端】rsyslog配置</h2>

<h3>1.安装rsyslog</h3>

<pre><code>yum -y install rsyslog
</code></pre>

<h3>2.配置rsyslog存储数据库（数据库的安装在下面那里一起写了）</h3>

<pre><code>yum -y install rsyslog-mysql 
</code></pre>

<h2>导入创库sql</h2>

<pre><code>cd /usr/share/doc/rsyslog-mysql-5.8.10/
[root@localhost rsyslog-mysql-5.8.10]# ls
createDB.sql
[root@localhost rsyslog-mysql-5.8.10]# mysql -u root -p &lt; createDB.sql 
</code></pre>

<p>这个sql会自动帮你创建rsyslog存储在mysql中的数据的表，等下可以直接被loganalyzer读取数据，然后使用。</p>

<h2>连接数据库检查</h2>

<pre><code>mysql -u root -p
Enter password: 
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 7
Server version: 5.1.73 Source distribution

Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

mysql&gt; show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| Syslog             |
| mysql              |
| test               |
+--------------------+
4 rows in set (0.00 sec)


mysql&gt; use Syslog
Reading table information for completion of table and column names
You can turn off this feature to get a quicker startup with -A

Database changed
mysql&gt; show tables;
+------------------------+
| Tables_in_Syslog       |
+------------------------+
| SystemEvents           |
| SystemEventsProperties |
+------------------------+
2 rows in set (0.00 sec)
</code></pre>

<h2>配置rsyslog连接mysql账号和密码和授权</h2>

<pre><code>mysql&gt; grant all on Syslog.* to 'rsysloga'@'localhost' identified by 'rsyslogp';  #设置用户访问数据库服务器中Syslog数据库的用户名和密码，因为rsyslog服务端和mysql数据库是在同一台机器上，所以只允许本机访问就可以了
Query OK, 0 rows affected (0.00 sec)

flush privileges;  #刷新权限，及时生效
</code></pre>

<h3>3.配置服务端的rsyslog.conf（数据库的安装在下面那里一起写了）</h3>

<pre><code>cat /etc/rsyslog.conf 
# rsyslog v5 configuration file

# For more information see /usr/share/doc/rsyslog-*/rsyslog_conf.html
# If you experience problems, see http://www.rsyslog.com/doc/troubleshoot.html

#### MODULES ####

$ModLoad imuxsock # provides support for local system logging (e.g. via logger command)
$ModLoad imklog   # provides kernel logging support (previously done by rklogd)
#$ModLoad immark  # provides --MARK-- message capability
$ModLoad ommysql    --注意这个

# Provides UDP syslog reception
$ModLoad imudp      --注意这个
$UDPServerRun 514   --注意这个

# Provides TCP syslog reception
#$ModLoad imtcp
#$InputTCPServerRun 514


#### GLOBAL DIRECTIVES ####

# Use default timestamp format
$ActionFileDefaultTemplate RSYSLOG_TraditionalFileFormat

# File syncing capability is disabled by default. This feature is usually not required,
# not useful and an extreme performance hit
#$ActionFileEnableSync on

# Include all config files in /etc/rsyslog.d/
$IncludeConfig /etc/rsyslog.d/*.conf


#### RULES ####

# Log all kernel messages to the console.
# Logging much else clutters up the screen.
#kern.*                                                 /dev/console

# Log anything (except mail) of level info or higher.
# Don't log private authentication messages!
#*.info;mail.none;authpriv.none;cron.none                /var/log/messages      
*.*                                                     :ommysql:127.0.0.1,Syslog,rsysaloga,rsyslogp        --注意这个 

# The authpriv file has restricted access.
authpriv.*                                              /var/log/secure

# Log all the mail messages in one place.
mail.*                                                  -/var/log/maillog


# Log cron stuff
cron.*                                                  /var/log/cron

# Everybody gets emergency messages
*.emerg                                                 *

# Save news errors of level crit and higher in a special file.
uucp,news.crit                                          /var/log/spooler

# Save boot messages also to boot.log
local7.*                                                /var/log/boot.log


# ### begin forwarding rule ###
# The statement between the begin ... end define a SINGLE forwarding
# rule. They belong together, do NOT split them. If you create multiple
# forwarding rules, duplicate the whole block!
# Remote Logging (we use TCP for reliable delivery)
#
# An on-disk queue is created for this action. If the remote host is
# down, messages are spooled to disk and sent when it is up again.
#$WorkDirectory /var/lib/rsyslog # where to place spool files
#$ActionQueueFileName fwdRule1 # unique name prefix for spool files
#$ActionQueueMaxDiskSpace 1g   # 1gb space limit (use as much as possible)
#$ActionQueueSaveOnShutdown on # save messages to disk on shutdown
#$ActionQueueType LinkedList   # run asynchronously
#$ActionResumeRetryCount -1    # infinite retries if host is down
# remote host is: name/ip:port, e.g. 192.168.0.1:514, port optional
#*.* @@remote-host:514
# ### end of the forwarding rule ###
</code></pre>

<blockquote>
  <p>1.增加了$ModLoad ommysql这个模块，这个就是rsyslog连接mysql使用的模块</p>
  
  <p>2.<em>.</em>                                                     :ommysql:127.0.0.1,Syslog,rsysaloga,rsyslogp 这里意思是说使用某个可以连接mysql的账号和密码，连接mysql，将数据传输到mysql数据库里面去。</p>
  
  <p>3.udp传输配置依然要开启，那是因为rsyslog客户端会将日志以udp的方式传输到rsyslog服务端，所以双方都要开启同样的传输方式才可以完成传输。</p>
  
  <p>4.需要注意的是，如果开启了防火墙的话，那么记得514端口是rsyslog的传输端口，也要放开访问。</p>
</blockquote>

<h3>4.重启rsyslog服务</h3>

<pre><code>service rsyslog restart
</code></pre>

<p>至此，rsyslog部分已经完成配置，若要检查是否配置成功，可以检查数据库里是否有数据即可。</p>

<pre><code>mysql&gt; select * from SystemEvents;
</code></pre>

<h1>二、loganalyzer</h1>

<p>可以理解为loganalyzer其实就是一个web平台来展现日志数据的而已。</p>

<h3>1.下载并安装http+php+mysql套件</h3>

<pre><code>yum -y install httpd php php-mysql php-gd mysql mysql-server

httpd用来提供web服务
php使apache支持php，因为loganalyzer是用php编写
php-mysql用于loganalyzer连接数据库
php-gd用于绘图
mysql 是loganalyzer存储数据的地方
</code></pre>

<blockquote>
  <p>设置MySQL的root用户设置密码，因为MySQL被安装时，它的root用户时没有设置密码的，所以可以直接连或者设置一个，但是不影响我们这次配置任务。mysql需要启动，这个需要注意。</p>
</blockquote>

<h3>2.配置apache+php，并启动apache和mysql</h3>

<p>因为yum安装的关系，所有一切都已经配置好了</p>

<pre><code>如：grep -E 'Document|Listen' /etc/httpd/conf/httpd.conf |grep -v '^#'  
Listen 80
DocumentRoot "/var/www/html"

如：grep -v '^#' /etc/httpd/conf.d/php.conf 
&lt;IfModule prefork.c&gt;
  LoadModule php5_module modules/libphp5.so
&lt;/IfModule&gt;
&lt;IfModule worker.c&gt;
  LoadModule php5_module modules/libphp5-zts.so
&lt;/IfModule&gt;

AddHandler php5-script .php
AddType text/html .php

DirectoryIndex index.php    
</code></pre>

<p>启动httpd</p>

<pre><code>service httpd start
</code></pre>

<p>启动mysql</p>

<pre><code>service mysqld start
</code></pre>

<h3>3.下载loganalyzer</h3>

<p>下载地址：<a rel="nofollow" href="http://download.adiscon.com/loganalyzer/loganalyzer-3.6.6.tar.gz"></a><a rel="nofollow" href="http://download.adiscon.com/loganalyzer/loganalyzer-3.6.6.tar.gz">http://download.adiscon.com/loganalyzer/loganalyzer-3.6.6.tar.gz</a></p>

<p>将其放置到配置好的apache的web目录里面/var/www/html</p>

<pre><code>tar -zxpf loganalyzer-3.6.6.tar.gz -C /var/www/html 

cd /var/www/html/
[root@localhost html]# ls
loganalyzer-3.6.6
</code></pre>

<p>授权目录</p>

<pre><code>chown -R apache.apache /var/www/html/loganalyzer-3.6.6/
</code></pre>

<h3>4.配置loganalyzer</h3>

<p>创建loganalyzer数据库和访问账号密码和授权</p>

<pre><code>mysql&gt; create database loganalyzer;
Query OK, 1 row affected (0.04 sec)
mysql&gt; grant all on loganalyzer.* to loga@'localhost' identified by 'logp';
Query OK, 0 rows affected (0.00 sec)
mysql&gt; flush privileges;
Query OK, 0 rows affected (0.00 sec)
</code></pre>

<p>生成config.php</p>

<pre><code>cd /var/www/html/loganalyzer-3.6.6/contrib

chmod +x *

./configure.sh 
</code></pre>

<p>在当前目录会生成config.php文件，然后将其放置到src目录去</p>

<pre><code>cp config.php /var/www/html/loganalyzer-3.6.6/src/
</code></pre>

<p>在浏览器访问这台主机的80端口</p>

<p><a rel="nofollow" href="http://%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84ip/loganalyzer-3.6.6/src/install.php">http://服务端的ip/loganalyzer-3.6.6/src/install.php</a></p>

<p><img src="http://source1.godblessyuan.com/blog_logrotate_20150501.jpg" alt=""></p>

<p>备注：</p>

<pre><code>1.step 2 会检查config.php的写入权限，如果没有请授权一下， chmod +w config.php
2.step 3 选择enable user database，使用自定义数据库，然后填写数据库访问信息，这里的数据库是指loganalyzer的用户数据库，而不是rsyslog日志存储的数据库，这里是需要注意的。并且选取require user to be login。
3.step 5 会将loganalyzer的相关用户表写入到数据库，可以检查loganalyzer的数据库就可以看到了。
4.step 6 配置loganalyzer的管理员账号，登录loganalyzer界面使用的。
5.step 7 是配置rsyslog的日志存储数据库的访问方法，在source type选择 mysql native，然后填写mysql的访问信息，记住，这里是rsyslog的日志存储数据库，不是loganalyzer的用户数据库。
6.完成后会自动跳转提示登录，登陆后就可以看到数据了。
</code></pre>

<h1>三、科普时间</h1>

<h3>1.关于rsyslog的日志规则facitlity和priority</h3>

<pre><code>###rsyslog.conf中日志规则的定义的格式
facitlity.priority          Target
#facility: 日志设备(可以理解为日志类型):
==============================================================
auth         #pam产生的日志，认证日志
authpriv     #ssh,ftp等登录信息的验证信息，认证授权认证
cron         #时间任务相关
kern         #内核
lpr          #打印
mail         #邮件
mark(syslog) #rsyslog服务内部的信息,时间标识
news         #新闻组
user         #用户程序产生的相关信息
uucp         #unix to unix copy, unix主机之间相关的通讯
local 1~7    #自定义的日志设备
===============================================================
#priority: 级别日志级别:
=====================================================================
debug           #有调式信息的，日志信息最多
info            #一般信息的日志，最常用
notice          #最具有重要性的普通条件的信息
warning, warn   #警告级别
err, error      #错误级别，阻止某个功能或者模块不能正常工作的信息
crit            #严重级别，阻止整个系统或者整个软件不能正常工作的信息
alert           #需要立刻修改的信息
emerg, panic    #内核崩溃等严重信息
###从上到下，级别从低到高，记录的信息越来越少，如果设置的日志内性为err，则日志不会记录比err级别低的日志，只会记录比err更高级别的日志，也包括err本身的日志。
=====================================================================
Target：
  #文件, 如/var/log/messages
  #用户， root，*（表示所有用户）
  #日志服务器，@172.16.22.1
  #管道        | COMMAND
</code></pre>

<h3>2.如果日志数量太大，内容太多，可以进行过滤记录日志</h3>

<p>简单的方法可以在rsyslog客户端上的配置</p>

<pre><code>:msg, !contains, "informational"  
*.*                 @主rsyslog服务器ip或者host
</code></pre>

<p>在传输配置的上一行增加一个过滤配置，格式是严格的，一定要在上一行增加过滤配置，这里的意思是日志内容出现informational的就不记录。详细的过滤方式在官网上有说，需要的话就要慢慢按照他的方式来使用。</p>

<hr>
<p>参考文档：</p>

<p>1.<a rel="nofollow" href="http://litaotao.blog.51cto.com/6224470/1283871"></a><a rel="nofollow" href="http://litaotao.blog.51cto.com/6224470/1283871">http://litaotao.blog.51cto.com/6224470/1283871</a></p>

<p>2.<a rel="nofollow" href="http://ftp.ics.uci.edu/pub/centos0/ics-custom-build/BUILD/rsyslog-3.19.7/doc/rsyslog_conf.html"></a><a rel="nofollow" href="http://ftp.ics.uci.edu/pub/centos0/ics-custom-build/BUILD/rsyslog-3.19.7/doc/rsyslog_conf.html">http://ftp.ics.uci.edu/pub/centos0/ics-custom-build/BUILD/rsyslog-3.19...</a></p>

<p>3.<a rel="nofollow" href="http://www.cnblogs.com/tobeseeker/archive/2013/03/10/2953250.html"></a><a rel="nofollow" href="http://www.cnblogs.com/tobeseeker/archive/2013/03/10/2953250.html">http://www.cnblogs.com/tobeseeker/archive/2013/03/10/2953250.html</a></p>

<hr>
<p>原文链接：<br><a rel="nofollow" href="http://www.godblessyuan.com/2015/05/02/rsyslog_loganalyzer_setting/">http://www.godblessyuan.com/2015/05/02/rsyslog_loganalyzer_setting/</a></p>

2015年五月3日凌晨 1:14:59
【译】编写更好的CSS必备的40个工具
<p>众所周知，CSS是非常棒的，它使网站看起来很漂亮，可以为网站添加动画，并让呈现和内容分离。去了解CSS的一切是非常难做到的，它只会变得更加困难,因为我们想让我们的代码跨浏览器兼容。<br>
这里介绍了很多第三方工具，从简化工作流程到生成真正的CSS，这些工具都提供了我们需要的代码，并且比我们自己写出的代码运行的更快。</p>

<h3>Pure</h3>

<p><a rel="nofollow" href="http://purecss.io/">Pure</a>并不是一个框架。相反，它只是集成一些已经应用到模块中的CSS代码，方便我们使用。只需要为你的项目抓取你想要的那部分CSS代码。当然，所有组件都是可用的。Pure中包含了网格系统、按钮、表格、表单和菜单，这些都是建立在normalize.css上的。</p>

<h3>Magic Animations CSS3</h3>

<p>Magic Animations CSS3集成了 <a rel="nofollow" href="http://www.minimamente.com/example/magic_animations/">CSS3 Animations</a>，可以被应用在任何元素上，包含元素替换、滑出、变形和消褪等效果</p>

<h3>Jeet Grid System</h3>

<p><a rel="nofollow" href="http://jeet.gs/">Jeet</a>和semantic.gs有点类似，是以SASS为基础的网格系统。你可以在CSS中定义列（有时定义行），而不是为标记元素添加Class。Jeet使响应式布局更加容易，并进一步分离了内容和呈现。</p>

<h3>10 Pure CSS Flat Mobile Devices</h3>

<p>一个叫Oleg的人用纯CSS重绘并模拟了<a rel="nofollow" href="http://marvelapp.github.io/devices.css/">10种不同的移动设备</a>（包括iPhone 6, iPad Mini, Nexus 5, and Lumia 920）</p>

<h3>CodyHouse</h3>

<p>可以给你的网站添加不相关的、独立组件的<a rel="nofollow" href="http://codyhouse.co/">一个库</a>。CodyHouse是用HTML、CSS和JavaScript建立的，你可以选择各种各样的导航、视差效果、分页、模态窗口、页面布局等等，每一个组件独有让你快速使用的教程。</p>

<h3>Ratchet</h3>

<p>如果你使用HTML、CSS和JavaScript是移动APP，<a rel="nofollow" href="http://goratchet.com/">Ratchet</a>应该是一个不错的框架。每一个UI组件都是针对移动设备定制的，并且它有很多你在传统的HTML/CSS框架中看不到的功能。组件的默认效果都是非常棒的。</p>

<h3>Animo.JS</h3>

<p><a rel="nofollow" href="http://labs.bigroomstudios.com/libraries/animo-js">Animo</a>基于JQuery，能帮你更好的触发CSS动画。你可以叠加动画,或者第一次完成后触发第二个动画,并能同时利用CSS动画提供的硬件加速优点。</p>

<h3>Adobe Extract</h3>

<p>将一个Photoshop图层样式文件转换为CSS是一件很痛苦的事。幸运的是,Adobe做了一个<a rel="nofollow" href="http://www.adobe.com/go/extract_tryitnow_en">工具</a>(运行在浏览器中),允许你选择某个图层,将其属性转换为CSS代码。您也可以选择任何在线网站在PSD文件中使用的文本。</p>

<h3>Sculpt</h3>

<p><a rel="nofollow" href="https://www.heartinternet.uk/sculpt">Sculpt</a>基于SASS，是一个很好的框架。与其他已经发布的框架相比，Sculpt支持被遗弃的低版本浏览器。如果你用SASS开发移动优先的网站，并想要网站正常运行在低版本的IE上，可以考虑Sculpt。</p>

<h3>CSS3 Generator</h3>

<p>一个简单通用的<a rel="nofollow" href="http://css3generator.com/">CSS3属性</a>生成器。它不是很新，但是当你忘了一些精确的语法时，它是非常有用的。</p>

<h3>Bourbon Neat</h3>

<p>SASS的最爱了，<a rel="nofollow" href="http://neat.bourbon.io/">Bourbon Neat</a>是一个简单的语义网格系统，可以单独使用，但它的设计是用 <a rel="nofollow" href="http://bourbon.io/">Bourbon</a> mixin库。</p>

<h3>Enjoy CSS</h3>

<p><a rel="nofollow" href="http://enjoycss.com/">Enjoy CSS</a>也是一个CSS3生成器，但有趣的是，它不仅仅是生成CSS3-related代码,你还可以选择你想要应用的元素:一个div,文本输入,一个按钮,等等，用一种简单可视的方式得到你想要的确切效果。</p>

<h3>Keyframer</h3>

<p>从这里开始创建你的<a rel="nofollow" href="http://alexberg.in/keyframer/">keyframe-based CSS animations</a>。只需要去这个网站学习一些教程。</p>

<h3>Gumby</h3>

<p><a rel="nofollow" href="http://gumbyframework.com/">Gumby</a>是一个HTML/CSS框架，为那些喜欢在Ruby环境中工作的人设计的。你可以单独下载它,当然,但也打包为一个Ruby gem,Ruby gem是由那些这种技术的人创建的。</p>

<h3>CSShake</h3>

<p>这有更多的<a rel="nofollow" href="http://despreneur.com/20-fresh-css-tutorials-and-tools-to-try/">CSS动画</a>,重点是做出一些改变（知道我说什么吗?），但是，他们在炫耀他们的在线赚钱艺术（我不能容忍！）。</p>

<h3>Bounce.JS</h3>

<p><a rel="nofollow" href="http://bouncejs.com/">Bounce.JS</a>结合了可视化（用于设计CSS3 动画）和JS库（用于实现），对于那些喜欢视觉设计的人来说，它的使用是非常简单的。</p>

<h3>GridLover</h3>

<p>需要一个简单、可视化的方式去调整字体大小吗？<a rel="nofollow" href="http://www.gridlover.net/">GridLover</a>提供了一种简单的方式来预览排版、设置匀称的垂直和抓取CSS。你可以抓取CSS中字体的像素值、EMs, or REMs, 这些值会被格式成普通的CSS, SASS, LESS或其他代码风格。</p>

<h3>ExtractCSS</h3>

<p>想要快速设置CSS文件？一种方式是首先写HTML，然后设置ID、class等，将HTML代码粘贴到<a rel="nofollow" href="http://extractcss.com/">ExtractCSS</a>,Web APP会列出所有的选择器，最后将它们放入CSS文件就行就可以了。</p>

<h3>Kite</h3>

<p><a rel="nofollow" href="http://hiloki.github.io/kitecss/">Kite</a>是一个用于布局的CSS库，其设计用到了CSS Flex模块，但并不是完全使用Flex。Kite兼容IE8+。</p>

<h3>Pesticide</h3>

<p>需要确切地找出你的布局发生了什么?添加<a rel="nofollow" href="http://pesticide.io/">Pesticide</a>CSS文件。它将给页面上的每个元素添加边框,当元素作为子层次结构时，会巧妙地改变边框颜色。简单,但让人印象深刻。</p>

<h3>Pleeease</h3>

<p>疲惫的寻找不同的工具来对CSS进行预处理,添加特定的前缀,包括IE过滤器?不介意使用命令行吗?<a rel="nofollow" href="http://pleeease.io/">这是</a>给你的。兼容SASS,LESS和Stylus</p>

<h3>CSS Colours</h3>

<p><a rel="nofollow" href="http://colours.neilorangepeel.com/category/green/">CSS友好的颜色</a>名称列表，包含了十六进制和rgba格式。</p>

<h3>CSS Vocabulary</h3>

<p>一个小应用程序,提供了一个方便的<a rel="nofollow" href="http://apps.workflower.fi/vocabs/">css相关</a>的术语列表。选择其中一个,它将通过高亮一些示例代码来说明这个术语。</p>

<h3>Tridiv</h3>

<p>用纯CSS建立复杂的<a rel="nofollow" href="http://tridiv.com/">三维模型</a>。</p>

<h3>Buttons</h3>

<p>用SASS和Compass建立<a rel="nofollow" href="http://unicorn-ui.com/buttons/builder/">CSS按钮库</a></p>

<h3>CSS Menu Maker</h3>

<p><a rel="nofollow" href="http://cssmenumaker.com/">CSS Menu Maker</a>能帮助你建立简单、响应式的导航</p>

<h3>One% CSS Grid</h3>

<p><a rel="nofollow" href="http://onepcssgrid.mattimling.com/">One% CSS Grid</a>是一个12列的流布局网格系统，它是为构建更快、成本更低的响应式布局而设计的。</p>

<h3>Simptip</h3>

<p><a rel="nofollow" href="http://arashm.net/lab/simptip/">Simptip</a>是由SASS制作的CSS提示框工具。不仅可以设置提示框的方向（上、右、下、左），还可以设置不同的颜色，例如成功色、信息色、警告色和危险色。</p>

<h3>Myth</h3>

<p><a rel="nofollow" href="http://www.myth.io/">Myth</a>是一个CSS预处理器，这样你只需要写CSS，不用去担心低版本浏览器的支持，甚至低版本规范的改进。</p>

<h3>Hover CSS</h3>

<p>集成了<a rel="nofollow" href="http://ianlunn.github.io/Hover/">CSS悬浮效果</a>的代码，可被用在链接、按钮、logos、SVG和特色图片等等。</p>

<h3>CSS Animation Cheat Sheet</h3>

<p><a rel="nofollow" href="http://www.justinaguilar.com/animations/scrolling.html">CSS Animation Cheat Sheet</a>是一组预设、即插即用的动画CSS库.你只需要将样式表导入到你的网站，然后给你想要添加动画的元素添加类就行。</p>

<h3>Spinkit</h3>

<p><a rel="nofollow" href="http://tobiasahlin.com/spinkit/">Spinkit</a>包含了一些简单但非常棒的CSS动画加载效果</p>

<h3>Typebase.CSS</h3>

<p><a rel="nofollow" href="http://devinhunt.github.io/typebase.css/">Typebase.CSS</a>是一个很小的、可定制的排版样式表。它同时又less和sass版本,因此可以很容易地修改和合并到现代web项目。</p>

<h3>SpriteBox</h3>

<p>使你的<a rel="nofollow" href="http://www.spritebox.net/">CSS imager sprites</a>变成可拖放的编辑器，并让它为你写代码。</p>

<h3>CSS Ratiocinator</h3>

<p><a rel="nofollow" href="https://github.com/begriffs/css-ratiocinator">CSS Ratiocinator</a>是一个命令行工具，通过检查实际的呈现效果，会清除掉没用的CSS代码。它非常适合应用在一些CSS文件已经超出控制的大项目。</p>

<h3>CSS Beautifier</h3>

<p><a rel="nofollow" href="http://html.fwpolice.com/css/">美化CSS</a>，如果你已经得到了一个缩小的文件但不能找到原始(或你只是有点混乱的代码)文件时,代码的美化可以通过适当的格式化和缩进修复。</p>

<h3>CSScomb</h3>

<p>在使用CSS Beautifier让你的代码变得可读之后，你可以使用<a rel="nofollow" href="http://csscomb.com/">CSScomb</a>运行代码，确保所有的属性都按照字母表有规则的排序。记住，不是选择器，而是属性，例如宽度总是在字体声明之后等等</p>

<h3>Anima</h3>

<p>一个<a rel="nofollow" href="http://lvivski.com/anima/">动画库</a>,为了扩展CSS动画的功能而设计的，并且能同时为100个元素设置动画。</p>

<h3>Recess</h3>

<p><a rel="nofollow" href="http://twitter.github.io/recess/">Recess</a>是一个剥绒机程序,也可以作为一个编译器运行，目的是确保你的CSS符合一组规则并保持精简。每个规则可以单独禁以满足你的编码风格。</p>

<h3>Bonus: A to Z CSS</h3>

<p>Bonus: A to Z CSS不是一个工具，但是对于初学者来说是一个很好的资源。在<a rel="nofollow" href="http://www.atozcss.com/">A to Z</a>，Guy Routledge为每一个CSS基本规则，如盒子模型及最常用的CSS属性，提供了坚实的课程。</p>

<p>译文出处：<a rel="nofollow" href="http://www.ido321.com/1545.html"></a><a rel="nofollow" href="http://www.ido321.com/1545.html">http://www.ido321.com/1545.html</a><br>
英文原文：<a rel="nofollow" href="http://www.developerdrive.com/2015/03/40-tools-for-writing-better-css">40 tools for writing better CSS</a></p>

2015年五月2日晚上 11:36:15
Lua 学习笔记（下）
<p>前面的部分见 <a rel="nofollow" href="http://segmentfault.com/a/1190000002723417">Lua 学习笔记（上）</a></p>

<h1> 4 辅助库</h1>

<p>辅助库为我们用 Lua 与 C 的通信提供了一些方便的函数。基础 API 提供 Lua 与 C 交互的所有原始函数。辅助库作为更高层次的函数来解决一些通用的问题。</p>

<p>辅助库的所有函数定义在头文件 <code>luaxlib.h</code> 中，函数带有前缀 <code>luaL_</code> 。</p>

<p>辅助库函数是建立在基础库之上的，所以基础库做不了的事情辅助库也做不了。</p>

<p>有一些函数是用来检查函数参数的，这些函数都有这样的前缀 <code>luaL_check</code> 或者 <code>luaL_opt</code>。这些函数在检查出问题后会抛出错误。由于抛出的错误消息表明是参数错误（例如，“bad argument #1”），因此不要把这些函数用在参数以外的 Lua 值上。</p>

<h1> 5 标准库</h1>

<p>标准 Lua 库提供了许多有用的函数，这些函数都是直接用 C API 实现的。有一些函数提供了 Lua 语言本身所必要的服务（例如，<code>type</code> 和 <code>getmetatable</code>）；有一些提供了通向“外部”的服务（例如，I/O）；还有一些函数，可以由 Lua 进行实现，但是由于相当有用或者有重要的性能需求需要由 C 实现（例如 <code>sort</code>）。</p>

<p>所有的库都以 C 模块的形式分开提供。5.1中，Lua有以下几种标准库：</p>

<pre><code>- 基础库
- 包库
- 字符串操作库
- 表操作库
- 数学功能库
- 输入输出库
- 操作系统工具库
- 调试工具库
</code></pre>

<p>除了基础库和包库，其他库都是作为<strong>全局表的域</strong>或者<strong>对象的方法</strong>提供。</p>

<p>[待补充]</p>

<h2>  5.1 基础库函数</h2>

<p>基础库为 Lua 提供了一些核心函数。如果没有包含这个库，那么就可能需要自己来实现一些 Lua 语言特性了。</p>

<h3> assert (v [, message])</h3>

<p>如果其参数 <code>v</code> 的值为假（<code>nil</code> 或 <code>false</code>）， 它就调用 <code>error</code>； 否则，返回所有的参数。 在错误情况时， <code>message</code>  指那个错误对象； 如果不提供这个参数，参数默认为 "assertion failed!" 。</p>

<h4>例子</h4>

<pre><code>assert(5==4,"Number Not Equal!")    --&gt; 报错 Number Not Equal!
</code></pre>

<pre><code>assert(nil)                         --&gt; 报错 assertion failed!
</code></pre>

<h3> collectgarbage (opt [, arg])</h3>

<p>控制垃圾回收器的参数有两个，pause 和 step multipier。</p>

<p>参数 pause 控制了收集器在开始一个新的收集周期之前要等待多久。 随着数字的增大就导致收集器工作工作的不那么主动。 小于 1 的值意味着收集器在新的周期开始时不再等待。 当值为 2 的时候意味着在总使用内存数量达到原来的两倍时再开启新的周期。</p>

<p>参数 step multiplier 控制了收集器相对内存分配的速度。 更大的数字将导致收集器工作的更主动的同时，也使每步收集的尺寸增加。 小于 1 的值会使收集器工作的非常慢，可能导致收集器永远都结束不了当前周期。 缺省值为 2 ，这意味着收集器将以内存分配器的两倍速运行。</p>

<p>该函数是垃圾回收器的通用接口，根据 <code>opt</code> 参数的不同实现不同的功能。</p>

<ul>
<li>"stop": 停止垃圾回收。</li>
<li>"restart": 重启垃圾回收。</li>
<li>"collect": 执行垃圾回收的完整循环。</li>
<li>"count": 返回 Lua 当前使用的总内存（单位为 Kb）。</li>
<li>"step": 执行一步（一步可由多步组成）垃圾回收。步数可由参数 <code>arg</code> 控制（值越大，步数越多，0 表示执行一步（指最小的一步））。如果执行后完成了回收循环，返回 <code>true</code>。</li>
<li>"setpause": 把 arg/100 作为垃圾回收参数 pause 的新值。</li>
<li>"setstepmul": 把 arg/100 作为垃圾回收参数 step mutiplier 的新值。</li>
</ul>
<h4>例子</h4>

<p>进行垃圾回收前后的内存占用情况：</p>

<pre><code>x = collectgarbage("count")
print(x)            --&gt; 27.5615234375
collectgarbage("collect")
x = collectgarbage("count")
print(x)            --&gt; 26.7490234375
</code></pre>

<h3> dofile (filename)</h3>

<p>打开该名字的文件，并执行文件中的 Lua 代码块。 不带参数调用时， dofile 执行标准输入的内容（stdin）。 返回该代码块的所有返回值。 对于有错误的情况，dofile 将错误反馈给调用者 （即，dofile 没有运行在保护模式下）。</p>

<h4>例子</h4>

<p>同一目录下新建两个 Lua 文件，代码及输出：</p>

<pre><code>-- another.lua
return "Message from another file!"

-- sample.lua
x = dofile("./another.lua")
print(x)    --&gt; Message from another file!
</code></pre>

<p>dofile 在这里等价于</p>

<pre><code>function dofile()
    function func()
        return "Message from another file!"
    end

    return func()
end
</code></pre>

<p>于是等价的输出为</p>

<pre><code>print(dofile()) --&gt; Message from another file!
</code></pre>

<h3> error (message [, level])</h3>

<p>终止所保护的函数，抛出 message 消息，不再返回。</p>

<p>通常这个函数会在抛出的消息前面加上发生错误的地址信息。堆栈等级决定添加哪个地址。如果堆栈等级为 0 ，不返回地址信息；如果为 1，返回 error 语句所在位置；如果为 2，返回调用 error所在函数的位置；依此类推。</p>

<h4>定义</h4>

<pre><code>error([报错消息],[堆栈等级]=1)
</code></pre>

<h4>例子</h4>

<pre><code>function division(a,b)
    if b == 0 then error("Divisor cannot be 0!",2) end      -- level 值为 1 时，错误信息指向这里
    return a / b
end

print(division(5,1))
print(division(5,0))        -- level 值为 2 时，错误信息指向这里
</code></pre>

<h3> <code>_G</code>
</h3>

<p><code>_G</code> 持有全局环境的变量，Lua 本身用不到这个变量，更改变量不会影响到全局环境；反过来也一样。</p>

<h3> getfenv (f)</h3>

<p>返回函数的环境。 f 可以是一个 Lua 函数，也可以是函数在堆栈中的等级。等级 1 代表调用 getfenv() 的那个函数。如果传入的函数不是 Lua 函数，或者 f 是 0，那么 getfenv 返回 全局环境。</p>

<p>~~[待补充]不是太明白，没能给出合适的代码~~<br>
参考 <a rel="nofollow" href="http://www.jellythink.com/archives/882">Lua中的环境概念</a></p>

<h4>定义</h4>

<pre><code>getfenv([目标函数]=1)
</code></pre>

<h4>例子</h4>

<p>获取全局环境：</p>

<pre><code>for k,v in pairs(_G) do
print(k,v)
end

--string            table: 0x7ff200f02330
--xpcall            function: 0x7ff200d03cc0
--package           table: 0x7ff200e00000
--tostring          function: 0x7ff200d04560
--print             function: 0x7ff200d046a0
--os                table: 0x7ff200f01cb0
--unpack            function: 0x7ff200d04610
--require           function: 0x7ff200f006f0
--getfenv           function: 0x7ff200d042f0
--setmetatable      function: 0x7ff200d044a0
--next              function: 0x7ff200d04260
--assert            function: 0x7ff200d03fc0
--tonumber          function: 0x7ff200d04500
--io                table: 0x7ff200f014a0
--rawequal          function: 0x7ff200d046f0
--collectgarbage    function: 0x7ff200d04010
--arg               table: 0x7ff200e01360
--getmetatable      function: 0x7ff200d04340
--module            function: 0x7ff200f006a0
--rawset            function: 0x7ff200d047a0
--math              table: 0x7ff200e00040
--debug             table: 0x7ff200e00a00
--pcall             function: 0x7ff200d042b0
--table             table: 0x7ff200f00790
--newproxy          function: 0x7ff200d04820
--type              function: 0x7ff200d045c0
--coroutine         table: 0x7ff200d048c0
--_G                table: 0x7ff200d02fc0
--select            function: 0x7ff200d04400
--gcinfo            function: 0x7ff200d03000
--pairs             function: 0x7ff200d03e00
--rawget            function: 0x7ff200d04750
--loadstring        function: 0x7ff200d04200
--ipairs            function: 0x7ff200d03d70
--_VERSION          Lua 5.1
--dofile            function: 0x7ff200d04110
--setfenv           function: 0x7ff200d04450
--load              function: 0x7ff200d041b0
--error             function: 0x7ff200d04160
--loadfile          function: 0x7ff200d043a0
</code></pre>

<h3> getmetatable (object)</h3>

<p>如果对象没有元表，返回空；如果对象有 <code>__metatable</code> 域，返回对应的值；否则，返回对象的元表。</p>

<h4>例子</h4>

<p>对象有 <code>__metatable</code> 域的情况：</p>

<pre><code>t = {num = "a table"}

mt = {__index = {x = 1,y = 2},__metatable = {__index = {x = 5,y = 6}}}
setmetatable(t, mt)

print(getmetatable(t).__index.x)  --&gt; 5
print(t.x)                        --&gt; 1
</code></pre>

<p>~~进行操作时的元表依旧是与值直接关联的那个元表，不知道这样子处理有什么作用？~~</p>

<h3> ipairs (t)</h3>

<p>返回三个值：迭代器、传入的表 t、值 0 。迭代器能够根据传入的表 t 和索引 i 得到 i+1 和 t[i+1] 的值。</p>

<p>其实现形式类似于这样：</p>

<pre><code>function ipairs(t)

    function iterator(t,i)
        i = i + 1
        i = t[i] and i      -- 如果 t[i] == nil 则 i = nil；否则 i = i
        return i,t[i]
    end

    return iterator,t,0

end
</code></pre>

<h4>例子</h4>

<p>使用 ipairs 对表进行遍历，会从键值为 1 开始依次向后遍历，直到值为 nil。</p>

<pre><code>t = {"1","2",nil,[4]="4"}
-- t = {"1","2",[4]="4"}   -- 使用该表会得到相同的输出

for i,v in ipairs(t) do
    print(i,v)
end

--&gt; 1   1
--&gt; 2   2
</code></pre>

<h3> load (func [, chunkname])</h3>

<p>通过传入函数 func 的返回值获取代码块片段。func 函数的后一次调用返回的字符串应当能与前一次调用返回的字符串衔接在一起，最终得到完整的代码块。函数返回 nil 或无返回值时表示代码块结束。</p>

<p>load 函数会将得到的代码块作为函数返回。返回函数的环境为全局环境。如果出现错误，load 会返回 nil 和 错误信息。</p>

<p>chunkname 作为该代码块的名称，用在错误信息与调试信息中。</p>

<h4>例子</h4>

<p>[待补充]</p>

<h3> loadfile ([filename])</h3>

<p>使用方式与 dofile 类似，函数内容与 load 类似。从文件中获取代码块，如果没有指定文件，则从标准输入中获取。</p>

<p>loadfile 把文件代码编译为中间码，以文件代码作为一个代码块（chunk）,并返回包含此代码块的函数。<br>
编译代码成中间码，并返回编译后的chunk作为一个函数。 如果出现错误，则返回 nil 以及错误信息。</p>

<p>使用 loadfile，可以一次编译多次运行；而每次使用 dofile，都会执行一次编译。</p>

<h4>例子</h4>

<p>同一目录下新建两个 Lua 文件，代码及输出：</p>

<pre><code>-- sample.lua
f = loadfile("./sample.lua")
print(f())
--&gt; Message from another file!
--&gt; 0

-- another.lua
function fun()
 print("Message from another file!")
 return 0
end
res = fun()
return res
</code></pre>

<p>loadfile 在这里等价于</p>

<pre><code>function loadfile()
    function fun()
     print("Message from another file!")
     return 0
    end
    res = fun()
    return res
end
</code></pre>

<h3> loadstring (string [, chunkname])</h3>

<p>与 load 类似，只不过是从字符串中获取代码块。</p>

<p>要想加载并运行所给的字符串，使用如下惯用形式：</p>

<pre><code>assert(loadingstring(s))()
</code></pre>

<h3> next (table [, index])</h3>

<p>返回传入的表中下一个键值对。</p>

<h4>定义</h4>

<pre><code>next([表],[键]=nil)
</code></pre>

<p>第一个参数是要操作的表，第二个参数是表中的某个键。如果传入的键值为 nil ，则函数返回第一个键值对。如果传入一个有效的键值，则输出下一对键值对。如果没有下一个键值对，返回 nil。</p>

<p><strong>根据定义，可以使用 next 来判断一个表是否为空表。</strong></p>

<p><strong>注意：</strong></p>

<p>键值对的遍历顺序是不一定的，即使是对数字索引也是如此。如果想要按照数字索引的顺序获取键值对，参见 <a rel="nofollow">ipairs (t)</a> 函数。</p>

<h4>例子</h4>

<pre><code>t = {"table",["a"] = 5, ["c"] = 6}

-- index 为 nil
print(next(t, nil))         --&gt; 1   table

-- index 为 无效键
print(next(t,"d"))          --&gt; 编译错误

-- index 为 数字索引
print(next(t,1))            --&gt; a   5

-- index 为 一般键
print(next(t, "a"))         --&gt; c   6

-- index 为 最后一个键
print(next(t,"c"))          --&gt; nil
</code></pre>

<p>遍历顺序与定义顺序不一致的例子：</p>

<pre><code>t = {[1]="table",b = 4,["a"] = 5, ["c"] = 6, func}

t.func = function (...)
    return true
end

for k,v in pairs(t) do
    print(k,v)
end
--&gt; a   5
--&gt; func    function: 0x7f7f63c0ad50
--&gt; c   6
--&gt; b   4
</code></pre>

<p>而且从上面的例子中可以看出 <code>name = exp</code> 的键值对形式会占用</p>

<h3> pairs (t)</h3>

<p>返回三个值：next 函数，表 t，nil。通常用来遍历表中的所有键值对。<br>
如果 t 有元方法 __pairs ，将 t 作为参数 传入该函数并返回前三个返回值。</p>

<p>在使用 pairs 函数遍历表的过程中，可以删除域或者修改已有的域，但是如果添加新的域，可能出现无法预期的问题。</p>

<h4>例子</h4>

<pre><code>t = {"table",["a"] = 5, ["c"] = 6}
for k,v in pairs(t) do
    print(k,v)
end
--&gt; 1   table
--&gt; a   5
--&gt; c   6
</code></pre>

<p>在遍历表的过程中添加新的域导致问题出现的情况：</p>

<pre><code>t = {"table",["a"] = 5, ["c"] = 6}

for k,v in pairs(t) do
    -- 添加一个新的域
    if k == 'a' then
        t[2] = 8
    end
    print(k,v)
end
--&gt; 1   table
--&gt; a   5
</code></pre>

<h3> pcall (f [, arg1, ...])</h3>

<p>以保护模式调用传入的函数，也就是说不会抛出错误。如果捕获到抛出的错误，第一个参数返回 false，第二个参数返回错误信息；如果没有出现错误，第一个参数返回 ture，后面的参数返回传入函数的返回值。</p>

<h4>#</h4>

<pre><code>function fun(a,b)

    assert(not(b == 0), "divisor can't be 0 !")

    return a / b    
end

success, res = pcall(fun,5,0) --&gt; false .../sample.lua:3: divisor can't be 0 !
success, res = pcall(fun,5,1) --&gt; true  5
</code></pre>

<h3> print (...)</h3>

<p>仅作为快速查看某个值的工具，不用做格式化输出。正式的格式化输出见 string.format 与 io.write。</p>

<h3> rawequal (v1, v2)</h3>

<p>以 <code>raw</code> 作为前缀的函数均表示该方法在不触发任何元方法的情况下调用。</p>

<p>rawequal 检查 v1 是否与 v2 相等，返回比较结果。</p>

<h4>例子</h4>

<pre><code>t = {"value"}
s = "value"
s2 = "value"
print(rawequal(t, s))     --&gt; false
print(rawequal(s, s2))    --&gt; true
</code></pre>

<h3> rawget (table, index)</h3>

<p>获取 table 中键 index 的关联值，table 参数必须是一个表，找不到返回 nil 。</p>

<h4>例子</h4>

<pre><code>t = {"value",x = 5}

print(rawget(t, 1))     --&gt; value
print(rawget(t, "x"))   --&gt; 5
print(rawget(t, 2))     --&gt; nil
print(rawget("value",1))--&gt; bad argument #1 to 'rawget' (table expected, got string)
</code></pre>

<h3> rawset (table, index, value)</h3>

<p>将 table[index] 的值设置为 value 。table 必须是一张表，index 不能是 nil 或 NaN 。value 可以是任何值。返回修改后的 table 。</p>

<h4>例子</h4>

<pre><code>t = {"value",x = 5}
t2 = {"sub table"}
rawset(t, 1,"new value")
rawset(t, "y", 6)
rawset(t, t2,"sub table")
rawset(t,NaN,"NaN")         --&gt; table index is nil

print(t[1])                 --&gt; new value
print(t.y)                  --&gt; 6
print(t[t2])                --&gt; sub table
</code></pre>

<h3> select (index, ...)</h3>

<p>index 可以是数字或者字符 '#' 。当 index 为数字时，返回第 index + 1 个参数及后面的参数（支持负数形式的 index）；当 index 为 '#' 时，返回参数的个数（不包括第一个参数）。</p>

<h4>例子</h4>

<pre><code>t = {"table",x = 5}
t2 = {"table2"}

print(select(  1, 1, t, t2))    --&gt; 1  table: 0x7fad7bc0a830 table: 0x7fad7bc0ac20
print(select( -3, 1, t, t2))    --&gt; 1  table: 0x7fad7bc0a830 table: 0x7fad7bc0ac20
print(select("#", 1, t, t2))    --&gt; 3
</code></pre>

<h3> setfenv (f, table)</h3>

<p>设置函数 f 的环境表为 table 。f 可以是一个函数，或者是代表栈层级的数字。栈层级为 1 的函数是那个调用 setfenv 的函数，栈层级为 2 的函数就是更上一层的函数。 setfenv 返回 f。</p>

<p>特别的，如果 f 为 0，那么 setfenv 会把全局环境设置为 table 。并且不做任何返回。</p>

<p><em>Lua 的之后版本中去掉了 setfenv 和 getfenv 函数。</em></p>

<h4>例子</h4>

<p>使用栈层级操作 setfenv 的例子：</p>

<pre><code>function foobar(...)

    -- 设置 foobar 的环境
    t = {}
    setmetatable(t, {__index = _G })
    setfenv(1,t)
    a = 1
    b = 2

    -- 输出 foobar 的环境
    for k,v in pairs(getfenv(1)) do
        print(k,v)
    end
    print()

    function foo(...)
        -- 设置 foo 的环境，继承 foobar 的环境
        local t = {}
        setmetatable(t, {__index = _G})
        setfenv(1,t)
        x = 3
        y = 4

        -- 输出 foo 的环境
        for k,v in pairs(getfenv(1)) do
            print(k,v)
        end
        print()

        -- 再次设置 foobar 的环境
        setfenv(2, t)
    end


    foo()

    -- 再次输出 foobar 的环境
    for k,v in pairs(getfenv(1)) do
        print(k,v)
    end
end

foobar()

--&gt; a   1
--&gt; b   2
--&gt; 
--&gt; y   4
--&gt; x   3
--&gt; 
--&gt; y   4
--&gt; x   3
</code></pre>

<p>将 setfenv 用于模块加载：</p>

<pre><code>-- sample.lua 文件
local FuncEnv={}    -- 作为环境
setmetatable(FuncEnv, {__index = _G}) -- 为了能够访问原本全局环境的值，将全局环境表（_G）放在元表中

local func=loadfile("other.lua")    -- 返回一个函数，函数以 other 文件内容作为代码块
setfenv(func,FuncEnv)
func()                              -- 执行代码块，得到定义的 message 函数，该函数会存在环境中
FuncEnv.message()                   --通过环境调用函数，FuncEnv 此时就相当于一个独立模块
</code></pre>

<pre><code>-- other.lua 文件
function message()
    print("Message from another file!")
end
</code></pre>

<p>本小节参考了 <strong>斯芬克斯</strong> 的 <a rel="nofollow" href="http://www.cnblogs.com/sifenkesi/p/3843348.html">设置函数环境——setfenv</a> ，<strong>icyday</strong> 的 <a rel="nofollow" href="http://blog.csdn.net/icyday/article/details/8116818">lua5.1中的setfenv使用</a> 两篇博客。</p>

<h3> setmetatable (table, metatable)</h3>

<p>给 table 关联元表 metatable 。返回参数 table 。</p>

<p>如果元表定义了 <code>__metatable</code> 域，会抛出错误。</p>

<p>metatable 参数为 nil 表示解除已经关联的元表。</p>

<h4>例子</h4>

<pre><code>-- 关联一个定义了加法操作的元表
t = setmetatable({}, {__add = function(a,b)
    if type(a) == "table" and type(b) == "table" then
        return a.num + b.num
    end
end})

t.num = 5
t2 = {num = 6}
print(t+t2)         --&gt; 11      -- 只要有一个表进行了关联就能够进行运算

setmetatable(t, nil)            

-- 解除关联后再进行加法运算会报错
print(t+t2)         --&gt; attempt to perform arithmetic on global 't' (a table value)

</code></pre>

<h3> tonumber (e [, base])</h3>

<pre><code>tonumber([值],[基数]=10)
</code></pre>

<p>尝试把 e 转换为十进制数值并返回。如果无法转换返回 nil 。</p>

<p>base 表示传入参数的进制，默认为 10 进制。base 的可输入范围 [2,36]。高于 10 的数字用字母表示，A-Z 分别表示 11-35 。</p>

<h4>例子</h4>

<pre><code>print(tonumber(123))            --&gt; 123
print(tonumber("123"))          --&gt; 123
print(tonumber("abc"))          --&gt; nil
print(tonumber("abc", 20))      --&gt; 4232
print(tonumber("ABC", 20))      --&gt; 4232
</code></pre>

<h3> tostring (e)</h3>

<p>能将任意类型的值转换为合适的字符串形式返回。要控制数字转换为字符串的方式，使用 <a rel="nofollow">string.format(formatstring,...)</a> 。</p>

<p>如果值所关联的元表有 <code>__tostring</code> 域，则使用该域的元方法获取字符串。</p>

<h4>例子</h4>

<pre><code>function func()
    print("this is a function")
end
t = {name = "table"}

print(tostring(123))        --&gt; 123
print(tostring("abc"))      --&gt; abc
print(tostring(func))       --&gt; function: 0x7f86348013b0
print(tostring(t))          --&gt; table: 0x7f86348013e0
</code></pre>

<h3> type (v)</h3>

<p>返回 v 的类型，类型以字符串形式返回。 有以下八种返回值： "nil" ， "number"， "string"， "boolean"， "table"， "function"， "thread"， "userdata"。</p>

<h4>例子</h4>

<pre><code>type(nil)                   --&gt; "nil"
type(false)                 --&gt; "boolean"
type(123)                   --&gt; "number"
type("abc")                 --&gt; "string"

print(type(nil) == "nil")   --&gt; true
</code></pre>

<h3> unpack (list [, i [, j]])</h3>

<pre><code>unpack([列表],[起始位置]=1,[返回个数]=[列表长度])
</code></pre>

<p>返回表中的各个域的值，等价于返回</p>

<pre><code>return list[i], list[i+1], ···, list[j]
</code></pre>

<h4>例子</h4>

<pre><code>t = {1,2,3,a = 4,b = 5}

print(unpack(t, 1, 4))      --&gt; 1   2   3   nil
</code></pre>

<h3> _VERSION</h3>

<p>包含有当前解释器版本号的全局变量，当前版本的值为 "Lua 5.1"。</p>

<h3> xpcall (f, err [, arg1, ...]</h3>

<p>与 <a rel="nofollow">pcall (f, arg1, ...)</a> 类似。不同的是，如果 f 函数抛出了错误，那么 xpcall 不会返回从 f 抛出的错误信息，而是使用 err 函数返回的错误信息。</p>

<h4>例子</h4>

<pre><code>function fun(a,b)   -- 这里的参数没什么实际作用，就是展示下用法
    error("something wrong !!", 1)
end

-- pcall 
local success, res = pcall(fun,1,2)
print(success,res)      --&gt; false   .../sample.lua:2: something wrong !!

-- xpcall
local success, res = xpcall(fun,function()
    return "an error occured !!"
end,1,2)
print(success,res)      --&gt; false   an error occured !!
</code></pre>

<h2>   5.4 字符串操作</h2>

<h3>   5.4.1 模式</h3>

<h4>字符类</h4>

<p>字符类代表一组字符。可以用下列组合来表示一个字符类。</p>

<table>
<thead><tr>
<th>组合</th>
  <th>代表字母</th>
  <th>代表字符类型</th>
</tr></thead>
<tbody>
<tr>
<td>x</td>
  <td>（变量 x）</td>
  <td>
<code>^$()%.[]*+-?</code>以外的任一字符</td>
</tr>
<tr>
<td>.</td>
  <td>（dot）</td>
  <td>任意字符</td>
</tr>
<tr>
<td>%a</td>
  <td>（alphabet）</td>
  <td>字母</td>
</tr>
<tr>
<td>%b</td>
  <td>（bracket）</td>
  <td>对称字符以及字符间的内容</td>
</tr>
<tr>
<td>%c</td>
  <td>（control）</td>
  <td>控制字符（即各类转义符）</td>
</tr>
<tr>
<td>%d</td>
  <td>（digits）</td>
  <td>数字</td>
</tr>
<tr>
<td>%l</td>
  <td>（lowercase）</td>
  <td>小写字母</td>
</tr>
<tr>
<td>%p</td>
  <td>（punctuation）</td>
  <td>标点符号</td>
</tr>
<tr>
<td>%s</td>
  <td>（space）</td>
  <td>空格</td>
</tr>
<tr>
<td>%u</td>
  <td>（uppercase）</td>
  <td>大写字母</td>
</tr>
<tr>
<td>%w</td>
  <td>（word）</td>
  <td>字母和数字</td>
</tr>
<tr>
<td>%x</td>
  <td>（hexadecimal）</td>
  <td>十六进制字符</td>
</tr>
<tr>
<td>%z</td>
  <td>（zero）</td>
  <td>值为 0 的字符，即 '\0'</td>
</tr>
<tr>
<td>%x</td>
  <td>（变量 x）</td>
  <td>字母和数字以外的任一字符</td>
</tr>
</tbody>
</table>
<p>如果组合中的字符写成大写形式（例如将 '%a' 写成 '%A'），相当于对原来所代表的字符类型取<strong>补集</strong>。</p>

<p><strong>例子：</strong></p>

<p>前两行的数字标出每个字符的下标。find函数返回找出第一个符合查找条件的字符的下标。</p>

<pre><code>-----------------00000000001111111112 222222222333333333344444444445555 5
-----------------12345678901234567890 123456789012345678901234567890123 4
x = string.find("Tutu is a young man.\n His student number is 20230001.\0","i")
    --&gt; 6
x = string.find("Tutu is a young man.\n His student number is 20230001.\0",".")
    --&gt; 1
x = string.find("Tutu is a young man.\n His student number is 20230001.\0","%a")    --&gt; 1   
x = string.find("Tutu is a young man.\n His student number is 20230001.\0","%c")    --&gt; 21 
x = string.find("Tutu is a young man.\n His student number is 20230001.\0","%d")    --&gt; 45 
x = string.find("Tutu is a young man.\n His student number is 20230001.\0","%l")    --&gt; 2   
x = string.find("Tutu is a young man.\n His student number is 20230001.\0","%p")    --&gt; 20 
x = string.find("Tutu is a young man.\n His student number is 20230001.\0","%s")    --&gt; 5   
x = string.find("Tutu is a young man.\n His student number is 20230001.\0","%u")    --&gt; 1   
x = string.find("Tutu is a young man.\n His student number is 20230001.\0","%w")    --&gt; 1   
x = string.find("Tutu is a young man.\n His student number is 20230001.\0","%x")    --&gt; 9   
x = string.find("Tutu is a young man.\n His student number is 20230001.\0","%z")    --&gt; 54 
</code></pre>

<p>加 <code>()</code> 表示捕捉，find的第三个参数返回被捕捉到的字符串,在这里即返回找到的那个字符。</p>

<pre><code>x,y,z = string.find("%()~!@#$%^&amp;*():\";\'?&lt;&gt;._[]","(%%)")   --&gt; 1   1   %
x,y,z = string.find("%()~!@#$%^&amp;*():\";\'?&lt;&gt;._[]","(%#)")   --&gt; 7   7   #
x,y,z = string.find("%()~!@#$%^&amp;*():\";\'?&lt;&gt;._[]","(%\")")  --&gt; 16  16  "
</code></pre>

<p>下句中的 <code>+</code> 表示取一个或多个满足条件的连续字符。</p>

<pre><code>                 --1 2 3 4 5 6 7 8
x,y = string.find("\a\b\f\n\r\t\v\0","%c+")     --&gt; 1   7
</code></pre>

<p>上句基本列出了所有控制字符，并不是所有转义符都是控制字符，例如 <code>\\</code> 和 <code>\xff</code> 不属于控制字符。</p>

<p><code>match</code> 函数返回符合匹配条件的字符子串。</p>

<pre><code>x = string.match("0123456789ABCDEFabcdefg","%x+")   --&gt; 0123456789ABCDEFabcdef
</code></pre>

<p>输出的符号即为 <code>%x</code> 所支持的所有字符。</p>

<p><code>%b</code> 的使用方法与前面的组合形式略有不同，其形式为 <code>%bxy</code>，使用示例如下：</p>

<pre><code>---------------------00000000001111111112 22222222233333333334444444444555555 5
---------------------12345678901234567890 12345678901234567890123456789012345 6
x,y,z = string.find("Tutu is a young man.\n His student number is [20230001].\0","(%b[])")  --&gt; 45  54  [20230001]
x,y,z = string.find("Tutu is a young man.\n His student number is _20230001_.\0","(%b__)")  --&gt; 45  54  _20230001_
x,y,z = string.find("Tutu is a young man.\n His student number is _20230001_.\0","(%b21)")  --&gt; 48  53  230001
</code></pre>

<h4>
<code>[]</code> 字符集</h4>

<p>字符集操作是对<strong>字符类</strong>中<strong>组合</strong>的一个扩展。可以通过 <code>[]</code> 制定出用户所需的一套字符选取范围。</p>

<pre><code>---------------------0000000001111111111222222222
---------------------1234567890123456789012345678
x,y,z = string.find("[Email]: tangyikejun@163.com","([123])")           --&gt; 22  22  1
x,y,z = string.find("[Email]: tangyikejun@163.com","([l]])")            --&gt; 6   7   l]
x,y,z = string.find("[Email]: tangyikejun@163.com","([1-3])")           --&gt; 22  22  1
x,y,z = string.find("[Email]: tangyikejun@163.com","([^1-3])")          --&gt; 1   1   [
x,y,z = string.find("[Email]: tangyikejun@163.com","([^%d])")           --&gt; 1   1   [
x,y,z = string.find("[Email]: tangyikejun@163.com","([0-9][%d][%d])")   --&gt; 22  24  163
x,y,z = string.find("[Email]: tangyikejun@163.com","([0-9]+)")          --&gt; 22  24  163
</code></pre>

<p><strong>使用特点：</strong></p>

<ol>
<li>每个字符集仅限定一个字符的范围。</li>
<li>连字符 <code>-</code> 用于限定字符的范围，值域根据字符在ASCII码中对应的值得出，例如 <code>[0-7]</code> 代表字符范围为 0-7。<br><code>x,y,z = string.find("!\"#$%&amp;0123","([$-1]+)")          --&gt; 4   8   $%&amp;01</code>
</li>
<li>添加 <code>^</code> 表示对指定的字符范围取补集。<code>[^%d]</code> 等价于 <code>[%D]</code>。</li>
</ol>
<h4>模式项</h4>

<table>
<thead><tr>
<th>模式项</th>
  <th>作用</th>
</tr></thead>
<tbody>
<tr>
<td>+</td>
  <td>匹配1个或多个字符，尽可能多地匹配</td>
</tr>
<tr>
<td>-</td>
  <td>匹配0个或多个字符，尽可能少地匹配</td>
</tr>
<tr>
<td>*</td>
  <td>匹配0个或多个字符，尽可能多地匹配</td>
</tr>
<tr>
<td>？</td>
  <td>匹配0个或1个字符，尽可能多地匹配</td>
</tr>
</tbody>
</table>
<p><strong>使用特点：</strong></p>

<ol>
<li>模式项都是针对前一个字符而言的。例如 <code>abc-</code> 作用于字符 <code>c</code>。</li>
</ol>
<pre><code>---------------------0000000001
---------------------1234567890
x,y,z = string.find("aaaabbbccc","(%a+)")       --&gt; 1   10  aaaabbbccc
x,y,z = string.find("bbbccc","(a+)")            --&gt; nil nil nil
x,y,z = string.find("aaaabbbccc","(ab-c)")      --&gt; 4   8   abbbc
-- x,y,z = string.find("aaaaccc","(ab-c)")      --&gt; 4   5   ac
-- x,y,z = string.find("aaaaccc","(ab*c)")      --&gt; 4   5   ac
-- x,y,z = string.find("aaaabccc","(ab?c)")     --&gt; 4   6   abc
-- x,y,z = string.find("aaaabccc","(ba?c)")     --&gt; 5   6   bc
</code></pre>

<pre><code>---------------------000000000111 111111122
---------------------123456789012 345678901
x,y,z = string.find("tangyikejun\0 163.com","(%z%s%w+)")    --&gt; 12  16  
x,y,z = string.find("tangyikejun\0163.com","(%z%d%w+)")     --&gt; nil nil     nil 
</code></pre>

<p><strong>注意：</strong> <code>\0</code> 后面不能跟数字。而且用 find 返回的匹配字符串无法输出 <code>\0</code> 之后的部分。</p>

<h4>模式</h4>

<p>多个模式项组合形成<strong>模式</strong>。</p>

<ul>
<li>模式的前面添加 <code>^</code> 表示匹配从目标字符串的起始位置开始。</li>
<li>模式的末尾添加 <code>$</code> 表示匹配目标字符串的末尾子串。</li>
<li>其他位置的 <code>^</code> 和 <code>$</code> 作为普通字符处理。</li>
</ul>
<pre><code>---------------------0000000001111111111222222222
---------------------1234567890123456789012345678
x,y,z = string.find("[Email]: tangyikejun@163.com","^(.%a+)")   --&gt;1    6   [Email
x,y,z = string.find("[Email]: tangyikejun@163.com","(%a+)$")    --&gt;26   28  com
</code></pre>

<h4>
<code>()</code>捕捉</h4>

<p>捕捉是指将括号内的组合匹配结果保存起来，每个括号保存一个结果。<br>
保存的数据的顺序按照<strong>左括号的顺序</strong>排列。</p>

<pre><code>x,y,z,h,l = string.find("Tutu is a young man.\n His student number is _20230001_.\0","((%a+%s)(%a+%s)%b__)")    --&gt; 35  54  number is _20230001_    number  is 
</code></pre>

<p>字符串模式匹配可参考<a rel="nofollow" href="http://www.cnblogs.com/whiteyun/archive/2009/09/02/1541043.html">Lua模式匹配</a>。</p>

<h3> 5.4.2 库函数</h3>

<ul>
<li>字符串的下标从1开始。正数下标表示正向下标，负数表示反向下标（例如 -1 表示字符串最后一个字符）。</li>
<li>函数均默认支持模式匹配。</li>
<li>返回的匹配字符串无法输出 <code>\0</code> 之后的部分。</li>
</ul>
<h3> string.find(s,pattern[,init[,plain]])</h3>

<p>查找字符串的子串，如果找到，返回子串的起始位置、结束位置；找不到返回 nil。<br>
如果使用捕获（即对模式串用括号包裹起来）,则一并返回匹配得到的字符串。</p>

<h4>定义</h4>

<pre><code>string.find([字符串],[待查找字符串],[查找起始位置]=1,[禁用模式匹配]=false)
</code></pre>

<p>只有显式指定了 init 参数才能控制 plain 参数。</p>

<h4>例子</h4>

<pre><code>x,y,z = string.find("1001 is a Robot", "Robot")
print(x,y,z)                                --&gt; 11 15   nil
x,y,z = string.find("1001 is a Robot","1%d",1,true)
print(x,y,z)                                --&gt; nil nil nil
x,y,z = string.find("1001 is a Robot","(%d+)",1,false)
print(x,y,z)                                --&gt; 1   2   1001
</code></pre>

<h3> string.match(s,pattern[,init])</h3>

<p>与 <code>string.find</code> 类似，返回值不一样。<code>string.match</code> 查找字符串的子串，如果找到，返回子串；找不到返回 nil。</p>

<p>支持模式匹配。</p>

<h4>定义</h4>

<p>略</p>

<h4>例子</h4>

<pre><code>x = string.match("1001 is a Robot","001")
print(x)                --&gt; 001                             
x = string.match("1001 is a Robot","%d%d")
print(x)                --&gt; 10      
</code></pre>

<h3> string.gmatch(s,pattern)</h3>

<p>返回一个迭代函数，该函数每执行一次，就返回下一个捕捉到的匹配（如果没有使用捕捉，就返回整个匹配结果）。</p>

<h4>例子</h4>

<pre><code>for s in string.gmatch("I have a Dream.","%a+") do
    print(s)
end
--&gt; I
--&gt; have
--&gt; a
--&gt; Dream
</code></pre>

<pre><code>t = {}
s = "name=tangyikejun, number=20250001"

-- 将捕获的两个子串分别作为键和值放到表t中
for k, v in string.gmatch(s, "(%w+)=(%w+)") do
    t[k] = v
end

-- 输出表t
for k,v in pairs(t) do
    print(k,v)
end

--&gt; name    tangyikejun
--&gt; number  20250001
</code></pre>

<h3> string.format(formatstring,...)</h3>

<p>返回格式化之后的字符串。</p>

<h4>定义</h4>

<p>略</p>

<h4>例子</h4>

<pre><code>string.format("My name is %s", "tangyikejun")   --&gt; My name is tangyikejun
</code></pre>

<h3> string.len(s)</h3>

<p>返回字符串长度</p>

<h3> string.lower(s)</h3>

<p>返回小写字母的字符串</p>

<h3> string.upper(s)</h3>

<p>返回大写字母的字符串</p>

<h3> string.rep(s,n)</h3>

<p>对字符串进行重复</p>

<h4>定义</h4>

<pre><code>string.rep([字符串],[重复次数])
</code></pre>

<h4>例子</h4>

<pre><code>string.rep("Hello",4)   -- HelloHelloHelloHello
</code></pre>

<h3> string.reverse(s)</h3>

<p>返回反转后的字符串。</p>

<h3> string.sub(s,i[,j])</h3>

<p>返回子字符串。</p>

<h4>定义</h4>

<pre><code>string.sub([字符串],[开始字符下标],[结束字符下标]=-1)
</code></pre>

<h4>例子</h4>

<pre><code>x = string.sub("tangyikejun",7)
print(x)                --&gt; kejun
x = string.sub("tangyikejun",1,-6)
print(x)                --&gt; tangyi
</code></pre>

<h3> string.gsub(s,pattern,repl[,n])</h3>

<p>根据模式匹配对字符串中每一个匹配部分都做替换处理，返回替换后的字符串。</p>

<h4>定义</h4>

<pre><code>string.gsub([字符串],[模式匹配],[替换字符],[最大替换次数] = 无限制)
</code></pre>

<p>repl 参数（<code>[替换字符]</code>）支持 字符串、表、函数。</p>

<p>如果 repl 是字符串，那么该字符串就是用于替换的字符串。同时支持 <code>%n</code> 转义符操作，n 的范围是 0-9。n 范围为 [1,9] 时表示第 n 个捕获的匹配字符串，<code>%0</code> 表示整个匹配的字符串，<code>%%</code> 表示替换为一个 <code>%</code>。</p>

<p>如果 repl 是表，那么将捕获的第一个字符串作为键值（Key）进行查询（没有定义捕捉则以整个匹配的字符串为键值），查到的值作为替换的字符串。</p>

<p>如果 repl 是函数，那么每次匹配成功都会调用该函数，并以按序以所有捕捉作为参数传入函数。没有捕捉则以整个匹配的字符作为参数。</p>

<p>如果从表或函数得到是字符串或者是数字，就将其用于替换；如果得到的是 false 或 nil，那么匹配部分将不会发生变化。</p>

<h4>例子</h4>

<p>repl 为字符串</p>

<pre><code>s = "Never say die."
x = string.gsub(s,"die","never")            --&gt; Never say never.
x = string.gsub(s,"die","'%0'")             --&gt; Never say 'die'.
x = string.gsub(s,"(%a+)%s%a+%s(%a+)","%2") --&gt; die.
</code></pre>

<p>限制最大替换次数</p>

<pre><code>s = "never say never."
x = string.gsub(s,"never","Never",1)    --&gt; Never say never.
</code></pre>

<p>repl 是表</p>

<pre><code>t = {name="Lua",version="5.1"}
x = string.gsub("$name-$version.tar.gz","$(%a+)",t) --&gt; Lua-5.1.tar.gz
</code></pre>

<p>repl是函数</p>

<pre><code>x = string.gsub("4+5 = $return 4+5$","%$(.-)%$",function(s)return loadstring(s)() end)  --&gt; 4+5 = 9
x = string.gsub("23+45=$result", "((%d+)%+(%d+)=)%$%a+", function (s,a,b)
    sum = a+b
    return s..sum
end)    --&gt; 23+45=68
</code></pre>

<p>~~<strong>注意：</strong>似乎只支持匿名函数。~~</p>

<p>从表或函数返回的是 false 或 nil</p>

<pre><code>x = string.gsub("4+5 = $return 4+5$","%$(.-)%$",function(s)return nil end)  --&gt; 4+5 = $return 4+5$
t = {name="Lua",version=false}
x = string.gsub("$name-$version.tar.gz","$(%a+)",t) --&gt; Lua-$version.tar.gz
</code></pre>

<h3> string.byte(s[,i[,j]])</h3>

<p>返回字符的 ASCII 码值。</p>

<h4>定义</h4>

<pre><code>string.byte([字符串],[起始下标]=1,[结束下标]=[起始下标])
</code></pre>

<h4>例子</h4>

<pre><code>x,y,z = string.byte("abc",2)    --&gt; 98  nil nil
x,y,z = string.byte("abc",1,3)  --&gt; 97  98  99
</code></pre>

<h3> string.char(...)</h3>

<p>根据传入的 ASCII 编码值（[0-255]）得到对应的字符，传入多少编码值就返回多长的字符串。</p>

<h4>例子</h4>

<pre><code>x = string.char(98,99,100)  --&gt; bcd
</code></pre>

<p>如果输入字符超限会编译报错。</p>

<h3> string.dump(function)</h3>

<p>返回函数的二进制表示（字符串形式），把这个返回值传给 loadingstring 可以获得函数的一份拷贝（传入的函数必须是没有<strong>上值</strong>的 Lua 函数）。</p>

<h4>例子</h4>

<pre><code>function sum(a,b)
    return a + b
end

s = string.dump(sum)
x = loadstring(s)(4,4) -- 8
</code></pre>

<hr>
<h1>参考链接</h1>

<p><a rel="nofollow" href="http://blog.163.com/chenglian_999@126/blog/static/760002792009752402332/">BNF范式简介 </a>（简要介绍 BNF）<br><a rel="nofollow" href="http://www.jellythink.com/archives/882">Lua入门系列-果冻想</a>（对Lua进行了较为全面的介绍）<br><a rel="nofollow" href="https://docs.google.com/presentation/d/1gBGwwnmhkI5i45C5k4OmKSnAfBeqe_-nBFudUafgqHg/edit#slide=id.i52">Lua快速入门</a>（介绍 Lua 中最为重要的几个概念，为 C/C++ 程序员准备）<br><a rel="nofollow" href="http://manual.luaer.cn/">Lua 5.1 中文手册</a>（全面的 Lua5.1 中文手册）<br><a rel="nofollow" href="http://cloudwu.github.io/lua53doc/contents.html">Lua 5.3 中文手册</a>（云风花了6天写的，天哪，我看都要看6天的节奏呀）<br><a rel="nofollow" href="http://www.cnblogs.com/stephen-liu74/archive/2012/06/20/2413799.html">Lua迭代器和泛型for</a>（介绍 Lua 迭代器的详细原理以及使用）<br><a rel="nofollow" href="http://stackoverflow.com/questions/111102/how-do-javascript-closures-work">How do JavaScript closures work?——StackOverflow</a>（详细介绍了 Javascript 中闭包的概念）<br><a rel="nofollow" href="http://www.cnblogs.com/whiteyun/archive/2009/09/02/1541043.html">Lua模式匹配</a>（参考了此文中对 <code>%b</code> 的使用）<br><a rel="nofollow" href="http://w3.impa.br/~diego/software/luasocket/home.html">LuaSocket</a>（LuaSocket 官方手册）<br><a rel="nofollow" href="http://blog.sina.com.cn/s/blog_6a99c8bc0101krl8.html">Lua loadfile的用法, 与其他函数的比较</a>（loadfile的介绍部分引用了此文）<br><a rel="nofollow" href="http://segmentfault.com/a/1190000000410274">Lua 的元表</a>（对元表的描述比较有条理，通俗易懂，本文元表部分参考了此文）<br><a rel="nofollow" href="http://www.cnblogs.com/sifenkesi/p/3843348.html">设置函数环境——setfenv</a>（解释了如何方便地设置函数的环境，以及为什么要那样设置）<br><a rel="nofollow" href="http://blog.csdn.net/icyday/article/details/8116818">lua5.1中的setfenv使用</a>（介绍了该环境的设置在实际中的一个应用）</p>

2015年五月2日晚上 11:27:33
Lua 学习笔记（四）—— 元表与元方法
<p>我们可以使用操作符对 Lua 的值进行运算，例如对数值类型的值进行加减乘除的运算操作以及对字符串的连接、取长操作等（在 <a rel="nofollow" href="http://segmentfault.com/a/1190000002723520">Lua 学习笔记（三）—— 表达式</a> 中介绍了许多类似的运算）。<strong>元表</strong>正是定义这些操作行为的地方。</p>

<p>元表本质上是一个普通 Lua 表。元表中的键用来指定操作，称为“事件名”；元表中键所关联的值称为“元方法”，定义操作的行为。</p>

<h1>1 事件名与元方法</h1>

<p>仅表（table）类型值对应的元表可由用户自行定义。其他类型的值所对应的元表仅能通过 Debug 库进行修改。</p>

<p>元表中的事件名均以两条下划线 <code>__</code> 作为前缀，元表支持的事件名有如下几个：</p>

<pre><code>__index     -- 'table[key]'，取下标操作，用于访问表中的域
__newindex  -- 'table[key] = value'，赋值操作，增改表中的域
__call      -- 'func(args)'，函数调用，（参见 《Lua 学习笔记（三）—— 表达式》中的函数部分介绍）

-- 数学运算操作符
__add       -- '+'
__sub       -- '-'
__mul       -- '*'
__div       -- '/'
__mod       -- '%'
__pow       -- '^'
__unm       -- '-'

-- 连接操作符
__concat    -- '..'

-- 取长操作符
__len       -- '#'

-- 比较操作符
__eq        -- '=='
__lt        -- '&lt;'      -- a &gt; b 等价于 b &lt; a
__le        -- '&lt;='     -- a &gt;= b 等价于 b &lt;= a 
</code></pre>

<p>还有一些其他的事件，例如 <code>__tostring</code> 和 <code>__gc</code> 等。</p>

<p>下面进行详细介绍。</p>

<h1>2 元表与值</h1>

<p>每个值都可以拥有一个元表。对 userdata 和 table 类型而言，其每个值都可以拥有独立的元表，也可以几个值共享一个元表。对于其他类型，一个类型的值共享一个元表。例如所有数值类型的值会共享一个元表。除了字符串类型，其他类型的值默认是没有元表的。</p>

<p>使用 getmetatable 函数可以获取任意值的元表。<br>
使用 setmetatable 函数可以设置<strong>表类型</strong>值的元表。（这两个函数将在[基础函数库]部分进行介绍）</p>

<h2>2.1 例子</h2>

<p>只有字符串类型的值默认拥有元表：</p>

<pre><code>a = "5"
b = 5
c = {5}
print(getmetatable(a))      --&gt; table: 0x7fe221e06890
print(getmetatable(b))      --&gt; nil
print(getmetatable(c))      --&gt; nil
</code></pre>

<h1>3 事件的具体介绍</h1>

<p>事先提醒 Lua 使用 <code>raw</code> 前缀的函数来操作元方法，避免元方法的循环调用。</p>

<p>例如 Lua 获取对象 obj 中元方法的过程如下：</p>

<pre><code>rawget(getmetatable(obj)or{}, "__"..event_name)
</code></pre>

<h2>3.1 元方法 index</h2>

<p>index 是元表中最常用的事件,用于值的下标访问 -- <code>table[key]</code>。</p>

<p>事件 index 的值可以是函数也可以是表。当使用表进行赋值时，元方法可能引发另一次元方法的调用，具体可见下面伪码介绍。<br>
当用户通过键值来访问表时，如果没有找到键对应的值，则会调用对应元表中的此事件。如果 index 使用表进行赋值，则在该表中查找传入键的对应值；如果 index 使用函数进行赋值，则调用该函数，并传入表和键。</p>

<p>Lua 对取下标操作的处理过程用伪码表示如下：</p>

<pre><code>function gettable_event (table, key)
    -- h 代表元表中 index 的值
    local h     
    if type(table) == "table" then

        -- 访问成功
        local v = rawget(table, key)
        if v ~= nil then return v end

        -- 访问不成功则尝试调用元表的 index
        h = metatable(table).__index

        -- 元表不存在返回 nil
        if h == nil then return nil end
    else

        -- 不是对表进行访问则直接尝试元表
        h = metatable(table).__index

        -- 无法处理导致出错
        if h == nil then
            error(···);
        end
    end

    -- 根据 index 的值类型处理
    if type(h) == "function" then
        return h(table, key)            -- 调用处理器
    else 
        return h[key]                   -- 或是重复上述操作
    end
end
</code></pre>

<h3>3.1.1 例子</h3>

<p>使用表赋值：</p>

<pre><code>t = {[1] = "cat",[2] = "dog"}
print(t[3])             --&gt; nil
setmetatable(t, {__index = {[3] = "pig", [4] = "cow", [5] = "duck"}})
print(t[3])             --&gt; pig
</code></pre>

<p>使用函数赋值：</p>

<pre><code>t = {[1] = "cat",[2] = "dog"}
print(t[3])             --&gt; nil
setmetatable(t, {__index = function (table,key)
    key = key % 2 + 1
    return table[key]
end})
print(t[3])             --&gt; dog
</code></pre>

<h2>3.2 元方法 newindex</h2>

<p>newindex 用于赋值操作 -- <code>talbe[key] = value</code>。</p>

<p>事件 newindex 的值可以是函数也可以是表。当使用表进行赋值时，元方法可能引发另一次元方法的调用，具体可见下面伪码介绍。</p>

<p>当操作类型不是表或者表中尚不存在传入的键时，会调用 newindex 的元方法。如果 newindex 关联的是一个函数类型以外的值，则再次对该值进行赋值操作。反之，直接调用函数。</p>

<p>~~不是太懂：一旦有了 "newindex" 元方法， Lua 就不再做最初的赋值操作。 （如果有必要，在元方法内部可以调用 rawset 来做赋值。）~~</p>

<p>Lua 进行赋值操作时的伪码如下：</p>

<pre><code>function settable_event (table, key, value)
    local h
    if type(table) == "table" then

        -- 修改表中的 key 对应的 value
        local v = rawget(table, key)
        if v ~= nil then rawset(table, key, value); return end

        -- 
        h = metatable(table).__newindex

        -- 不存在元表，则直接添加一个域
        if h == nil then rawset(table, key, value); return end
    else
        h = metatable(table).__newindex
        if h == nil then
            error(···);
        end
    end

    if type(h) == "function" then
        return h(table, key,value)    -- 调用处理器
    else 


        h[key] = value             -- 或是重复上述操作
    end
end
</code></pre>

<h3>3.2.1 例子</h3>

<p>元方法为表类型：</p>

<pre><code>t = {}
mt = {}

setmetatable(t, {__newindex = mt})
t.a = 5
print(t.a)      --&gt; nil
print(mt.a)     --&gt; 5
</code></pre>

<p>通过两次调用 newindex 元方法将新的域添加到了表 mt 。</p>

<p>+++</p>

<p>元方法为函数：</p>

<pre><code>-- 对不同类型的 key 使用不同的赋值方式
t = {}
setmetatable(t, {__newindex = function (table,key,value)
    if type(key) == "number" then
        rawset(table, key, value*value)
    else
        rawset(table, key, value)
    end
end})
t.name = "product"
t[1] = 5
print(t.name)       --&gt; product
print(t[1])         --&gt; 25
</code></pre>

<h2>3.3 元方法 call</h2>

<p>call 事件用于函数调用 -- <code>function(args)</code>。</p>

<p>Lua 进行函数调用操作时的伪代码：</p>

<pre><code>function function_event (func, ...)

  if type(func) == "function" then
      return func(...)   -- 原生的调用
  else
      -- 如果不是函数类型，则使用 call 元方法进行函数调用
      local h = metatable(func).__call

      if h then
        return h(func, ...)
      else
        error(···)
      end
  end
end
</code></pre>

<h3>3.3.1 例子</h3>

<p>由于用户只能为表类型的值绑定自定义元表，因此，我们可以对表进行函数调用，而不能把其他类型的值当函数使用。</p>

<pre><code>-- 把数据记录到表中，并返回数据处理结果
t = {}

setmetatable(t, {__call = function (t,a,b,factor)
  t.a = 1;t.b = 2;t.factor = factor
  return (a + b)*factor
end})

print(t(1,2,0.1))       --&gt; 0.3

print(t.a)              --&gt; 1
print(t.b)              --&gt; 2
print(t.factor)         --&gt; 0.1
</code></pre>

<h2>3.4 运算操作符相关元方法</h2>

<p>运算操作符相关元方法自然是用来定义运算的。</p>

<p>以 add 为例，Lua 在实现 add 操作时的伪码如下：</p>

<pre><code>function add_event (op1, op2)
  -- 参数可转化为数字时，tonumber 返回数字，否则返回 nil
  local o1, o2 = tonumber(op1), tonumber(op2)
  if o1 and o2 then  -- 两个操作数都是数字？
    return o1 + o2   -- 这里的 '+' 是原生的 'add'
  else  -- 至少一个操作数不是数字时
    local h = getbinhandler(op1, op2, "__add") -- 该函数的介绍在下面
    if h then
      -- 以两个操作数来调用处理器
      return h(op1, op2)
    else  -- 没有处理器：缺省行为
      error(···)
    end
  end
end
</code></pre>

<p>代码中的 getbinhandler 函数定义了 Lua 怎样选择一个处理器来作二元操作。 在该函数中，首先，Lua 尝试第一个操作数。如果这个操作数所属类型没有定义这个操作的处理器，然后 Lua 会尝试第二个操作数。</p>

<pre><code> function getbinhandler (op1, op2, event)
   return metatable(op1)[event] or metatable(op2)[event]
 end
</code></pre>

<p>+++</p>

<p>对于一元操作符，例如取负，Lua 在实现 unm 操作时的伪码：</p>

<pre><code>function unm_event (op)
  local o = tonumber(op)
  if o then  -- 操作数是数字？
    return -o  -- 这里的 '-' 是一个原生的 'unm'
  else  -- 操作数不是数字。
    -- 尝试从操作数中得到处理器
    local h = metatable(op).__unm
    if h then
      -- 以操作数为参数调用处理器
      return h(op)
    else  -- 没有处理器：缺省行为
      error(···)
    end
  end
end
</code></pre>

<h3>3.4.1 例子</h3>

<p>加法的例子：</p>

<pre><code>t = {}
setmetatable(t, {__add = function (a,b)
  if type(a) == "number" then
      return b.num + a
  elseif type(b) == "number" then
      return a.num + b
  else
      return a.num + b.num
  end
end})

t.num = 5

print(t + 3)  --&gt; 8
</code></pre>

<p>取负的例子：</p>

<pre><code>t = {}
setmetatable(t, {__unm = function (a)
  return -a.num
end})

t.num = 5

print(-t)  --&gt; -5
</code></pre>

<h2>3.5 元方法 tostring</h2>

<p>对于 tostring 操作，元方法定义了值的字符串表示方式。</p>

<p><strong>例子：</strong></p>

<pre><code>t = {num = "a table"}
print(t)              --&gt; table: 0x7f8e83c0a820

mt = {__tostring = function(t)
  return t.num
end}
setmetatable(t, mt)

print(tostring(t))    --&gt; a table
print(t)              --&gt; a table
</code></pre>

<h2>3.6 比较类元方法</h2>

<p>对于三种比较类操作，均需要满足两个操作数为同类型，且关联同一个元表时才能使用元方法。</p>

<p>对于 eq （等于）比较操作，如果操作数所属类型没有原生的等于比较，则调用元方法。</p>

<p>对于 lt （小于）与 le （小于等于）两种比较操作，如果两个操作数同为数值或者同为字符串，则直接进行比较，否则使用元方法。</p>

<p>对于 le 操作，如果元方法 "le" 没有提供，Lua 就尝试 "lt"，它假定 a &lt;= b 等价于 not (b &lt; a) 。</p>

<h3>3.6.1 例子</h3>

<p>等于比较操作：</p>

<pre><code>t = {name="number",1,2,3}
t2 = {name = "number",4,5,6}
mt = {__eq = function (a,b)
    return a.name == b.name
end}
setmetatable(t,mt)              -- 必须要关联同一个元表才能比较
setmetatable(t2,mt)

print(t==t2)   --&gt; true
</code></pre>

<h2>3.7 其他事件的元方法</h2>

<p>对于连接操作，当操作数中存在数值或字符串以外的类型时调用该元方法。</p>

<p>对于取长操作，如果操作数不是字符串类型，也不是表类型，则尝试使用元方法（这导致自定义的取长基本没有，在之后的版本中似乎做了改进）。</p>

<h3>3.7.1 例子</h3>

<p>取长操作：</p>

<pre><code>t = {1,2,3,"one","two","three"}
setmetatable(t, {__len = function (t)
  local cnt = 0
  for k,v in pairs(t) do
    if type(v) == "number" then 
      cnt = cnt + 1
      print(k,v)
    end
  end
  return cnt
end})

-- 结果是 6 而不是预期中的 3
print(#t)   --&gt; 6 
</code></pre>

2015年五月2日晚上 11:19:16
防止表单多次提交
<div class="markdown-text"><h2>Node.js CSRF protection middleware</h2>
<p>这是防止表单多次提交的，原理是利用cookie和session生产token，和java里的token都是一样的概念</p>
<p>官方提供的中间件，还不错</p>
<p><a href="https://github.com/expressjs/csurf">https://github.com/expressjs/csurf</a></p>
<h2>ajax提交</h2>
<p>如果是ajax提交，就disable button吧</p>
</div>

2015年五月2日晚上 11:11:03
Lua 学习笔记（三）—— 表达式
<h1>1 数学运算操作符</h1>

<h2>1.1 <code>%</code> 操作符</h2>

<p>Lua 中的 <code>%</code> 操作符与 C 语言中的操作符虽然都是取模的含义，但是取模的方式不一样。<br>
在 C 语言中，取模操作是将两个操作数的绝对值取模后，在添加上第一个操作数的符号。<br>
而在 Lua 中，仅仅是简单的对商相对负无穷向下取整后的余数。</p>

<p>+++</p>

<p>在 C 中，</p>

<pre><code>a1 = abs(a);
b1 = abs(b);
c = a1 % b1 = a1 - floor(a1/b1)*b1;

a % b = (a &gt;= 0) ? c : -c;
</code></pre>

<p>在 Lua 中，</p>

<pre><code>a % b == a - math.floor(a/b)*b
</code></pre>

<p>Lua 是直接根据取模定义进行运算。 C 则对取模运算做了一点处理。</p>

<p>+++</p>

<p><strong>举例：</strong></p>

<p>在 C 中</p>

<pre><code>int a = 5 % 6;
int b = 5 % -6;
int c = -5 % 6;
int d = -5 % -6;

printf("a,b,c,d");--5,5,-5,-5
</code></pre>

<p>在 Lua 中</p>

<pre><code>a = 5 % 6
b = 5 % -6
c = -5 % 6
d = -5 % -6

x = {a,b,c,d}

for i,v in ipairs(x) do
    print(i,v)
end


--&gt; 5
--&gt; -1
--&gt; 1
--&gt; -5
</code></pre>

<p>可以看到，仅当操作数同号时，两种语言的取模结果相同。异号时，取模结果的符号与数值均不相等。</p>

<p>在 Lua 中的取模运算总结为：a % b，如果 a，b 同号，结果取 a，b 绝对值的模；异号，结果取 b 绝对值与绝对值取模后的差。取模后值的符号与 b 相同。</p>

<h1>2 比较操作符</h1>

<p>比较操作的结果是 <code>boolean</code> 型的，非 <code>true</code> 即 <code>false</code>。</p>

<p>支持的操作符有：</p>

<pre><code>&lt; &lt;= ~= == &gt; &gt;=
</code></pre>

<p>不支持 <code>!</code> 操作符。</p>

<p>+++</p>

<p>对于 <code>==</code> 操作，运算时先比较两个操作数的类型，如果不一致则结果为 false。此时数值与字符串之间并不会自动转换。</p>

<p>比较两个对象是否相等时，仅当指向同一内存区域时，判定为 <code>true</code>。·</p>

<pre><code>a = 123
b = 233
c = "123"
d = "123"
e = {1,2,3}
f = e
g = {1,2,3}

print(a == b)       --&gt; false
print(a == c)       --&gt; false      -- 数字与字符串作为不同类型进行比较
print(c == d)       --&gt; true       
print(e == f)       --&gt; true       -- 引用指向相同的对象
print(e == g)       --&gt; false      -- 虽然内容相同，但是是不同的对象
print(false == nil) --&gt; false      -- false 是 boolean，nil 是 nil 型
</code></pre>

<p>方便标记，<code>--&gt;</code> 代表前面表达式的结果。</p>

<p>+++</p>

<p><code>userdata</code> 与 <code>table</code> 的比较方式可以通过元方法 <code>eq</code> 进行改变。</p>

<p>大小比较中，数字和字符串的比较与 C 语言一致。如果是其他类型的值，Lua会尝试调用元方法 <code>lt</code> 和 <code>le</code>。</p>

<h1>3 逻辑操作符</h1>

<p><code>and,or,not</code></p>

<p>仅认为 <code>false</code> 与 <code>nil</code> 为假。</p>

<h2>3.1 <code>not</code>
</h2>

<p>取反操作 <code>not</code> 的结果为 <code>boolean</code> 类型。(<code>and</code> 和 <code>or</code> 的结果则不一定为 <code>boolean</code>)</p>

<pre><code>b = not a           -- a 为 nil，b 为 true
c = not not a       -- c 为 false
</code></pre>

<h2>3.2 <code>and</code>
</h2>

<p><code>a and b</code>，如果 <code>a</code> 为假，返回 <code>a</code>，如果 <code>a</code> 为真， 返回 <code>b</code>。</p>

<p>注意，为什么 <code>a</code> 为假的时候要返回 <code>a</code> 呢？有什么意义？这是因为 <code>a</code> 可能是 <code>false</code> 或者 <code>nil</code>，这两个值虽然都为假，但是是有区别的。</p>

<h2>3.3 <code>or</code>
</h2>

<p><code>a or b</code>，如果 <code>a</code> 为假，返回 <code>b</code>，如果 <code>a</code> 为真， 返回 <code>a</code>。与 <code>and</code> 相反。</p>

<p>+++</p>

<p><strong>提示：</strong> 当逻辑操作符用于得出一个 <code>boolean</code> 型结果时，不需要考虑逻辑运算后返回谁的问题，因为逻辑操作符的操作结果符合原本的逻辑含义。</p>

<p>举例</p>

<pre><code>if (not (a &gt; min and a &lt; max)) then  -- 如果 a 不在范围内，则报错
    error() 
end
</code></pre>

<p>+++</p>

<h2>3.4 其他</h2>

<p><code>and</code> 与 <code>or</code> 遵循短路原则，第二个操作数仅在需要的时候会进行求值操作。</p>

<p>例子</p>

<pre><code><br>a = 5
x = a or jjjj() -- 虽然后面的函数并没有定义，但是由于不会执行，因此不会报错。


print(a)        --&gt;5
print(x)        --&gt;5
</code></pre>

<p>通过上面这个例子，我们应当对于逻辑操作有所警觉，因为这可能会引入一些未能及时预料到的错误。</p>

<h1>4 连接符</h1>

<p><code>..</code><br>
连接两个字符串（或者数字）成为新的字符串。对于其他类型，调用元方法 <code>concat</code>。</p>

<h1>5 取长度操作符</h1>

<p><code>#</code></p>

<p>对于字符串，长度为字符串的字符个数。</p>

<p>对于表，通过寻找满足t[n] 不是 nil 而 t[n+1] 为 nil 的下标 n 作为表的长度。</p>

<p>~~对于其他类型呢？~~</p>

<h2>5.1 例子</h2>

<pre><code>-- 字符串取长
print(#"abc\0")                         --&gt; 4
-- 表取长
print(#{[1]=1,[2]=2,[3]=3,x=5,y=6})     --&gt; 3
print(#{[1]=1,[2]=nil,[3]=3,x=5,y=6})   --&gt; 1
</code></pre>

<h1>6 优先级</h1>

<p>由低到高：</p>

<pre><code>or
and
 &lt;     &gt;     &lt;=    &gt;=    ~=    ==
 ..
 +     -
 *     /     %
 not   #     - (unary)
 ^
</code></pre>

<p><strong>幂运算&gt;单目运算&gt;四则运算&gt;连接符&gt;比较操作符&gt;and&gt;or</strong></p>

<h1>7 Table 构造</h1>

<p>Table 构造的 BNF 定义</p>

<pre><code>tableconstructor ::= `{´ [fieldlist] `}´
fieldlist ::= field {fieldsep field} [fieldsep]
field ::= `[´ exp `]´ `=´ exp | Name `=´ exp | exp
fieldsep ::= `,´ | `;´
</code></pre>

<p>BNF 定义参考 <a rel="nofollow" href="http://blog.163.com/chenglian_999@126/blog/static/760002792009752402332/">BNF范式简介 </a> 。</p>

<p>举例：</p>

<pre><code>a = {}
b = {["price"] = 5; cost = 4; 2+5}
c = { [1] = 2+5, [2] = 2, 8, price = "abc", ["cost"] = 4} -- b 和 c 构造的表是等价的


print(b["price"])   --&gt; 5
print(b.cost)       --&gt; 4
print(b[1])         --&gt; 7       -- 未给出键值的，按序分配下标，下标从 1 开始

print(c["price"])   --&gt; abc
print(c.cost)       --&gt; 4
print(c[1])         --&gt; 8       
print(c[2])         --&gt; 2       
</code></pre>

<p><strong>注意：</strong></p>

<ul>
<li>未给出键值的，按序分配下标，下标从 1 开始</li>
<li>如果表中有相同的键，那么以靠后的那个值作为键对应的值</li>
</ul>
<p>上面这两条的存在使得上面的例子中 c<a rel="nofollow" href="http://blog.163.com/chenglian_999@126/blog/static/760002792009752402332/">1</a> 的输出值为 8。</p>

<p>+++</p>

<p>如果表中有相同的键，那么以靠后的那个值作为键对应的值。</p>

<pre><code>a = {[1] = 5,[1] = 6} -- 那么 a[1] = 6
</code></pre>

<p>+++</p>

<p>如果表的最后一个域是表达式形式，并且是一个函数，那么这个函数的所有返回值都会加入到表中。</p>

<pre><code>a = 1
function order()
    a = a + 1
    return 1,2,3,4
end

b = {order(); a; order(); }

c = {order(); a; (order());}

print(b[1])                     --&gt; 1       
print(b[2])                     --&gt; 2       -- 表中的值并不是一次把表达式都计算结束后再赋值的
print(b[3])                     --&gt; 1       
print(b[4])                     --&gt; 2       -- 表达式形式的多返回值函数

print(#b)                       --&gt; 6       -- 表的长度为 6                 
print(#c)                       --&gt; 3       -- 函数添加括号后表的长度为 3
</code></pre>

<h1>8 函数</h1>

<p>函数是一个表达式，其值为 function 类型的对象。函数每次执行都会被实例化。</p>

<h2>8.1 函数定义</h2>

<p>Lua 中实现一个函数可以有以下三种形式。</p>

<pre><code>f = function() [block] end
local f; f = function() [block] end
a.f = function() [block] end
</code></pre>

<p>Lua 提供语法糖分别处理这三种函数定义。</p>

<pre><code>function f() [block] end
local function f() [block] end
function a.f() [block] end
</code></pre>

<p>+++</p>

<p>上面 <code>local</code> 函数的定义之所以不是 <code>local f = function() [block] end</code>，是为了避免如下错误：</p>

<pre><code>local f = function()
    print("local fun")
    if i==0 then 
        f()             -- 编译错误:attempt to call global 'f' (a nil value)
        i = i + 1
    end
end
</code></pre>

<h2>8.2 函数的参数</h2>

<p>形参会通过实参来初始化为局部变量。</p>

<p>参数列表的尾部添加 <code>...</code> 表示函数能接受不定长参数。如果尾部不添加，那么函数的参数列表长度是固定的。</p>

<pre><code>f(a,b)
g(a,b,...)
h(a,...,b)              -- 编译错误
</code></pre>

<pre><code>f(1)                    --&gt; a = 1, b = nil
f(1,2)                  --&gt; a = 1, b = 2
f(1,2,3)                --&gt; a = 1, b = 2

g(1,2)                  --&gt; a = 1, b = 2, (nothing)
g(1,2,3)                --&gt; a = 1, b = 2, (3)
g(1,f(4,5),3)           --&gt; a = 1, b = 4, (3)
g(1,f(4,5))             --&gt; a = 1, b = 4, (5)

</code></pre>

<p>+++</p>

<p>还有一种形参为self的函数的定义方式：</p>

<pre><code>a.f = function (self, params) [block] end
</code></pre>

<p>其语法糖形式为：</p>

<pre><code>function a:f(params) [block] end
</code></pre>

<p>使用举例：</p>

<pre><code>a = {name = "唐衣可俊"}
function a:f()
    print(self.name)
end
a:f()                       --&gt; 唐衣可俊   -- 如果这里使用 a.f()，那么 self.name 的地方会报错 attempt to index local 'self';此时应该写为 a.f(a)
</code></pre>

<p><code>:</code> 的作用在于函数定义与调用的时候可以少写一个 <code>self</code> 参数。这种形式是对<code>方法</code>的模拟</p>

<h2>8.3 函数调用</h2>

<p>Lua 中的函数调用的BNF语法如下：</p>

<pre><code>functioncall ::= prefixexp args
</code></pre>

<p>如果 prefixexp 的值的类型是 function， 那么这个函数就被用给出的参数调用。 否则 prefixexp 的元方法 "call" 就被调用， call 的第一个参数就是 prefixexp 的值，接下来的是 args 参数列表（参见 <a rel="nofollow">2.8 元表 | Metatable</a>）。</p>

<p>函数调用根据是否传入 <code>self</code> 参数分为 <code>.</code> 调用和 <code>:</code> 调用。<br>
函数调用根据传入参数的类型，可以分为<strong>参数列表调用、表调用、字符串调用</strong>。</p>

<p><strong>[待完善]</strong></p>

<h2>8.4 函数闭包</h2>

<p><strong>如果一个函数访问了它的外部变量，那么它就是一个闭包。</strong></p>

<p>由于函数内部的变量均为局部变量，外界无法对其进行访问。这时如果外界想要改变局部变量的值，那么就可以使用闭包来实现这一目的。<br>
具体的实现过程大致是这样，函数内部有能够改变局部变量的子函数，函数将这个子函数返回，那么外界就可以通过使用这个子函数来操作局部变量了。</p>

<p><strong>例子：</strong>利用闭包来实现对局部变量进行改变</p>

<pre><code>-- 实现一个迭代器

function begin(i)
    local cnt = i

    return function ()      -- 这是一个匿名函数，实现了自增的功能；同时它也是一个闭包，因为访问了外部变量 cnt
        cnt = cnt + 1
        return cnt
    end
end


iterator = begin(2)     -- 设置迭代器的初值为 2 ，返回一个迭代器函数

print(iterator())           -- 执行迭代
print(iterator())

</code></pre>

<p><strong>提示：</strong> 关于闭包的更多说明可参考<a rel="nofollow" href="http://stackoverflow.com/questions/111102/how-do-javascript-closures-work">JavaScript 闭包是如何工作的?——StackOverflow</a></p>

<hr>
<h4>参考链接</h4>

<p><a rel="nofollow" href="http://blog.163.com/chenglian_999@126/blog/static/760002792009752402332/">BNF范式简介 </a>（简要介绍 BNF）<br><a rel="nofollow" href="http://stackoverflow.com/questions/111102/how-do-javascript-closures-work">How do JavaScript closures work?——StackOverflow</a>（详细介绍了 Javascript 中闭包的概念）</p>

2015年五月2日晚上 10:43:06
求问本地异步读文件的效率问题？
<div class="markdown-text"><p>当用ajax发送多个post请求时，总时间取决于最慢的那个请求。 但当在本地异步读多个文件的时候，总时间还是取决于最慢的那个吗？ 我在想在底层异步读多个文件会导致时间增长，并不会比并行读文件效率高多少，不知道实际情况应该怎么分析？</p>
</div>

2015年五月2日晚上 10:41:34
详说 Cookie, LocalStorage 与 SessionStorage
<blockquote>
  <p>本文最初发布于我的个人博客：<a rel="nofollow" href="http://jerryzou.com/posts/cookie-and-web-storage/">咀嚼之味</a></p>
</blockquote>

<p>最近在找暑期实习，其中百度、网易游戏、阿里的面试都问到一些关于HTML5的东西，问题大多是这样开头的：“你用过什么HTML5的技术呀？” 而后，每次都能扯到 Cookie 和 localStorage 有啥差别。这篇文章就旨在详细地阐述这部分内容，而具体 Web Storage API 的使用可以参考<a rel="nofollow" href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API">MDN的文档</a>，就不在这篇文章中赘述了。</p>

<h2>基本概念</h2>

<h3>Cookie</h3>

<p>Cookie 是小甜饼的意思。顾名思义，cookie 确实非常小，它的大小限制为4KB左右，是网景公司的前雇员 Lou Montulli 在1993年3月的发明。它的主要用途有保存登录信息，比如你登录某个网站市场可以看到“记住密码”，这通常就是通过在 Cookie 中存入一段辨别用户身份的数据来实现的。</p>

<h3>localStorage</h3>

<p>localStorage 是 HTML5 标准中新加入的技术，它并不是什么划时代的新东西。早在 IE 6 时代，就有一个叫 userData 的东西用于本地存储，而当时考虑到浏览器兼容性，更通用的方案是使用 Flash。而如今，localStorage 被大多数浏览器所支持，如果你的网站需要支持 IE6+，那以 userData 作为你的 polyfill 的方案是种不错的选择。</p>

<table>
<thead><tr>
<th>特性</th>
  <th>Chrome</th>
  <th>Firefox (Gecko)</th>
  <th>Internet Explorer</th>
  <th>Opera</th>
  <th>Safari (WebKit)</th>
</tr></thead>
<tbody>
<tr>
<td>localStorage</td>
  <td>4</td>
  <td>3.5</td>
  <td>8</td>
  <td>10.50</td>
  <td>4</td>
</tr>
<tr>
<td>sessionStorage</td>
  <td>5</td>
  <td>2</td>
  <td>8</td>
  <td>10.50</td>
  <td>4</td>
</tr>
</tbody>
</table>
<h3>sessionStorage</h3>

<p>sessionStorage 与 localStorage 的接口类似，但保存数据的生命周期与 localStorage 不同。做过后端开发的同学应该知道 Session 这个词的意思，直译过来是“会话”。而 sessionStorage 是一个前端的概念，它只是可以将一部分数据在当前会话中保存下来，刷新页面数据依旧存在。但当页面关闭后，sessionStorage 中的数据就会被清空。</p>

<h2>三者的异同</h2>

<table>
<thead><tr>
<th>特性</th>
            <th>Cookie</th>
            <th>localStorage</th>
            <th>sessionStorage</th>
        </tr></thead>
<tbody>
<tr>
<td>数据的生命期</td>
            <td>可设置失效时间，默认是关闭浏览器后失效</td>
            <td>除非被清除，否则永久保存</td>
            <td>仅在当前会话下有效，关闭页面或浏览器后被清除</td>
        </tr>
<tr>
<td>存放数据大小</td>
            <td>4K左右</td>
            <td>一般为5MB</td>
<td>一般为5MB</td>
        </tr>
<tr>
<td>与服务器端通信</td>
            <td>每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题</td>
            <td>仅在客户端（即浏览器）中保存，不参与和服务器的通信</td>
<td>仅在客户端（即浏览器）中保存，不参与和服务器的通信</td>
        </tr>
<tr>
<td>易用性</td>
            <td>需要程序员自己封装，源生的Cookie接口不友好</td>
            <td>源生接口可以接受，亦可再次封装来对Object和Array有更好的支持</td>
<td>源生接口可以接受，亦可再次封装来对Object和Array有更好的支持</td>
        </tr>
</tbody>
</table>
<h3>应用场景</h3>

<p>有了对上面这些差别的直观理解，我们就可以讨论三者的应用场景了。</p>

<p>因为考虑到每个 HTTP 请求都会带着 Cookie 的信息，所以 Cookie 当然是能精简就精简啦，比较常用的一个应用场景就是判断用户是否登录。针对登录过的用户，服务器端会在他登录时往 Cookie 中插入一段加密过的唯一辨识单一用户的辨识码，下次只要读取这个值就可以判断当前用户是否登录啦。曾经还使用 Cookie 来保存用户在电商网站的购物车信息，如今有了 localStorage，似乎在这个方面也可以给 Cookie 放个假了~</p>

<p>而另一方面 localStorage 接替了 Cookie 管理购物车的工作，同时也能胜任其他一些工作。比如HTML5游戏通常会产生一些本地数据，localStorage 也是非常适用的。如果遇到一些内容特别多的表单，为了优化用户体验，我们可能要把表单页面拆分成多个子页面，然后按步骤引导用户填写。这时候 sessionStorage 的作用就发挥出来了。</p>

<h2>安全性的考虑</h2>

<p>需要注意的是，不是什么数据都适合放在 Cookie、localStorage 和 sessionStorage 中的。使用它们的时候，需要时刻注意是否有代码存在 XSS 注入的风险。因为只要打开控制台，你就随意修改它们的值，也就是说如果你的网站中有 XSS 的风险，它们就能对你的 localStorage 肆意妄为。所以千万不要用它们存储你系统中的敏感数据。</p>

<h2>参考资料</h2>

<ul>
<li><a rel="nofollow" href="http://stackoverflow.com/questions/19867599/what-is-the-difference-between-localstorage-sessionstorage-session-and-cookie">what is the difference between localStorage, sessionStorage, session and cookie?</a></li>
<li><a rel="nofollow" href="http://stackoverflow.com/questions/3718349/html5-localstorage-security">HTML5 localStorage security</a></li>
<li><a rel="nofollow" href="http://zh.wikipedia.org/wiki/Cookie">维基百科 - Cookie</a></li>
<li><a rel="nofollow" href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API">Web Storage API</a></li>
<li><a rel="nofollow" href="http://han.guokai.blog.163.com/blog/static/13671827120112694851799/">浏览器本地数据（sessionStorage、localStorage、cookie）与server端数据</a></li>
<li><a rel="nofollow" href="http://www.cnblogs.com/yuzhongwusan/archive/2011/12/19/2293347.html">HTMl5的sessionStorage和localStorage</a></li>
<li><a rel="nofollow" href="http://www.cnblogs.com/xiaowei0705/archive/2011/04/19/2021372.html">HTML5 LocalStorage 本地存储</a></li>
</ul>

2015年五月2日晚上 10:39:20
Lua 学习笔记（二）—— 语句
<p>Lua 中的语句支持赋值，控制结构，函数调用，还有变量声明。</p>

<p>不允许空的语句段，因此 <code>;;</code> 是非法的。</p>

<h2>1 语句组 | chuncks</h2>

<pre><code>chunck ::= {stat[';']}
</code></pre>

<p>(<code>[';']</code> 应该是表示语句组后面 <code>;</code> 是可选项。)</p>

<h2>2 语句块 | blocks</h2>

<pre><code>block ::= chunck
stat ::= do block end
</code></pre>

<p>可以将一个语句块显式地写成语句组，可以用于控制局部变量的作用范围。</p>

<h2>3 赋值 | assignment</h2>

<p>Lua 支持多重赋值。</p>

<p>多重赋值时，按序将右边的表达式的值赋值给左值。右值不足补 nil，右值多余舍弃。</p>

<pre><code>b = 1
a,b = 4 -- a = 4,b = nil 
</code></pre>

<p>+++</p>

<p>Lua 在进行赋值操作时，会一次性把右边的表达式都计算出来后进行赋值。</p>

<pre><code>i = 5
i,a[i] = i+1, 7 -- i = 6 ,a[5] = 7
</code></pre>

<p>特别地，有</p>

<pre><code>x,y = y,x -- 交换 x，y 的值
</code></pre>

<p>+++</p>

<p>对全局变量以及表的域的赋值操作含义可以在元表中更改。</p>

<h2>4 控制结构</h2>

<h3>4.1 条件语句</h3>

<pre><code>if [exp]
    [block]
elseif [exp]
    [block]
else
    [block]
end
</code></pre>

<h3>4.2 循环语句</h3>

<pre><code>while [exp]
    [block]
end
</code></pre>

<p>+++</p>

<pre><code>repeat
    [block]
until [exp]
</code></pre>

<p>注意，由于 <code>repeat</code> 语句到 <code>until</code> 还未结束，因此在 <strong><code>until</code> 之后的表达式中可以使用 <code>block</code> 中定义的局部变量。</strong></p>

<p>例如：</p>

<pre><code>a = 1
c = 5
repeat
    b = a + c
    c = c * 2
until b &gt; 20
print(c)            --&gt;     40
</code></pre>

<p>+++</p>

<h3>4.3 <code>break</code> 和 <code>return</code>
</h3>

<p><code>break</code> 和 <code>return</code> 只能写在语句块的最后一句，如果实在需要写在语句块中间，那么就在两个关键词外面包围 <code>do end</code> 语句块。</p>

<pre><code>do break end
</code></pre>

<h2>5 <code>For</code> 循环</h2>

<p><code>for</code> 循环的用法比较多，单独拎出来讲。</p>

<p><code>for</code> 中的表达式会在循环开始前一次性求值，在循环过程中不再更新。</p>

<h3>5.1 数字形式</h3>

<pre><code>for [Name] = [exp],[exp],[exp] do [block] end
</code></pre>

<p>三个 exp 分别代表<strong>初值，结束值，步进</strong>。exp 的值均需要是一个数字。<br>
第三个 exp 默认为 1，可以省略。</p>

<pre><code>a = 0

for i = 1,6,2 do
    a = a + i
end
</code></pre>

<p>等价于</p>

<pre><code>int a = 0;
for (int i = 1; i &lt;= 6;i += 2){ // 取到等号，如果步进是负的，那么会取 i &gt;= 6
    a += i;
}
</code></pre>

<h3>5.2 迭代器形式</h3>

<p>迭代器形式输出一个表时，如果表中有函数，则输出的顺序及个数不确定（笔者测试得出的结果，具体原因未知）。</p>

<p>迭代器形式的 for 循环的实质</p>

<pre><code>-- 依次返回 迭代器、状态表、迭代器初始值
function mypairs(t)

    function iterator(t,i)
        i = i + 1
        i = t[i] and i      -- 如果 t[i] == nil 则 i = nil；否则 i = i
        return i,t[i]
    end

    return iterator,t,0

end

-- 一个表
t = {[1]="1",[2]="2"}

-- 迭代形式 for 语句的 等价形式
do
local f, s, var = mypairs(t)
    while true do
        local var1, var2 = f(s, var)
        var = var1
        if var == nil then break end

        -- for 循环中添加的语句
        print(var1,var2)

    end
end

-- 迭代形式 for 语句
for var1,var2 in mypairs(t) do
    print(var1,var2)
end

--&gt; 1   1
--&gt; 2   2
--&gt; 1   1
--&gt; 2   2
</code></pre>

<h4>5.2.1 数组形式</h4>

<pre><code>ary = {[1]=1,[2]=2,[5]=5}
for i,v in ipairs(ary) do
    print(v)                    --&gt; 1 2
end
</code></pre>

<p>从1开始，直到数值型下标结束或者值为 nil 时结束。</p>

<h4>5.2.2 表遍历</h4>

<pre><code>table = {[1]=1,[2]=2,[5]=5}
for k,v in pairs(table) do
    print(v)                    --&gt; 1 2 5
end
</code></pre>

<p>遍历整个表的键值对。</p>

<p>关于迭代器的更多内容，可参考<a rel="nofollow" href="http://www.cnblogs.com/stephen-liu74/archive/2012/06/20/2413799.html">Lua 迭代器和泛型 for</a>。</p>

<hr>
<h4>参考链接</h4>

<p><a rel="nofollow" href="http://www.cnblogs.com/stephen-liu74/archive/2012/06/20/2413799.html">Lua迭代器和泛型for</a>（介绍 Lua 迭代器的详细原理以及使用）</p>

2015年五月2日晚上 10:29:56
Lua 学习笔记（一）—— 基本语法
<h2>1 简介</h2>

<p>由 clean C 实现。需要被宿主程序调用，可以注入 C 函数。</p>

<h2>2 语法约定</h2>

<p>Lua 的语法基于 BNF 的语法规则。</p>

<p>Lua 对大小写敏感。</p>

<h3>2.1 保留关键字</h3>

<p>C 语言中没有的关键字有：</p>

<p><code>and</code> <code>elseif</code> <code>function</code><br><code>in</code> <code>nil</code> <code>local</code> <code>not</code> <code>or</code><br><code>repeat</code> <code>then</code> <code>until</code></p>

<p><strong>规范：</strong>全局变量以下划线开头。</p>

<h3>2.2 操作符</h3>

<p>C 语言中没有的操作符：</p>

<pre><code>^ 
~= 
//  -- 向下取整
</code></pre>

<p>Lua 中没有的操作符：</p>

<pre><code>+=
-=
</code></pre>

<h3>2.3 字符串定义</h3>

<h4>采用转义符：通过转义符表示那些有歧义的字符</h4>

<p>字符表示</p>

<pre><code>a           -- 代表字符 a
\97         -- 代表字符 a
\049        -- 代表数字字符 1 
</code></pre>

<p>其他转义符表示</p>

<pre><code>\\n         -- 代表字符串 \n
\n          -- 代表换行
</code></pre>

<p><strong>注意</strong>数字字符必须是三位。其他字符则不能超过三位。</p>

<h4>采用长括号:长括号内的所有内容都作为普通字符处理。</h4>

<pre><code>[[]]        -- 0级长括号
[==[]==]    -- 2级长括号
</code></pre>

<h2>3 值与类型</h2>

<p>Lua 是动态语言，变量没有类型，值才有。值自身携带类型信息。</p>

<p>Lua 有八种基本数据类型：<code>nil, boolean, number, string, function, userdata, thread, table</code>。</p>

<p>仅 <code>nil</code> 和 <code>false</code> 导致条件为假，其他均为真。</p>

<p><code>userdata</code> 类型变量用于保存 C 数据。 Lua 只能对该类数据进行使用，而不能进行创建或修改，保证宿主程序完全掌握数据。</p>

<p><code>thread</code> 用于实现协程（coroutine）。</p>

<p><code>table</code> 用于实现关联数组。<code>table</code> 允许任何类型的数据做索引，也允许任何类型做 <code>table</code> 域中的值（前述<br><code>任何类型</code> 不包含 nil）。<code>table</code> 是 Lua 中唯一的数据结构。<br>
由于函数也是一种值，所以 <code>table</code> 中可以存放函数。</p>

<p><code>function, userdata, thread, table</code> <strong>这些类型的值都是对象</strong>。这些类型的变量都<strong>只是保存变量的引用</strong>，并且在进行赋值，参数传递，函数返回等操作时不会进行任何性质的拷贝。</p>

<p>库函数 <code>type()</code> 返回变量的类型描述信息。</p>

<h3>3.1 强制转换</h3>

<p>Lua 提供<strong>数字</strong>与<strong>字符串</strong>间的自动转换。<br>
可以使用 format 函数控制数字向字符串的转换。</p>

<h2>4 变量</h2>

<p>变量有三种类型：<strong>全局变量、局部变量、表中的域</strong>。</p>

<p><strong>函数外</strong>的变量默认为全局变量，除非用 local 显示声明。<strong>函数内</strong>变量与函数的参数默认为局部变量。</p>

<p>局部变量的作用域为从声明位置开始到所在语句块结束（或者是直到下一个同名局部变量的声明）。</p>

<p><strong>变量的默认值均为 nil。</strong></p>

<pre><code><br>a = 5               -- 全局变量
local b = 5     -- 局部变量

function joke()
    c = 5           -- 局部变量
    local d = 6 -- 局部变量
end

print(c,d)      --&gt; nil nil

do 
    local a = 6 -- 局部变量
    b = 6           -- 全局变量
    print(a,b); --&gt; 6 6
end

print(a,b)      --&gt; 5 6

</code></pre>

<p>方便标记，<code>--&gt;</code> 代表前面表达式的结果。</p>

<h3>4.1 索引</h3>

<p>对 table 的索引使用方括号 <code>[]</code>。Lua使用语法糖提供 <code>.</code> 操作。</p>

<pre><code>t[i]
t.i                 -- 当索引为字符串类型时的一种简化写法
gettable_event(t,i) -- 采用索引访问本质上是一个类似这样的函数调用
</code></pre>

<h3>4.2 环境表</h3>

<p>所有全局变量放在一个环境表里，该表的变量名为 <code>_env</code> 。对某个全局变量 <code>a</code> 的访问即 <code>_env.a</code> （<code>_env_</code> 只是为了方便说明）。</p>

<p>每个函数作为变量持有一个环境表的引用，里面包含该函数可调用的所有变量。<br>
子函数会从父函数继承环境表。<br>
可以通过函数 <code>getfenv / setfenv</code> 来读写环境表。</p>

2015年五月2日晚上 10:10:54
Lua 学习笔记（上）
<h1> 1 简介</h1>

<p>由 clean C 实现。需要被宿主程序调用，可以注入 C 函数。</p>

<h1> 2 语法</h1>

<p>采用基于 BNF 的语法规则。</p>

<h2>  2.1 语法约定</h2>

<p>Lua 对大小写敏感。</p>

<h3>   2.1.1 保留关键字</h3>

<p>C 语言中没有的关键字有：</p>

<p><code>and</code> <code>elseif</code> <code>function</code><br><code>in</code> <code>nil</code> <code>local</code> <code>not</code> <code>or</code><br><code>repeat</code> <code>then</code> <code>until</code></p>

<p><strong>规范：</strong>全局变量以下划线开头。</p>

<h3>   2.1.2 操作符</h3>

<p>C 语言中没有的操作符：</p>

<pre><code>^ 
~= 
//  -- 向下取整
</code></pre>

<p>Lua 中没有的操作符：</p>

<pre><code>+=
-=
</code></pre>

<h3>   2.1.3 字符串定义</h3>

<h4>采用转义符：通过转义符表示那些有歧义的字符</h4>

<p>字符表示</p>

<pre><code>a           -- 代表字符 a
\97         -- 代表字符 a
\049        -- 代表数字字符 1 
</code></pre>

<p>其他转义符表示</p>

<pre><code>\\n         -- 代表字符串 \n
\n          -- 代表换行
</code></pre>

<p><strong>注意</strong>数字字符必须是三位。其他字符则不能超过三位。</p>

<h4>采用长括号:长括号内的所有内容都作为普通字符处理。</h4>

<pre><code>[[]]        -- 0级长括号
[==[]==]    -- 2级长括号
</code></pre>

<h2>    2.2 值与类型</h2>

<p>Lua 是动态语言，变量没有类型，值才有。值自身携带类型信息。</p>

<p>Lua 有八种基本数据类型：<code>nil, boolean, number, string, function, userdata, thread, table</code>。</p>

<p>仅 <code>nil</code> 和 <code>false</code> 导致条件为假，其他均为真。</p>

<p><code>userdata</code> 类型变量用于保存 C 数据。 Lua 只能对该类数据进行使用，而不能进行创建或修改，保证宿主程序完全掌握数据。</p>

<p><code>thread</code> 用于实现协程（coroutine）。</p>

<p><code>table</code> 用于实现关联数组。<code>table</code> 允许任何类型的数据做索引，也允许任何类型做 <code>table</code> 域中的值（前述<br><code>任何类型</code> 不包含 nil）。<code>table</code> 是 Lua 中唯一的数据结构。<br>
由于函数也是一种值，所以 <code>table</code> 中可以存放函数。</p>

<p><code>function, userdata, thread, table</code> <strong>这些类型的值都是对象</strong>。这些类型的变量都<strong>只是保存变量的引用</strong>，并且在进行赋值，参数传递，函数返回等操作时不会进行任何性质的拷贝。</p>

<p>库函数 <code>type()</code> 返回变量的类型描述信息。</p>

<h3>   2.2.1 强制转换</h3>

<p>Lua 提供<strong>数字</strong>与<strong>字符串</strong>间的自动转换。<br>
可以使用 format 函数控制数字向字符串的转换。</p>

<h2>    2.3 变量</h2>

<p>变量有三种类型：<strong>全局变量、局部变量、表中的域</strong>。</p>

<p><strong>函数外</strong>的变量默认为全局变量，除非用 local 显示声明。<strong>函数内</strong>变量与函数的参数默认为局部变量。</p>

<p>局部变量的作用域为从声明位置开始到所在语句块结束（或者是直到下一个同名局部变量的声明）。</p>

<p><strong>变量的默认值均为 nil。</strong></p>

<pre><code><br>a = 5               -- 全局变量
local b = 5     -- 局部变量

function joke()
    c = 5           -- 局部变量
    local d = 6 -- 局部变量
end

print(c,d)      --&gt; nil nil

do 
    local a = 6 -- 局部变量
    b = 6           -- 全局变量
    print(a,b); --&gt; 6 6
end

print(a,b)      --&gt; 5 6

</code></pre>

<p>方便标记，<code>--&gt;</code> 代表前面表达式的结果。</p>

<h3>   2.3.1 索引</h3>

<p>对 table 的索引使用方括号 <code>[]</code>。Lua使用语法糖提供 <code>.</code> 操作。</p>

<pre><code>t[i]
t.i                 -- 当索引为字符串类型时的一种简化写法
gettable_event(t,i) -- 采用索引访问本质上是一个类似这样的函数调用
</code></pre>

<h3>   2.3.2 环境表</h3>

<p>所有全局变量放在一个环境表里，该表的变量名为 <code>_env</code> 。对某个全局变量 <code>a</code> 的访问即 <code>_env.a</code> （<code>_env_</code> 只是为了方便说明）。</p>

<p>每个函数作为变量持有一个环境表的引用，里面包含该函数可调用的所有变量。<br>
子函数会从父函数继承环境表。<br>
可以通过函数 <code>getfenv / setfenv</code> 来读写环境表。</p>

<h2>    2.4 语句 | statement</h2>

<p>支持赋值，控制结构，函数调用，还有变量声明。</p>

<p>不允许空的语句段，因此 <code>;;</code> 是非法的。</p>

<h3>    2.4.1 语句组 | chuncks</h3>

<pre><code>chunck ::= {stat[';']}
</code></pre>

<p>(<code>[';']</code> 应该是表示语句组后面 <code>;</code> 是可选项。)</p>

<h3>    2.4.2 语句块 | blocks</h3>

<pre><code>block ::= chunck
stat ::= do block end
</code></pre>

<p>可以将一个语句块显式地写成语句组，可以用于控制局部变量的作用范围。</p>

<h3>    2.4.3 赋值 | assignment</h3>

<p>Lua 支持多重赋值。</p>

<p>多重赋值时，按序将右边的表达式的值赋值给左值。右值不足补 nil，右值多余舍弃。</p>

<pre><code>b = 1
a,b = 4 -- a = 4,b = nil 
</code></pre>

<p>+++</p>

<p>Lua 在进行赋值操作时，会一次性把右边的表达式都计算出来后进行赋值。</p>

<pre><code>i = 5
i,a[i] = i+1, 7 -- i = 6 ,a[5] = 7
</code></pre>

<p>特别地，有</p>

<pre><code>x,y = y,x -- 交换 x，y 的值
</code></pre>

<p>+++</p>

<p>对全局变量以及表的域的赋值操作含义可以在元表中更改。</p>

<h3>    2.4.4 控制结构</h3>

<h4>条件语句</h4>

<pre><code>if [exp]
    [block]
elseif [exp]
    [block]
else
    [block]
end
</code></pre>

<h4>循环语句</h4>

<pre><code>while [exp]
    [block]
end
</code></pre>

<p>+++</p>

<pre><code>repeat
    [block]
until [exp]
</code></pre>

<p>注意，由于 <code>repeat</code> 语句到 <code>until</code> 还未结束，因此在 <strong><code>until</code> 之后的表达式中可以使用 <code>block</code> 中定义的局部变量。</strong></p>

<p>例如：</p>

<pre><code>a = 1
c = 5
repeat
    b = a + c
    c = c * 2
until b &gt; 20
print(c)            --&gt;     40
</code></pre>

<p>+++</p>

<h4>
<code>break</code> 和 <code>return</code>
</h4>

<p><code>break</code> 和 <code>return</code> 只能写在语句块的最后一句，如果实在需要写在语句块中间，那么就在两个关键词外面包围 <code>do end</code> 语句块。</p>

<pre><code>do break end
</code></pre>

<h3>    2.4.5 <code>For</code> 循环</h3>

<p><code>for</code> 循环的用法比较多，单独拎出来讲。</p>

<p><code>for</code> 中的表达式会在循环开始前一次性求值，在循环过程中不再更新。</p>

<h4>数字形式</h4>

<pre><code>for [Name] = [exp],[exp],[exp] do [block] end
</code></pre>

<p>三个 exp 分别代表<strong>初值，结束值，步进</strong>。exp 的值均需要是一个数字。<br>
第三个 exp 默认为 1，可以省略。</p>

<pre><code>a = 0

for i = 1,6,2 do
    a = a + i
end
</code></pre>

<p>等价于</p>

<pre><code>int a = 0;
for (int i = 1; i &lt;= 6;i += 2){ // 取到等号，如果步进是负的，那么会取 i &gt;= 6
    a += i;
}
</code></pre>

<h4>迭代器形式</h4>

<p>迭代器形式输出一个表时，如果表中有函数，则输出的顺序及个数不确定（笔者测试得出的结果，具体原因未知）。</p>

<p>迭代器形式的 for 循环的实质</p>

<pre><code>-- 依次返回 迭代器、状态表、迭代器初始值
function mypairs(t)

    function iterator(t,i)
        i = i + 1
        i = t[i] and i      -- 如果 t[i] == nil 则 i = nil；否则 i = i
        return i,t[i]
    end

    return iterator,t,0

end

-- 一个表
t = {[1]="1",[2]="2"}

-- 迭代形式 for 语句的 等价形式
do
local f, s, var = mypairs(t)
    while true do
        local var1, var2 = f(s, var)
        var = var1
        if var == nil then break end

        -- for 循环中添加的语句
        print(var1,var2)

    end
end

-- 迭代形式 for 语句
for var1,var2 in mypairs(t) do
    print(var1,var2)
end

--&gt; 1   1
--&gt; 2   2
--&gt; 1   1
--&gt; 2   2
</code></pre>

<h5>数组形式</h5>

<pre><code>ary = {[1]=1,[2]=2,[5]=5}
for i,v in ipairs(ary) do
    print(v)                    --&gt; 1 2
end
</code></pre>

<p>从1开始，直到数值型下标结束或者值为 nil 时结束。</p>

<h5>表遍历</h5>

<pre><code>table = {[1]=1,[2]=2,[5]=5}
for k,v in pairs(table) do
    print(v)                    --&gt; 1 2 5
end
</code></pre>

<p>遍历整个表的键值对。</p>

<p>关于迭代器的更多内容，可参考<a rel="nofollow" href="http://www.cnblogs.com/stephen-liu74/archive/2012/06/20/2413799.html">Lua 迭代器和泛型 for</a>。</p>

<h2> 2.5 表达式</h2>

<h3> 2.5.1 数学运算操作符</h3>

<h4>
<code>%</code> 操作符</h4>

<p>Lua 中的 <code>%</code> 操作符与 C 语言中的操作符虽然都是取模的含义，但是取模的方式不一样。<br>
在 C 语言中，取模操作是将两个操作数的绝对值取模后，在添加上第一个操作数的符号。<br>
而在 Lua 中，仅仅是简单的对商相对负无穷向下取整后的余数。</p>

<p>+++</p>

<p>在 C 中，</p>

<pre><code>a1 = abs(a);
b1 = abs(b);
c = a1 % b1 = a1 - floor(a1/b1)*b1;

a % b = (a &gt;= 0) ? c : -c;
</code></pre>

<p>在 Lua 中，</p>

<pre><code>a % b == a - math.floor(a/b)*b
</code></pre>

<p>Lua 是直接根据取模定义进行运算。 C 则对取模运算做了一点处理。</p>

<p>+++</p>

<p><strong>举例：</strong></p>

<p>在 C 中</p>

<pre><code>int a = 5 % 6;
int b = 5 % -6;
int c = -5 % 6;
int d = -5 % -6;

printf("a,b,c,d");--5,5,-5,-5
</code></pre>

<p>在 Lua 中</p>

<pre><code>a = 5 % 6
b = 5 % -6
c = -5 % 6
d = -5 % -6

x = {a,b,c,d}

for i,v in ipairs(x) do
    print(i,v)
end


--&gt; 5
--&gt; -1
--&gt; 1
--&gt; -5
</code></pre>

<p>可以看到，仅当操作数同号时，两种语言的取模结果相同。异号时，取模结果的符号与数值均不相等。</p>

<p>在 Lua 中的取模运算总结为：a % b，如果 a，b 同号，结果取 a，b 绝对值的模；异号，结果取 b 绝对值与绝对值取模后的差。取模后值的符号与 b 相同。</p>

<h3> 2.5.2 比较操作符</h3>

<p>比较操作的结果是 <code>boolean</code> 型的，非 <code>true</code> 即 <code>false</code>。</p>

<p>支持的操作符有：</p>

<pre><code>&lt; &lt;= ~= == &gt; &gt;=
</code></pre>

<p>不支持 <code>!</code> 操作符。</p>

<p>+++</p>

<p>对于 <code>==</code> 操作，运算时先比较两个操作数的类型，如果不一致则结果为 false。此时数值与字符串之间并不会自动转换。</p>

<p>比较两个对象是否相等时，仅当指向同一内存区域时，判定为 <code>true</code>。·</p>

<pre><code>a = 123
b = 233
c = "123"
d = "123"
e = {1,2,3}
f = e
g = {1,2,3}

print(a == b)       --&gt; false
print(a == c)       --&gt; false      -- 数字与字符串作为不同类型进行比较
print(c == d)       --&gt; true       
print(e == f)       --&gt; true       -- 引用指向相同的对象
print(e == g)       --&gt; false      -- 虽然内容相同，但是是不同的对象
print(false == nil) --&gt; false      -- false 是 boolean，nil 是 nil 型
</code></pre>

<p>方便标记，<code>--&gt;</code> 代表前面表达式的结果。</p>

<p>+++</p>

<p><code>userdata</code> 与 <code>table</code> 的比较方式可以通过元方法 <code>eq</code> 进行改变。</p>

<p>大小比较中，数字和字符串的比较与 C 语言一致。如果是其他类型的值，Lua会尝试调用元方法 <code>lt</code> 和 <code>le</code>。</p>

<h3>    2.5.3 逻辑操作符</h3>

<p><code>and,or,not</code></p>

<p>仅认为 <code>false</code> 与 <code>nil</code> 为假。</p>

<h4><code>not</code></h4>

<p>取反操作 <code>not</code> 的结果为 <code>boolean</code> 类型。(<code>and</code> 和 <code>or</code> 的结果则不一定为 <code>boolean</code>)</p>

<pre><code>b = not a           -- a 为 nil，b 为 true
c = not not a       -- c 为 false
</code></pre>

<h4><code>and</code></h4>

<p><code>a and b</code>，如果 <code>a</code> 为假，返回 <code>a</code>，如果 <code>a</code> 为真， 返回 <code>b</code>。</p>

<p>注意，为什么 <code>a</code> 为假的时候要返回 <code>a</code> 呢？有什么意义？这是因为 <code>a</code> 可能是 <code>false</code> 或者 <code>nil</code>，这两个值虽然都为假，但是是有区别的。</p>

<h4><code>or</code></h4>

<p><code>a or b</code>，如果 <code>a</code> 为假，返回 <code>b</code>，如果 <code>a</code> 为真， 返回 <code>a</code>。与 <code>and</code> 相反。</p>

<p>+++</p>

<p><strong>提示：</strong> 当逻辑操作符用于得出一个 <code>boolean</code> 型结果时，不需要考虑逻辑运算后返回谁的问题，因为逻辑操作符的操作结果符合原本的逻辑含义。</p>

<p>举例</p>

<pre><code>if (not (a &gt; min and a &lt; max)) then  -- 如果 a 不在范围内，则报错
    error() 
end
</code></pre>

<p>+++</p>

<h4>其他</h4>

<p><code>and</code> 与 <code>or</code> 遵循短路原则，第二个操作数仅在需要的时候会进行求值操作。</p>

<p>例子</p>

<pre><code><br>a = 5
x = a or jjjj() -- 虽然后面的函数并没有定义，但是由于不会执行，因此不会报错。


print(a)        --&gt;5
print(x)        --&gt;5
</code></pre>

<p>通过上面这个例子，我们应当对于逻辑操作有所警觉，因为这可能会引入一些未能及时预料到的错误。</p>

<h3>    2.5.4 连接符</h3>

<p><code>..</code><br>
连接两个字符串（或者数字）成为新的字符串。对于其他类型，调用元方法 <code>concat</code>。</p>

<h3>    2.5.5 取长度操作符</h3>

<p><code>#</code></p>

<p>对于字符串，长度为字符串的字符个数。</p>

<p>对于表，通过寻找满足t[n] 不是 nil 而 t[n+1] 为 nil 的下标 n 作为表的长度。</p>

<p>~~对于其他类型呢？~~</p>

<h4>例子</h4>

<pre><code>-- 字符串取长
print(#"abc\0")                         --&gt; 4
-- 表取长
print(#{[1]=1,[2]=2,[3]=3,x=5,y=6})     --&gt; 3
print(#{[1]=1,[2]=nil,[3]=3,x=5,y=6})   --&gt; 1
</code></pre>

<h3>    2.5.6 优先级</h3>

<p>由低到高：</p>

<pre><code>or
and
 &lt;     &gt;     &lt;=    &gt;=    ~=    ==
 ..
 +     -
 *     /     %
 not   #     - (unary)
 ^
</code></pre>

<p><strong>幂运算&gt;单目运算&gt;四则运算&gt;连接符&gt;比较操作符&gt;and&gt;or</strong></p>

<h3>    2.5.7 Table 构造</h3>

<p>Table 构造的 BNF 定义</p>

<pre><code>tableconstructor ::= `{´ [fieldlist] `}´
fieldlist ::= field {fieldsep field} [fieldsep]
field ::= `[´ exp `]´ `=´ exp | Name `=´ exp | exp
fieldsep ::= `,´ | `;´
</code></pre>

<p>举例：</p>

<pre><code>a = {}
b = {["price"] = 5; cost = 4; 2+5}
c = { [1] = 2+5, [2] = 2, 8, price = "abc", ["cost"] = 4} -- b 和 c 构造的表是等价的


print(b["price"])   --&gt; 5
print(b.cost)       --&gt; 4
print(b[1])         --&gt; 7       -- 未给出键值的，按序分配下标，下标从 1 开始

print(c["price"])   --&gt; abc
print(c.cost)       --&gt; 4
print(c[1])         --&gt; 8       
print(c[2])         --&gt; 2       
</code></pre>

<p><strong>注意：</strong></p>

<ul>
<li>未给出键值的，按序分配下标，下标从 1 开始</li>
<li>如果表中有相同的键，那么以靠后的那个值作为键对应的值</li>
</ul>
<p>上面这两条的存在使得上面的例子中 c<a rel="nofollow" href="http://blog.163.com/chenglian_999@126/blog/static/760002792009752402332/">1</a> 的输出值为 8。</p>

<p>+++</p>

<p>如果表中有相同的键，那么以靠后的那个值作为键对应的值。</p>

<pre><code>a = {[1] = 5,[1] = 6} -- 那么 a[1] = 6
</code></pre>

<p>+++</p>

<p>如果表的最后一个域是表达式形式，并且是一个函数，那么这个函数的所有返回值都会加入到表中。</p>

<pre><code>a = 1
function order()
    a = a + 1
    return 1,2,3,4
end

b = {order(); a; order(); }

c = {order(); a; (order());}

print(b[1])                     --&gt; 1       
print(b[2])                     --&gt; 2       -- 表中的值并不是一次把表达式都计算结束后再赋值的
print(b[3])                     --&gt; 1       
print(b[4])                     --&gt; 2       -- 表达式形式的多返回值函数

print(#b)                       --&gt; 6       -- 表的长度为 6                 
print(#c)                       --&gt; 3       -- 函数添加括号后表的长度为 3
</code></pre>

<h3>    2.5.8 函数定义</h3>

<p>函数是一个表达式，其值为 function 类型的对象。函数每次执行都会被实例化。</p>

<p>Lua 中实现一个函数可以有以下三种形式。</p>

<pre><code>f = function() [block] end
local f; f = function() [block] end
a.f = function() [block] end
</code></pre>

<p>Lua 提供语法糖分别处理这三种函数定义。</p>

<pre><code>function f() [block] end
local function f() [block] end
function a.f() [block] end
</code></pre>

<p>+++</p>

<p>上面 <code>local</code> 函数的定义之所以不是 <code>local f = function() [block] end</code>，是为了避免如下错误：</p>

<pre><code>local f = function()
    print("local fun")
    if i==0 then 
        f()             -- 编译错误:attempt to call global 'f' (a nil value)
        i = i + 1
    end
end
</code></pre>

<h4>函数的参数</h4>

<p>形参会通过实参来初始化为局部变量。</p>

<p>参数列表的尾部添加 <code>...</code> 表示函数能接受不定长参数。如果尾部不添加，那么函数的参数列表长度是固定的。</p>

<pre><code>f(a,b)
g(a,b,...)
h(a,...,b)              -- 编译错误
</code></pre>

<pre><code>f(1)                    --&gt; a = 1, b = nil
f(1,2)                  --&gt; a = 1, b = 2
f(1,2,3)                --&gt; a = 1, b = 2

g(1,2)                  --&gt; a = 1, b = 2, (nothing)
g(1,2,3)                --&gt; a = 1, b = 2, (3)
g(1,f(4,5),3)           --&gt; a = 1, b = 4, (3)
g(1,f(4,5))             --&gt; a = 1, b = 4, (5)

</code></pre>

<p>+++</p>

<p>还有一种形参为self的函数的定义方式：</p>

<pre><code>a.f = function (self, params) [block] end
</code></pre>

<p>其语法糖形式为：</p>

<pre><code>function a:f(params) [block] end
</code></pre>

<p>使用举例：</p>

<pre><code>a = {name = "唐衣可俊"}
function a:f()
    print(self.name)
end
a:f()                       --&gt; 唐衣可俊   -- 如果这里使用 a.f()，那么 self.name 的地方会报错 attempt to index local 'self';此时应该写为 a.f(a)
</code></pre>

<p><code>:</code> 的作用在于函数定义与调用的时候可以少写一个 <code>self</code> 参数。这种形式是对<code>方法</code>的模拟</p>

<h3>    2.5.9 函数调用</h3>

<p>Lua 中的函数调用的BNF语法如下：</p>

<pre><code>functioncall ::= prefixexp args
</code></pre>

<p>如果 prefixexp 的值的类型是 function， 那么这个函数就被用给出的参数调用。 否则 prefixexp 的元方法 "call" 就被调用， call 的第一个参数就是 prefixexp 的值，接下来的是 args 参数列表（参见 <a rel="nofollow">2.8 元表 | Metatable</a>）。</p>

<p>函数调用根据是否传入 <code>self</code> 参数分为 <code>.</code> 调用和 <code>:</code> 调用。<br>
函数调用根据传入参数的类型，可以分为<strong>参数列表调用、表调用、字符串调用</strong>。</p>

<p><strong>[待完善]</strong></p>

<h3>    2.5.10 函数闭包</h3>

<p><strong>如果一个函数访问了它的外部变量，那么它就是一个闭包。</strong></p>

<p>由于函数内部的变量均为局部变量，外界无法对其进行访问。这时如果外界想要改变局部变量的值，那么就可以使用闭包来实现这一目的。<br>
具体的实现过程大致是这样，函数内部有能够改变局部变量的子函数，函数将这个子函数返回，那么外界就可以通过使用这个子函数来操作局部变量了。</p>

<p><strong>例子：</strong>利用闭包来实现对局部变量进行改变</p>

<pre><code>-- 实现一个迭代器

function begin(i)
    local cnt = i

    return function ()      -- 这是一个匿名函数，实现了自增的功能；同时它也是一个闭包，因为访问了外部变量 cnt
        cnt = cnt + 1
        return cnt
    end
end


iterator = begin(2)     -- 设置迭代器的初值为 2 ，返回一个迭代器函数

print(iterator())           -- 执行迭代
print(iterator())

</code></pre>

<p><strong>提示：</strong> 关于闭包的更多说明可参考<a rel="nofollow" href="http://stackoverflow.com/questions/111102/how-do-javascript-closures-work">JavaScript 闭包是如何工作的?——StackOverflow</a></p>

<h2>  2.6 可视规则</h2>

<p>即变量的作用域，见 <a rel="nofollow">2.3 变量</a> 部分。</p>

<h2>   2.7 错误处理</h2>

<p>[待补充]</p>

<h2>   2.8 元表 | Metatable</h2>

<p>我们可以使用操作符对 Lua 的值进行运算，例如对数值类型的值进行加减乘除的运算操作以及对字符串的连接、取长操作等（在 <a rel="nofollow">2.5 表达式</a> 这一节中介绍了许多类似的运算）。元表正是定义这些操作行为的地方。</p>

<p>元表本质上是一个普通 Lua 表。元表中的键用来指定操作，称为“事件名”；元表中键所关联的值称为“元方法”，定义操作的行为。</p>

<h3> 2.8.1 事件名与元方法</h3>

<p>仅表（table）类型值对应的元表可由用户自行定义。其他类型的值所对应的元表仅能通过 Debug 库进行修改。</p>

<p>元表中的事件名均以两条下划线 <code>__</code> 作为前缀，元表支持的事件名有如下几个：</p>

<pre><code>__index     -- 'table[key]'，取下标操作，用于访问表中的域
__newindex  -- 'table[key] = value'，赋值操作，增改表中的域
__call      -- 'func(args)'，函数调用，参见 [2.5.9 函数调用](#2-5-9)

-- 数学运算操作符
__add       -- '+'
__sub       -- '-'
__mul       -- '*'
__div       -- '/'
__mod       -- '%'
__pow       -- '^'
__unm       -- '-'

-- 连接操作符
__concat    -- '..'

-- 取长操作符
__len       -- '#'

-- 比较操作符
__eq        -- '=='
__lt        -- '&lt;'      -- a &gt; b 等价于 b &lt; a
__le        -- '&lt;='     -- a &gt;= b 等价于 b &lt;= a 
</code></pre>

<p>还有一些其他的事件，例如 <code>__tostring</code> 和 <code>__gc</code> 等。</p>

<p>下面进行详细介绍。</p>

<h3> 2.8.2 元表与值</h3>

<p>每个值都可以拥有一个元表。对 userdata 和 table 类型而言，其每个值都可以拥有独立的元表，也可以几个值共享一个元表。对于其他类型，一个类型的值共享一个元表。例如所有数值类型的值会共享一个元表。除了字符串类型，其他类型的值默认是没有元表的。</p>

<p>使用 getmetatable 函数可以获取任意值的元表。<a rel="nofollow">getmetatable (object)</a><br>
使用 setmetatable 函数可以设置<strong>表类型</strong>值的元表。<a rel="nofollow">setmetatable (table, metatable)</a></p>

<h4>例子</h4>

<p>只有字符串类型的值默认拥有元表：</p>

<pre><code>a = "5"
b = 5
c = {5}
print(getmetatable(a))      --&gt; table: 0x7fe221e06890
print(getmetatable(b))      --&gt; nil
print(getmetatable(c))      --&gt; nil
</code></pre>

<h3> 2.8.3 事件的具体介绍</h3>

<p>事先提醒 Lua 使用 <code>raw</code> 前缀的函数来操作元方法，避免元方法的循环调用。</p>

<p>例如 Lua 获取对象 obj 中元方法的过程如下：</p>

<pre><code>rawget(getmetatable(obj)or{}, "__"..event_name)
</code></pre>

<h4>元方法 index</h4>

<p>index 是元表中最常用的事件,用于值的下标访问 -- <code>table[key]</code>。</p>

<p>事件 index 的值可以是函数也可以是表。当使用表进行赋值时，元方法可能引发另一次元方法的调用，具体可见下面伪码介绍。<br>
当用户通过键值来访问表时，如果没有找到键对应的值，则会调用对应元表中的此事件。如果 index 使用表进行赋值，则在该表中查找传入键的对应值；如果 index 使用函数进行赋值，则调用该函数，并传入表和键。</p>

<p>Lua 对取下标操作的处理过程用伪码表示如下：</p>

<pre><code>function gettable_event (table, key)
    -- h 代表元表中 index 的值
    local h     
    if type(table) == "table" then

        -- 访问成功
        local v = rawget(table, key)
        if v ~= nil then return v end

        -- 访问不成功则尝试调用元表的 index
        h = metatable(table).__index

        -- 元表不存在返回 nil
        if h == nil then return nil end
    else

        -- 不是对表进行访问则直接尝试元表
        h = metatable(table).__index

        -- 无法处理导致出错
        if h == nil then
            error(···);
        end
    end

    -- 根据 index 的值类型处理
    if type(h) == "function" then
        return h(table, key)            -- 调用处理器
    else 
        return h[key]                   -- 或是重复上述操作
    end
end
</code></pre>

<p><strong>例子：</strong></p>

<p>使用表赋值：</p>

<pre><code>t = {[1] = "cat",[2] = "dog"}
print(t[3])             --&gt; nil
setmetatable(t, {__index = {[3] = "pig", [4] = "cow", [5] = "duck"}})
print(t[3])             --&gt; pig
</code></pre>

<p>使用函数赋值：</p>

<pre><code>t = {[1] = "cat",[2] = "dog"}
print(t[3])             --&gt; nil
setmetatable(t, {__index = function (table,key)
    key = key % 2 + 1
    return table[key]
end})
print(t[3])             --&gt; dog
</code></pre>

<h4>元方法 newindex</h4>

<p>newindex 用于赋值操作 -- <code>talbe[key] = value</code>。</p>

<p>事件 newindex 的值可以是函数也可以是表。当使用表进行赋值时，元方法可能引发另一次元方法的调用，具体可见下面伪码介绍。</p>

<p>当操作类型不是表或者表中尚不存在传入的键时，会调用 newindex 的元方法。如果 newindex 关联的是一个函数类型以外的值，则再次对该值进行赋值操作。反之，直接调用函数。</p>

<p>~~不是太懂：一旦有了 "newindex" 元方法， Lua 就不再做最初的赋值操作。 （如果有必要，在元方法内部可以调用 rawset 来做赋值。）~~</p>

<p>Lua 进行赋值操作时的伪码如下：</p>

<pre><code>function settable_event (table, key, value)
    local h
    if type(table) == "table" then

        -- 修改表中的 key 对应的 value
        local v = rawget(table, key)
        if v ~= nil then rawset(table, key, value); return end

        -- 
        h = metatable(table).__newindex

        -- 不存在元表，则直接添加一个域
        if h == nil then rawset(table, key, value); return end
    else
        h = metatable(table).__newindex
        if h == nil then
            error(···);
        end
    end

    if type(h) == "function" then
        return h(table, key,value)    -- 调用处理器
    else 


        h[key] = value             -- 或是重复上述操作
    end
end
</code></pre>

<p><strong>例子：</strong></p>

<p>元方法为表类型：</p>

<pre><code>t = {}
mt = {}

setmetatable(t, {__newindex = mt})
t.a = 5
print(t.a)      --&gt; nil
print(mt.a)     --&gt; 5
</code></pre>

<p>通过两次调用 newindex 元方法将新的域添加到了表 mt 。</p>

<p>+++</p>

<p>元方法为函数：</p>

<pre><code>-- 对不同类型的 key 使用不同的赋值方式
t = {}
setmetatable(t, {__newindex = function (table,key,value)
    if type(key) == "number" then
        rawset(table, key, value*value)
    else
        rawset(table, key, value)
    end
end})
t.name = "product"
t[1] = 5
print(t.name)       --&gt; product
print(t[1])         --&gt; 25
</code></pre>

<h4>元方法 call</h4>

<p>call 事件用于函数调用 -- <code>function(args)</code>。</p>

<p>Lua 进行函数调用操作时的伪代码：</p>

<pre><code>function function_event (func, ...)

  if type(func) == "function" then
      return func(...)   -- 原生的调用
  else
      -- 如果不是函数类型，则使用 call 元方法进行函数调用
      local h = metatable(func).__call

      if h then
        return h(func, ...)
      else
        error(···)
      end
  end
end
</code></pre>

<p><strong>例子：</strong></p>

<p>由于用户只能为表类型的值绑定自定义元表，因此，我们可以对表进行函数调用，而不能把其他类型的值当函数使用。</p>

<pre><code>-- 把数据记录到表中，并返回数据处理结果
t = {}

setmetatable(t, {__call = function (t,a,b,factor)
  t.a = 1;t.b = 2;t.factor = factor
  return (a + b)*factor
end})

print(t(1,2,0.1))       --&gt; 0.3

print(t.a)              --&gt; 1
print(t.b)              --&gt; 2
print(t.factor)         --&gt; 0.1
</code></pre>

<h4>运算操作符相关元方法</h4>

<p>运算操作符相关元方法自然是用来定义运算的。</p>

<p>以 add 为例，Lua 在实现 add 操作时的伪码如下：</p>

<pre><code>function add_event (op1, op2)
  -- 参数可转化为数字时，tonumber 返回数字，否则返回 nil
  local o1, o2 = tonumber(op1), tonumber(op2)
  if o1 and o2 then  -- 两个操作数都是数字？
    return o1 + o2   -- 这里的 '+' 是原生的 'add'
  else  -- 至少一个操作数不是数字时
    local h = getbinhandler(op1, op2, "__add") -- 该函数的介绍在下面
    if h then
      -- 以两个操作数来调用处理器
      return h(op1, op2)
    else  -- 没有处理器：缺省行为
      error(···)
    end
  end
end
</code></pre>

<p>代码中的 getbinhandler 函数定义了 Lua 怎样选择一个处理器来作二元操作。 在该函数中，首先，Lua 尝试第一个操作数。如果这个操作数所属类型没有定义这个操作的处理器，然后 Lua 会尝试第二个操作数。</p>

<pre><code> function getbinhandler (op1, op2, event)
   return metatable(op1)[event] or metatable(op2)[event]
 end
</code></pre>

<p>+++</p>

<p>对于一元操作符，例如取负，Lua 在实现 unm 操作时的伪码：</p>

<pre><code>function unm_event (op)
  local o = tonumber(op)
  if o then  -- 操作数是数字？
    return -o  -- 这里的 '-' 是一个原生的 'unm'
  else  -- 操作数不是数字。
    -- 尝试从操作数中得到处理器
    local h = metatable(op).__unm
    if h then
      -- 以操作数为参数调用处理器
      return h(op)
    else  -- 没有处理器：缺省行为
      error(···)
    end
  end
end
</code></pre>

<p><strong>例子：</strong></p>

<p>加法的例子：</p>

<pre><code>t = {}
setmetatable(t, {__add = function (a,b)
  if type(a) == "number" then
      return b.num + a
  elseif type(b) == "number" then
      return a.num + b
  else
      return a.num + b.num
  end
end})

t.num = 5

print(t + 3)  --&gt; 8
</code></pre>

<p>取负的例子：</p>

<pre><code>t = {}
setmetatable(t, {__unm = function (a)
  return -a.num
end})

t.num = 5

print(-t)  --&gt; -5
</code></pre>

<h4>其他事件的元方法</h4>

<p>对于连接操作，当操作数中存在数值或字符串以外的类型时调用该元方法。</p>

<p>对于取长操作，如果操作数不是字符串类型，也不是表类型，则尝试使用元方法（这导致自定义的取长基本没有，在之后的版本中似乎做了改进）。</p>

<p>对于三种比较类操作，均需要满足两个操作数为同类型，且关联同一个元表时才能使用元方法。</p>

<p>对于 eq （等于）比较操作，如果操作数所属类型没有原生的等于比较，则调用元方法。</p>

<p>对于 lt （小于）与 le （小于等于）两种比较操作，如果两个操作数同为数值或者同为字符串，则直接进行比较，否则使用元方法。</p>

<p>对于 le 操作，如果元方法 "le" 没有提供，Lua 就尝试 "lt"，它假定 a &lt;= b 等价于 not (b &lt; a) 。</p>

<p>对于 tostring 操作，元方法定义了值的字符串表示方式。</p>

<p><strong>例子：</strong></p>

<p>取长操作：</p>

<pre><code>t = {1,2,3,"one","two","three"}
setmetatable(t, {__len = function (t)
  local cnt = 0
  for k,v in pairs(t) do
    if type(v) == "number" then 
      cnt = cnt + 1
      print(k,v)
    end
  end
  return cnt
end})

-- 结果是 6 而不是预期中的 3
print(#t)   --&gt; 6 
</code></pre>

<p>等于比较操作：</p>

<pre><code>t = {name="number",1,2,3}
t2 = {name = "number",4,5,6}
mt = {__eq = function (a,b)
    return a.name == b.name
end}
setmetatable(t,mt)              -- 必须要关联同一个元表才能比较
setmetatable(t2,mt)

print(t==t2)   --&gt; true
</code></pre>

<p>tostring 操作：</p>

<pre><code>t = {num = "a table"}
print(t)              --&gt; table: 0x7f8e83c0a820

mt = {__tostring = function(t)
  return t.num
end}
setmetatable(t, mt)

print(tostring(t))    --&gt; a table
print(t)              --&gt; a table
</code></pre>

<h2>   2.9 环境表</h2>

<p>类型 <code>thread</code>、<code>function</code> 和 <code>userdata</code> 的对象除了能与元表建立关联外，还能关联一个环境表。</p>

<p>关联在线程上的环境表称为全局环境。<br>
全局环境作为子线程及子函数的默认环境。<br>
全局环境能够直接被 C 调用。</p>

<p>关联在 Lua 函数上的环境表接管函数对全局变量的所有访问。并且作为子函数的默认环境。</p>

<p>关联在 C 函数上的环境能直接被 C 调用。</p>

<p>关联在 <code>userdata</code> 上的环境没有实际的用途，只是为了方便程序员把一个表关联到 <code>userdata</code> 上。</p>

<h2>   2.10 垃圾回收</h2>

<h3>  2.10.1 垃圾收集的元方法</h3>

<p>[待补充]</p>

<h3>  2.10.2 弱表</h3>

<p>弱表是包含弱引用的表。</p>

<p>弱表的弱引用方式有三种。<strong>键弱引用，值弱引用，键和值均弱引用</strong>。</p>

<p>可以通过元表中的 <code>__mode</code> 域来设置一个表是否有弱引用，以及弱引用的方式。</p>

<pre><code>a = {}
b = { __mode = "k"}  -- 引号中添加 k 表示 key 弱引用，v 表示 value 弱引用， kv 表示均弱引用。
setmetable(a,b)     -- b 是 a 的元表，绑定后就不能在更改 __mode 的值。
</code></pre>

<p>垃圾回收机制会把弱引用的部分回收。但是不论是哪种弱引用，回收机制都会把整个键值对从弱表中移除。</p>

<h1> 3 程序接口 （API）</h1>

<p>这部分描述 Lua 的 C API，即用来与 Lua 进行通信的 C 函数，所有的函数和常量都定义在 <code>lua.h</code> 头文件里面。</p>

<p>有一部分 C 函数是用宏来实现的。~~<strong>为什么？：</strong>由于所有的宏只会使用他们的参数一次（除了第一个参数，即 <strong>Lua 状态机</strong>），所以不必担心宏展开带来的副作用。~~</p>

<p>默认情况下 Lua 在进行函数调用时不会检查函数的有效性和坚固性，如果想要进行检查，则使用 <code>luaconf.h</code> 中的 <code>luai_apicheck()</code> 函数开启。</p>

<h2> 3.1 堆栈</h2>

<p>Lua 调用 C API 时使用一个虚拟栈来传递参数，栈中的所有元素都是 Lua 的类型（例如 <code>boolean</code>，<code>table</code>，<code>nil</code>等）。</p>

<p>Lua 调用 C 函数的时候都会新建一个虚拟栈，而不是使用旧栈或者其他的栈。同时在 C 函数中，对 Lua API 调用时，只能使用当前调用所对应栈中的元素，其他栈的元素是无法访问的。<br>
虚拟栈中包含 C 函数所需的所有参数，函数的返回值也都放在该栈中。</p>

<p>这里所谓的栈概念并不是严格意义上的栈，可以通过下标对栈中的元素进行访问。1表示栈底，-1表示栈顶，又例如 3 表示从栈底开始的第三个元素。</p>

<h2> 3.2 堆栈尺寸</h2>

<p>由于 Lua 的 C API 默认不做有效性和坚固性（鲁棒性）检测，因此开发人员有责任保证坚固性。特别要注意的是，不能让堆栈溢出。Lua 只保证栈大小会大于 <code>LUA_MINSTACK</code>（一般是 20）。开发人员可以使用 <code>lua_checkstack</code> 函数来手动设置栈的大小。</p>

<h2> 3.3 伪索引</h2>

<p>除了用索引访问函数堆栈的 Lua 元素，C 代码还可以使用<strong>伪索引</strong>来访问堆栈以外的 Lua 元素，例如线程的环境、注册表、函数的环境 以及 C函数的 <code>upvalue</code>（上值）。可以通过特别声明来禁用伪索引。</p>

<p>线程的环境放在伪索引 <code>LUA_GLOBALSINDEX</code> 处，函数的环境放在伪索引 <code>LUA_ENVIRONINDEX</code> 处。</p>

<p>访问环境的方式跟访问表的方式是一致的，例如要访问全局变量的值，可以使用：</p>

<pre><code>lua_getfield(L,LUA_GLOBALSINDEX,varname)
</code></pre>

<h2> 3.4 C 闭包</h2>

<p>当我们把创建出来的函数和一些值关联在一起，就得到了一个闭包。那些关联起来的值称为 <code>upvalue</code> （上值）。</p>

<p>函数的上值都放在特定的伪索引处，可以通过 <code>lua_upvalueindex</code> 获取上值的伪索引。例如 <code>lua_upvalueindex(3)</code> 表示获取第三个关联值（按照关联顺序排列）对应的伪索引。</p>

<h2> 3.5 注册表</h2>

<p>Lua 提供了一个注册表，C 代码可以用来存放想要存放的 Lua 值。注册表用伪索引 <code>LUA_REGISTRYINDEX</code> 定位。</p>

<p>为了避免命名冲突，一般采用包含库名的字符串作为键名。~~<strong>什么东西？：</strong>或者可以取你自己 C 代码 中的一个地址，以 light userdata 的形式做键。~~</p>

<p>注册表中的整数键有特定用途（用于实现补充库的引用系统），不建议用于其他用途。</p>

<h2> 3.6 C 中的错误处理</h2>

<p>[待补充]</p>

<h2> 3.7 函数和类型</h2>

<p>本节介绍 C API 中的函数和类型。</p>

<p>余下部分见 <a rel="nofollow" href="http://segmentfault.com/a/1190000002723546">Lua 学习笔记（下）</a></p>

<hr>
<h1>参考链接</h1>

<p><a rel="nofollow" href="http://blog.163.com/chenglian_999@126/blog/static/760002792009752402332/">BNF范式简介 </a>（简要介绍 BNF）<br><a rel="nofollow" href="http://www.jellythink.com/archives/882">Lua入门系列-果冻想</a>（对Lua进行了较为全面的介绍）<br><a rel="nofollow" href="https://docs.google.com/presentation/d/1gBGwwnmhkI5i45C5k4OmKSnAfBeqe_-nBFudUafgqHg/edit#slide=id.i52">Lua快速入门</a>（介绍 Lua 中最为重要的几个概念，为 C/C++ 程序员准备）<br><a rel="nofollow" href="http://manual.luaer.cn/">Lua 5.1 中文手册</a>（全面的 Lua5.1 中文手册）<br><a rel="nofollow" href="http://cloudwu.github.io/lua53doc/contents.html">Lua 5.3 中文手册</a>（云风花了6天写的，天哪，我看都要看6天的节奏呀）<br><a rel="nofollow" href="http://www.cnblogs.com/stephen-liu74/archive/2012/06/20/2413799.html">Lua迭代器和泛型for</a>（介绍 Lua 迭代器的详细原理以及使用）<br><a rel="nofollow" href="http://stackoverflow.com/questions/111102/how-do-javascript-closures-work">How do JavaScript closures work?——StackOverflow</a>（详细介绍了 Javascript 中闭包的概念）<br><a rel="nofollow" href="http://www.cnblogs.com/whiteyun/archive/2009/09/02/1541043.html">Lua模式匹配</a>（参考了此文中对 <code>%b</code> 的使用）<br><a rel="nofollow" href="http://w3.impa.br/~diego/software/luasocket/home.html">LuaSocket</a>（LuaSocket 官方手册）<br><a rel="nofollow" href="http://blog.sina.com.cn/s/blog_6a99c8bc0101krl8.html">Lua loadfile的用法, 与其他函数的比较</a>（loadfile的介绍部分引用了此文）<br><a rel="nofollow" href="http://segmentfault.com/a/1190000000410274">Lua 的元表</a>（对元表的描述比较有条理，通俗易懂，本文元表部分参考了此文）<br><a rel="nofollow" href="http://www.cnblogs.com/sifenkesi/p/3843348.html">设置函数环境——setfenv</a>（解释了如何方便地设置函数的环境，以及为什么要那样设置）<br><a rel="nofollow" href="http://blog.csdn.net/icyday/article/details/8116818">lua5.1中的setfenv使用</a>（介绍了该环境的设置在实际中的一个应用）</p>

2015年五月2日晚上 9:00:36
PHP数组操作详解
<h2>概述</h2>

<p>要访问一个变量的内容，可以直接使用其名称。如果该变量是一个数组，可以使用变量名称和关键字或索引的组合来访问其内容。</p>

<p>像其他变量一样，使用运算符<code>=</code>可以改变数组元素的内容。数组单元可以通过 <code>array[key]</code> 语法来访问。</p>

<p><img src="/img/bVlACw" alt="图片描述"></p>

<h2>数组的基本操作</h2>

<h3>php定义数组：</h3>

<pre><code>&lt;?php  
    $array = array();  
    $array["key"] = "values";  
?&gt; 
</code></pre>

<p>在<code>PHP</code>中声明数组的方式主要有两种：</p>

<p>1.用<code>array()</code>函数声明数组，<br>
2.直接为数组元素赋值。</p>

<pre><code>&lt;?php
    //array数组
    $users = array('phone','computer','dos','linux');
    echo $users;//只会打印出数据类型Array
    print_r($users);//Array ( [0] =&gt; phone [1] =&gt; computer [2] =&gt; dos [3] =&gt; linux )

    $numbers = range(1,5);//创建一个包含指定范围的数组
    print_r($numbers);//Array ( [0] =&gt; 1 [1] =&gt; 2 [2] =&gt; 3 [3] =&gt; 4 [4] =&gt; 5 )
    print_r(true);//1
    var_dump(false);//bool(false)

//print_r可以把字符串和数字简单地打印出来，数组会以Array开头并已键值形式表示，print_r输出布尔值和null的结果没有意义，因此用var_dump更合适

//通过循环来显示数组里所有的值
    for($i = 0 ;$i &lt; 5;$i++){
        echo $users[$i];
        echo '&lt;br/&gt;';
    }

//通过count/sizeof统计数组中单元数目或对象中的属性个数

    for($i = 0; $i &lt; count($users);$i++){
        echo $users[$i];
        echo '&lt;br/&gt;';
    }
//还可以通过foreach循环来遍历数组，这种好处在于不需要考虑key
    foreach($users as $value){
        echo $value.'&lt;br/&gt;';//点号为字符串连接符号
    }
//foreach循环遍历 $key =&gt; $value；$key和$value是变量名，可以自行设置
    foreach($users as $key =&gt; $value){
        echo $key.'&lt;br/&gt;';//输出键
    }
?&gt;
</code></pre>

<h3>创建自定义键的数组</h3>

<pre><code>&lt;?php

    //创建自定义键的数组
    $ceo = array('apple'=&gt;'jobs','microsoft'=&gt;'Nadella','Larry Page','Eric');
    //如果不去声明元素的key,它会从零开始
    print_r($ceo);//Array ( [apple] =&gt; jobs [microsoft] =&gt; Nadella [0] =&gt; Larry Page [1] =&gt; Eric )

    echo $ceo['apple'];//jobs

     //php5.4起的用法
    $array = [
        "foo" =&gt; "bar",
        "bar" =&gt; "foo",
    ];

    print_r($array);//Array ( [foo] =&gt; bar [bar] =&gt; foo ) 

?&gt;    
</code></pre>

<p>从<code>php5.4</code> 起可以使用短数组定义语法，用 <code>[]</code> 替代 <code>array()</code>。有点类似于<code>javascript</code>中数组的定义。</p>

<h3>each()的使用</h3>

<pre><code>&lt;?php
    //通过为数组元素赋值来创建数组
    $ages['trigkit4'] = 22;
    echo $ages.'&lt;br/&gt;';//Array
    //因为相关数组的索引不是数字，所以无法通过for循环来进行遍历操作，只能通过foreach循环或list()和each()结构

    //each的使用
    //each返回数组中当前的键/值对并将数组指针向前移动一步
    $users = array('trigkit4'=&gt;22,'mike'=&gt;20,'john'=&gt;30);
    //print_r(each($users));//Array ( [1] =&gt; 22 [value] =&gt; 22 [0] =&gt; trigkit4 [key] =&gt; trigkit4 )

   //相当于：$a = array([0]=&gt;trigkit4,[1]=&gt;22,[value]=&gt;22,[key]=&gt;trigkit4);
    $a = each($users);//each把原来的数组的第一个元素拿出来包装成新数组后赋值给$a
    echo $a[0];//trigkit4

    //!!表示将真实存在的数据转换成布尔值
    echo !!each($users);//1

?&gt;  
</code></pre>

<p><code>each</code>的指针指向第一个键值对，并返回第一个数组元素，获取其键值对，并包装成新数组</p>

<h3>list()的使用</h3>

<p><code>list</code>用来把数组用的值赋给一些变量，看下面例子：</p>

<pre><code>&lt;?php

    $a = ['2','abc','def'];
    list($var1,$var2) = $a;
    echo $var1.'&lt;br/&gt;';//2
    echo $var2;//abc

    $a = ['name'=&gt;'trigkit4','age'=&gt;22,'0'=&gt;'boy'];
    //list只认识key为数字的索引
    list($var1,$var2) = $a;

    echo $var1;//boy

?&gt;
</code></pre>

<p>注：<code>list</code>只认识key为数字的索引</p>

<h2>数组元素的排序</h2>

<pre><code>反向排序:sort()、asort()和 ksort()都是正向排序,当然也有相对应的反向排序. 
实现反向:rsort()、arsort()和 krsort()。

array_unshift()函数将新元素添加到数组头,array_push()函数将每个新元素添加到数组 的末尾。
array_shift()删除数组头第一个元素,与其相反的函数是 array_pop(),删除并返回数组末 尾的一个元素。
array_rand()返回数组中的一个或多个键。

函数shuffle()将数组个元素进 行随机排序。
函数 array_reverse()给出一个原来数组的反向排序
</code></pre>

<h2>数组的各类API的使用</h2>

<pre><code>count()和 sizeof()统计数组下标的个数 
array_count_values()统计数组内下标值的个数

&lt;?php
    $numbers = array('100','2');
    sort($numbers,SORT_STRING);//按字符串排序，字符串只比较第一位大小
    print_r($numbers);//Array ( [0] =&gt; 100 [1] =&gt; 2 )

    $arr = array('trigkit4','banner','10');
    sort($arr,SORT_STRING);
    print_r($arr);//Array ( [0] =&gt; 10 [1] =&gt; banner [2] =&gt; trigkit4 )

    shuffle($arr);
    print_r($arr);//随机排序

    $array = array('a','b','c','d','0','1');
    array_reverse($array);
    print_r($array);//原数组的反向排序。 Array ( [0] =&gt; a [1] =&gt; b [2] =&gt; c [3] =&gt; d [4] =&gt; 0 [5] =&gt; 1 )


    //数组的拷贝
    $arr1  = array( '10' , 2);
    $arr2  =  &amp;$arr1 ;
    $arr2 [] =  4 ;  // $arr2 被改变了,$arr1仍然是array('10', 3)
    print_r($arr2);//Array ( [0] =&gt; 10 [1] =&gt; 2 [2] =&gt; 4 )

    //asort的使用
    $arr3  = &amp; $arr1 ;//现在arr1和arr3是一样的
    $arr3 [] =  '3' ;
    asort($arr3);//对数组进行排序并保留原始关系
    print_r($arr3);// Array ( [1] =&gt; 2 [2] =&gt; 3 [0] =&gt; 10 )

    //ksort的使用
    $fruits = array('c'=&gt;'banana','a'=&gt;'apple','d'=&gt;'orange');
    ksort($fruits);
    print_r($fruits);//Array ( [a] =&gt; apple [c] =&gt; banana [d] =&gt; orange )

   //unshift的使用
    array_unshift($array,'z');//开头处添加一元素
    print_r($array);//Array ( [0] =&gt; z [1] =&gt; a [2] =&gt; b [3] =&gt; c [4] =&gt; d [5] =&gt; 0 [6] =&gt; 1 )  

    //current(pos)的使用
    echo current($array);//z;获取当前数组中的当前单元

    //next的使用
    echo next($array);//a;将数组中的内部指针向前移动一位

    //reset的使用
    echo reset($array);//z;将数组内部指针指向第一个单元

    //prev的使用
    echo next($array);//a;
    echo prev($array);//z;倒回一位

    //sizeof的使用
    echo sizeof($array);//7；统计数组元素的个数

    //array_count_values
    $num = array(10,20,30,10,20,1,0,10);//统计数组元素出现的次数
    print_r(array_count_values($num));//Array ( [10] =&gt; 3 [20] =&gt; 2 [30] =&gt; 1 [1] =&gt; 1 [0] =&gt; 1 ) 

?&gt;    
</code></pre>

<p><code>current()</code>：每个数组都有一个内部指针指向他的当前单元，初始指向插入到数组中的第一个元素</p>

<h2>for循环遍历</h2>

<pre><code>&lt;?php
    $value = range(0,120,10);
    for($i=0;$i&lt;count($value);$i++){
        print_r($value[$i].' ');//0 10 20 30 40 50 60 70 80 90 100 110 120 
    }
?&gt;
</code></pre>

<h2>数组的实例</h2>

<h3>array_pad函数的使用</h3>

<pre><code>&lt;?php
    //array_pad函数，数组数组首尾选择性追加
    $num = array(1=&gt;10,2=&gt;20,3=&gt;30);
    $num = array_pad($num,4,40);
    print_r($num);//Array ( [0] =&gt; 10 [1] =&gt; 20 [2] =&gt; 30 [3] =&gt; 40 )

    $num = array_pad($num,-5,50);//array_pad(array,size,value)
    print_r($num);//Array ( [0] =&gt; 50 [1] =&gt; 10 [2] =&gt; 20 [3] =&gt; 30 [4] =&gt; 40 ) 
?&gt;
</code></pre>

<p><code>size</code>:指定的长度。整数则填补到右侧，负数则填补到左侧。</p>

<h3>unset()的使用</h3>

<pre><code> &lt;?php
    //unset()的使用
    $num = array_fill(0,5,rand(1,10));//rand(min,max)
    print_r($num);//Array ( [0] =&gt; 8 [1] =&gt; 8 [2] =&gt; 8 [3] =&gt; 8 [4] =&gt; 8 ) 
    echo '&lt;br/&gt;';

    unset($num[3]);
    print_r($num);//Array ( [0] =&gt; 8 [1] =&gt; 8 [2] =&gt; 8 [4] =&gt; 8 ) 
?&gt;
</code></pre>

<h3>array_fill()的使用</h3>

<pre><code>&lt;?php
    //array_fill()的使用
    $num = range('a','e');
    $arrayFilled = array_fill(1,2,$num);//array_fill(start,number,value)
    echo '&lt;pre&gt;';

    print_r($arrayFilled);

?&gt;
</code></pre>

<h3>array_combine()的使用</h3>

<pre><code>&lt;?PHP
    $number = array(1,2,3,4,5);
    $array = array("I","Am","A","PHP","er");
    $newArray = array_combine($number,$array);
    print_r($newArray);//Array ( [1] =&gt; I [2] =&gt; Am [3] =&gt; A [4] =&gt; PHP [5] =&gt; er ) 
?&gt; 
</code></pre>

<h3>array_splice()删除数组成员</h3>

<pre><code>&lt;?php
    $color = array("red", "green", "blue", "yellow");
    count ($color); //得到4
    array_splice($color,1,1); //删除第二个元素
    print_r(count ($color)); //3
    echo $color[2]; //yellow
    echo $color[1]; //blue
?&gt;  
</code></pre>

<h3>array_unique删除数组中的重复值</h3>

<pre><code>&lt;?php
    $color=array("red", "green", "blue", "yellow","blue","green");
    $result = array_unique($color);
    print_r($result);//Array ( [0] =&gt; red [1] =&gt; green [2] =&gt; blue [3] =&gt; yellow ) 
?&gt; 
</code></pre>

<h3>array_flip()交换数组的键值和值</h3>

<pre><code>&lt;?PHP
    $array = array("red","blue","red","Black");
    print_r($array);
    echo "&lt;br /&gt;";
    $array = array_flip($array);//
    print_r($array);//Array ( [red] =&gt; 2 [blue] =&gt; 1 [Black] =&gt; 3 ) 
?&gt; 
</code></pre>

<h3>array_search()搜索数值</h3>

<pre><code>&lt;meta charset="utf-8"&gt;
&lt;?php
   $array = array("red","blue","red","Black");
   $result=array_search("red",$array)//array_search(value,array,strict)
    if(($result === NULL)){
        echo "不存在数值red";
    }else{
        echo "存在数值 $result";//存在数值 0 
    }
?&gt; 
</code></pre>

2015年五月2日晚上 8:56:47
Linux 文件和文件夹的操作权限
<p>由于 linux 是多用户操作系统，所以基于安全的考虑，需要具备保障个人隐私和系统安全的机制。因此在使用 linux 系统的时候，经常会出现权限的问题(比如: 删除文件、安装软件、运行应用等等)，期初遇到这些问题的时候，大部分都使用<code>sudo</code>或者是<code>sudo chmod 777 file</code>(后面会讲解这个命令)来解决的。虽然这种方式可以解决问题，但是这样是不安全的，特别是在服务器上操作的时候，因为不是所有的文件和文件夹都可以被其它用户操作的，不是所有的用户都有<code>root</code>权限的，不是所有的应用都可以用<code>root</code>用户启动的。那么我们要如何正确的处理这些权限问题呢？那就让我们来学习一下 linux 权限相关的知识。</p>



<h3>用户的权限</h3>

<p>要确定一个用户对某个文件或文件夹是否具有相应的操作权限，先要明确该用户与文件或文件夹之间的关系。在 linux 系统中，定义了如下三种关系：</p>

<ul>
<li>
<strong>文件或文件夹的所有者 (owner)</strong>：文件或文件夹的拥有者，开始创建文件或文件夹时为创建者。</li>
<li>
<strong>组 (group)</strong>：文件或文件夹所属的组, 开始创建文件或文件夹时为创建者的所属的组。</li>
<li>
<strong>其他人 (other)</strong>：除了文件或文件夹的所有者和文件或文件夹所属的组的其他成员，剩下的 linux 的用户。</li>
</ul>
<p>因为在 linux 下的文件和文件夹都有<code>读取(r)</code>、<code>写入(w)</code>、<code>执行(x)</code>的操作，所以上面描述的每种关系的用户分别都可以赋予这些操作权限。操作权限介绍:</p>

<table>
<thead><tr>
<th>权限</th>
  <th>简写</th>
  <th>对普通文件的作用</th>
  <th>对文件夹的作用</th>
</tr></thead>
<tbody>
<tr>
<td>读取</td>
  <td>r</td>
  <td>查看文件内容</td>
  <td>列出文件夹中的文件(ls)</td>
</tr>
<tr>
<td>写入</td>
  <td>w</td>
  <td>修改文件内容</td>
  <td>在文件夹中删除、添加或重命名文件(夹)</td>
</tr>
<tr>
<td>执行</td>
  <td>x</td>
  <td>文件可以作为程序执行</td>
  <td>cd 到文件夹</td>
</tr>
</tbody>
</table>
<h3>文件或文件夹和用户的三种关系的基础操作权限</h3>

<p>在 linux 使用<code>ls -la</code>命令可以查看文件夹内文件的属性，下面是我电脑上某个文件夹下文件的属性:</p>

<pre><code>bash</code><code>$ ls -la
drwxr-xr-x 14 root root     4096 Apr  3 18:47 .
drwxr-xr-x 23 root root     4096 Mar  2 05:48 ..
drwxr-xr-x  2 root root     4096 Apr  3 07:44 backups
drwxr-xr-x 17 root root     4096 Jul 22  2014 cache
drwxr-xr-x  2 root root     4096 Mar  2 04:26 docker-registry
lrwxrwxrwx  1 root root        9 Feb 25 13:31 lock -&gt; /run/lock
drwxrwxr-x 15 root syslog   4096 Apr  3 07:44 log
-rw-r--r--  1 root root        0 Apr  3 18:47 test
</code></pre>

<ul>
<li><p>上面的有九列数据，第一列数据表示和文件或文件夹相应关系用户的操作权限，第二列表示文件夹内文件和文件夹的总数量(包括文件夹本身)，第三列表示文件夹或文件的拥有者，第四列表示文件或文件夹的所属的组，第五列表示文件或文件夹的大小，第六、七、八列表示文件或文件夹最后被修改的时间，第九列文件或文件夹的名字。</p></li>
<li>
<p>接下主要分析第一列的数据，在上面的信息中倒数第二行<code>drwxrwxr-x</code>，从左到右第一个字母表示文件系统对象的类别，这里<code>d</code>表示为目录(文件夹)。其它文件系统对象:</p>

<blockquote>
  <p><code>-</code>(常规文件)、<code>d</code>(目录)、<code>l</code>(符号链接)、<code>c</code>(字符特殊设备)、<code>b</code>(模块特殊设备)、<code>p</code>(FIFO)、<code>s</code>(套接字)</p>
</blockquote>
</li>
<li><p><code>drwxrwxr-x</code>除出去第一个字母<code>d</code>后的<code>rwxrwxr-x</code>表示的是三种用户关系对文件或文件夹的操作权限。从左到右每三个一组，依次表示所有者权限、组权限、其他用户权限。每组的顺序均为<code>rwx</code>，如果用户有相应的操作权限就用相应的字母表示，如果不具有相应的操作权限就用<code>-</code>表示。比如: <code>rwxrwxr-x</code>表示文件或文件夹的所有者具有<code>rwx</code>(可读，可写，可执行)的操作权限，组用户也具有<code>rwx</code>(可读，可写，可执行)的权限，其他用户具有<code>r-x</code>(可读，可执行，没有可读)的操作权限。</p></li>
</ul>
<h3>特殊权限<code>SUID</code>、<code>SGID</code>、<code>Sticky</code>
</h3>

<p>在 linux 系统中还有三种与用户身份无关的三个文件权限属性。即<code>SUID、SGID和Sticky</code>。</p>

<ul>
<li>
<p><strong><em>SUID(Set User ID, 4):</em></strong></p>

<blockquote>
  <p>该属性只对有执行权限的文件有效，对目录无效。执行具有<code>SUID</code>权限的程序时，引发的进程的所有者是程序文件的所有者，而不是启动程序的用户（除非二者是同一个人）。比如，如果一个程序的所有者是<code>root</code>且具有<code>SUID</code>属性，一个普通用户执行此程序时，如同<code>root</code>执行此程序一样。（请注意该属性对<code>Shell</code>脚本程序无效）该属性为一些特殊程序（如lpr）的启动带来了方便。但有时也带来了安全隐患：比如一个具有<code>SUID</code>属性的程序如果在执行时运行了一个<code>shell</code>，那么用户可以籍此得到系统的最高权限。<code>SUID</code>可用<code>s</code>表示，如:</p>
</blockquote>

<pre><code>bash</code><code>$ ls -l /usr/bin/passwd
-rwsr-xr-x 1 root root 47032 Feb 16  2014 /usr/bin/passwd
</code></pre>
</li>
<li>
<p><strong><em>SGID(Set Group ID, 4):</em></strong></p>

<blockquote>
  <p>对于可执行文件，<code>SGID</code>与<code>SUID</code>类似，引发的进程的所有组是程序文件所属的组。对于目录，<code>SGID</code>属性会使目录中新建文件的所属组与该目录相同。<code>SGID</code>也可以用s表示，如:</p>
</blockquote>

<pre><code>bash</code><code>$ ls -l /var
drwxrwsr-x  2 root staff    4096 Apr 10  2014 local
drwxrwxr-x 15 root syslog   4096 Apr  4 19:57 log
</code></pre>
</li>
<li>
<p><strong><em>Sticky, 1:</em></strong></p>

<blockquote>
  <p>仅对目录有效。带<code>sticky</code>属性的目录下的文件或目录可以被其拥有者删除或改名。常利用<code>sticky</code>属性创建这样的目录：组用户可以在此目录中创建新文件、修改文件内容，但只有文件所有者才能对自己的文件进行删除或改名。如系统中的<code>/tmp</code>文件夹。在属性字符串中，通常用t表示。</p>
</blockquote>

<pre><code>bash</code><code>$ ls -l /
drwxrwxrwt   8 root root  4096 Apr  4 23:57 tmp
</code></pre>
</li>
</ul>
<h3>修改文件或文件夹对应用户的操作权限</h3>

<p>在 linux 系统中，可以使用<code>chmod</code>命令来修改文件或文件夹对应用户的操作权限，<code>chmod</code>命令也有两种方式修改，一种是使用代表相应操作权限的字母简写表示，另一种是使用代表相应操作权限的数字表示。</p>

<ul>
<li>
<p><strong><em>使用简写字母</em></strong></p>

<blockquote>
  <p><code>chmod</code>语法参数格式: [ugoa][[+-=][rwxst]<br>
  第一个字符是u、g、 o 或 a 中的一个（分别表示用户、组、其他人和所有人）。还可以选择添加（+）、删除（-）或设置（=）各种不同权限。</p>
</blockquote>

<ul>
<li>给文件或文件夹<code>try</code>的拥有者加可执行权限</li>
</ul>
<pre><code>bash</code><code>$ sudo chmod u+x try
</code></pre>

<ul>
<li>给文件或文件夹<code>try</code>的拥有者和组成员加可读可写权限</li>
</ul>
<pre><code>bash</code><code>$ sudo chmod ug+rw try
</code></pre>

<ul>
<li>给文件或文件夹<code>try</code>的拥有者和组成员除去可写权限</li>
</ul>
<pre><code>bash</code><code>$ sudo chmod ug-r try
</code></pre>
</li>
<li>
<p><strong><em>使用数字表示(八进制数)</em></strong></p>

<blockquote>
  <p>为了简化表述，也可使用八进制数来表示权限。即用一个四位八进制数来表示，其中最高位表示特殊权限，随后的三位依次是所有者权限、组权限和其他人权限。每一个八进制位的权限数值是文件具有的相应权限所对应的数值之后，如：</p>
</blockquote>

<pre><code>bash</code><code>0755=rwxr-xr-x=0(4+2+1)(4+0+1)(4+0+1)
</code></pre>

<blockquote>
  <p>数值权限的算法，比如<code>rw-</code>其实就是<code>110</code>的二进制，也就是<code>0*2^0 + 1*2^1 + 1*2^2 = 6</code>。有相应的权限就用<code>1</code>表示，没有相应的权限就用<code>0</code>表示。不过这种算法特殊权限不包含在内。</p>
</blockquote>

<ul>
<li>给文件或文件夹<code>try</code>的拥有者加<code>rwx</code>权限，组用户加<code>r-x</code>权限，其他用户<code>r--</code>权限</li>
</ul>
<pre><code>bash</code><code>$ sudo chmod 0754 try
</code></pre>

<ul>
<li>
<code>chmod</code>命令也可以递归的修改文件夹下所有的文件的权限，如给 try 文件夹下得所有文件加上 0755 权限</li>
</ul>
<pre><code>bash</code><code>$ sudo chmod -R 0755 try
</code></pre>

<ul>
<li>批量只修改文件或文件夹权限</li>
</ul>
<pre><code>bash</code><code>$ find -type d|xargs chmod 745     // 只修改文件夹权限
$ find -type f|xargs chmod 644     // 只修改文件权限
// 或者
$ chmod 745 `find 路径 -type d`     // 只修改文件夹权限
$ chmod 644 `find 路径 -type f`    // 只修改文件权限
</code></pre>

<ul>
<li>相应权限的数值:<br>
&gt; - <code>rwx</code>(7)、<code>rw-</code>(6)、<code>r-x</code>(5)、<code>r--</code>(4)、<code>--wx</code>(3)、<code>-w-</code>(2)、<code>--x</code>(1)、<code>---</code>(0)<br>
&gt; - suid: 符号<code>s</code>(4)<br>
&gt; - sgid: 符号<code>s</code>(2)<br>
&gt; - sticky: 符号<code>t</code>(1)</li>
</ul>
</li>
</ul>
<h3>修改文件或文件夹的拥有者和所属的组</h3>

<p>使用<code>chown</code>可以修改文件或文件夹的拥有者和所属的组。</p>

<ul>
<li>
<p>将文件或文件夹<code>try</code>的拥有者修改成<code>aikin</code>，所属的组修改成<code>adm</code></p>

<pre><code>bash</code><code>$ sudo chown aikin:adm try
</code></pre>
</li>
<li>
<p>和<code>chmod</code>一样，<code>-R</code>参数可以起到递归的作用</p>

<pre><code>bash</code><code>$ sudo chown -R aikin:adm try
</code></pre>
</li>
</ul>
<h3>创建组和用户</h3>

<ul>
<li>
<p><strong><em>组相关操作：</em></strong></p>

<ul>
<li>创建一个<code>try</code>组</li>
</ul>
<pre><code>bash</code><code>$ sudo groupadd  try
</code></pre>

<ul>
<li>修改<code>try</code>组的名字为<code>rename-try</code>
</li>
</ul>
<pre><code>bash</code><code>$ sudo groupadd -n rename-try try
</code></pre>

<ul>
<li>修改<code>try</code>组的名字为<code>rename-try</code>
</li>
</ul>
<pre><code>bash</code><code>$ sudo groupadd -n rename-try try
</code></pre>

<ul>
<li>删除<code>try2</code>组</li>
</ul>
<pre><code>bash</code><code>$ sudo groupdel  try2
</code></pre>

<ul>
<li>查看所有组</li>
</ul>
<pre><code>bash</code><code>$ sudo cat /etc/group
</code></pre>
</li>
<li>
<p><strong><em>用户相关操作：</em></strong></p>

<ul>
<li>创建用户<code>test</code><br>
&gt; 在 linux 系统上虽然可以使用<code>useradd</code>或<code>adduser</code>来创建用户，但是这两个命令是有区别的。<br>
&gt; 1. 使用<code>useradd</code>时，如果后面不添加任何参数选项，例如：<code>$sudo useradd test</code>创建出来的用户将是默认“三无”用户：一无Home Directory，二无密码，三无系统Shell。<br>
&gt; 2. 使用<code>adduser</code>时，创建用户的过程更像是一种人机对话，系统会提示你输入各种信息，然后会根据这些信息帮你创建新用户。<br>
&gt; 下面创建用户使用的是<code>adduser</code>命令:</li>
</ul>
<pre><code>bash</code><code>$ sudo adduser test
Adding user `test' ...
Adding new group `test' (1002) ...
Adding new user `test' (1001) with group `test' ...
Creating home directory `/home/test' ...
Copying files from `/etc/skel' ...
Enter new UNIX password:
Retype new UNIX password:
passwd: password updated successfully
Changing the user information for test
Enter the new value, or press ENTER for the default
Full Name []: test
Room Number []:
Work Phone []:
Home Phone []:
Other []:
Is the information correct? [Y/n] y
</code></pre>

<ul>
<li>修改用户</li>
</ul>
<pre><code>bash</code><code>$ sudo passwd test    // 修改用户密码
$ sudo usermod -d /home/test -G try2 test   // 将test用户的登录目录改成/home/test，并加入 try 组，注意这里是大 G。
$ sudo gpasswd -a test try     // 将用户 test 加入到 try2 组。
$ sudo gpasswd -d test try2    // 将用户 test 从 try 组中移除
</code></pre>

<ul>
<li>删除用户<code>test</code>
</li>
</ul>
<pre><code>bash</code><code>$ sudo userdel test
</code></pre>

<ul>
<li>查看所有用户</li>
</ul>
<pre><code>bash</code><code>$ cut -d : -f 1 /etc/passwd
// 或者
$ cat /etc/passwd |awk -F \: '{print $1}'
</code></pre>
</li>
</ul>
<p>　　<strong><em>了解 linux 用户操作权限，安全就掌握在手中。</em></strong></p>

<h2>参考</h2>

<ul>
<li><a rel="nofollow" href="http://www.ibm.com/developerworks/cn/linux/l-lpic1-v3-104-5/">学习 Linux，101: 管理文件权限和所有权</a></li>
<li><a rel="nofollow" href="http://linux-wiki.cn/wiki/zh-hans/%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90">文件权限</a></li>
<li><a rel="nofollow" href="http://blog.51yip.com/linux/1137.html">linux下添加，删除，修改，查看用户和用户组</a></li>
</ul>
<blockquote>
  <p><a rel="nofollow" href="http://ulaijn.com/2015/04/03/linux-file-permission-ower/">原文链接</a></p>
</blockquote>

2015年五月2日晚上 8:47:47
Fedora 21下Nvidia显卡的安装
<p>最近由于工作和学习需要，把家用的两台电脑攒成了一台机器，用的是Fedora 21，安装过程比较傻瓜就不写了，因为显卡用的是比较搓的N卡，N卡的开源驱动nouveau又搓的要死，装了跟不装一事，所以装机后需要做的第一件事就是要安装N卡的官方驱动，过程不难但是背不下来，所以正好在这里记录一下，以后也好找。</p>

<p>简单来说：</p>

<ul>
<li>
<p>查看自己显卡的型号</p>

<p>$ lspci | grep VGA<br>
01:00.0 VGA compatible controller: NVIDIA Corporation GK208 [<strong>GeForce GT 730</strong>] (rev a1)</p>
</li>
</ul>
<p>这里GeForce GT730就是我这块网卡的型号</p>

<ul>
<li>
<a rel="nofollow" href="http://www.geforce.cn/drivers">官网</a>搜索下载驱动</li>
</ul>
<p>按照提示几个选项一路选下来，搜索得到的驱动里选择一个最新的，随便用什么工具下载下来</p>

<pre><code>wget http://us.download.nvidia.com/XFree86/Linux-x86_64/346.59/NVIDIA-Linux-x86_64-346.59.run
</code></pre>

<ul>
<li>准备驱动安装环境</li>
</ul>
<p>到这里还不能直接安装驱动，下载下来的run文件在安装过程中会编译匹配我们当前系统版本的驱动出来。编译驱动需要用到kernel source，但如果是像我这样直接下了发行版来安装的话，默认是不包含kernel source的，所以我们需要安装对应当前系统版本的kernel-devel</p>

<pre><code>sudo yum install gcc kernel-devel-$(uname -r) 
</code></pre>

<p>系统更新完成后，要重启新的kernel才会生效，不过没关系等等一起重启也可以，现在我们要做的是屏蔽nouveau驱动，直接</p>

<pre><code>echo "blacklist nouveau" &gt;&gt; /etc/modprobe.d/blacklist.conf
</code></pre>

<p>移除已经安装的开源驱动包</p>

<pre><code>yum list | grep nouveau
yum remove xorg-x11-drv-nouveau.x86_64
</code></pre>

<p>设置默认启动进入字符界面</p>

<pre><code>systemctl set-default multi-user.target
</code></pre>

<p>(效力等同于重启后在登录界面输入ctrl+alt+F2,这点还不熟悉的同学可以看看systemcl的几组user target的定义)</p>

<p>重启系统之后安装官方驱动</p>

<pre><code>chmod u+x ./*.run
./NVIDIA-Linux-x86_64-346.59.run
</code></pre>

<p>跟着提示一路走下去即可，安装完成之后记得将启动级别改回到图形界面</p>

<pre><code>systemctl set-default graphical.target
</code></pre>

<p>然后重启就可以了。</p>

<p>问题：<br>
安装过程没遇到什么问题，有一点可以注意一下，如果你安装kernel-devel的时候没有指定<code>uname -r</code>，即当前版本，你更新到的kernel source会是最新版的，在编译官方驱动的时候会跟你抱怨找不到KDIR的。</p>

2015年五月2日晚上 8:13:32
关于redis不同权限列表显示缓存问题-带分页
<div class="markdown-text"><p>各位大神好,求助,由于对redis+mysql这种nosql+sql方式存储没有最佳实践,想求教下有这种经验的大神,最近用mysql+redis+nodejs做个大数据高并发东西,想要用redis缓存带分页列表信息减少mysql查询压力,当前端访问时候可以根据不同访问权限到redis提取数据,如果没有则从mysql查询.(比如:老师,学生,校长三个不同权限拉取数据不同,需要考虑数据更新,redis-mysql数据一致性问题).</p>
</div>

2015年五月2日下午 3:07:27
T-SQL学习中--内联接，外连接，交叉连接
<p>交叉连接可以表A和表B是同一张表取得笛卡尔乘积。<br>
比如说下面这种写法：</p>

<pre><code>SQL</code><code>SELECT D.n AS theday, S.n AS shiftno  
FROM dbo.Nums AS D
  cross JOIN dbo.Nums AS S
WHERE D.n &lt;= 7
  AND S.N &lt;= 3
ORDER BY theday, shiftno;

</code></pre>

<p>当然也可以表A和表B是两张不同的表，取得笛卡尔乘积。</p>

<pre><code>SQL</code><code>SELECT D.n AS theday, S.empid AS shiftno  
FROM dbo.Nums AS D
  cross JOIN [HR].[Employees] AS S
WHERE D.n &lt;= 7
  AND S.empid &lt;= 3
ORDER BY theday, shiftno;
</code></pre>

<p>但是<code>CROSS JOIN</code>不能用<code>ON</code>条件，只能用<code>WHERE</code>条件。下面这句与上面的语句查询结果相同。</p>

<pre><code>SQL</code><code>SELECT D.n AS theday, S.empid AS shiftno  
FROM dbo.Nums AS D
  inner JOIN [HR].[Employees] AS S
on D.n &lt;= 7
  AND S.empid &lt;= 3
ORDER BY theday, shiftno;
</code></pre>

<p>内联接查询，表A和表B中的数据必须紧密对应，不可以是Null。下面的查询中，<code>Production.Products</code>表中没有商品记录的的日本供货商不会被列出来。<code>INNER</code>这个关键词是可以舍去的，如果只写<code>JOIN</code>就表示<code>INNER JOIN</code>。</p>

<pre><code>SQL</code><code>SELECT
  S.companyname AS supplier, S.country,
  P.productid, P.productname, P.unitprice
FROM Production.Suppliers AS S
  INNER JOIN Production.Products AS P
    ON S.supplierid = P.supplierid
WHERE S.country = N'Japan';
</code></pre>

<p>外连接查询有三种情况：左外连接，右外连接，全外连接。<br>
下面这个查询与上面这个查询写法只差一点点（WHERE变成了AND），但是结果就有区别：</p>

<pre><code>SQL</code><code>SELECT
  S.companyname AS supplier, S.country,
  P.productid, P.productname, P.unitprice
FROM Production.Suppliers AS S
  INNER JOIN Production.Products AS P
    ON S.supplierid = P.supplierid
    AND S.country = N'Japan';
</code></pre>

<p>而且<code>Production.Products</code>表中没有商品记录的的日本供货商同样也会被列出来，但是相关的P.productid, P.productname, P.unitprice都会被记为NULL。<br>
下面这句：</p>

<pre><code>SQL</code><code>SELECT E.empid,
  E.firstname + N' ' + E.lastname AS emp,
  M.firstname + N' ' + M.lastname AS mgr
FROM HR.Employees AS E
  INNER JOIN HR.Employees AS M
    ON E.mgrid = M.empid;
</code></pre>

<p>用了内联接，则最高主管（CEO）不会被列出来，因为最高主管没有更高的主管了。<br>
而改用左外连接</p>

<pre><code>SQL</code><code>SELECT E.empid,
  E.firstname + N' ' + E.lastname AS emp,
  M.firstname + N' ' + M.lastname AS mgr
FROM HR.Employees AS E
  LEFT OUTER JOIN HR.Employees AS M
    ON E.mgrid = M.empid;
</code></pre>

<p>则CEO也会被列出来，CEO对应的mgr会被记为NULL。<br>
套用内联接的左外连接：</p>

<pre><code>SQL</code><code>SELECT
  S.companyname AS supplier, S.country,
  P.productid, P.productname, P.unitprice,
  C.categoryname
FROM Production.Suppliers AS S
  LEFT OUTER JOIN Production.Products AS P
    ON S.supplierid = P.supplierid
  INNER JOIN Production.Categories AS C
    ON C.categoryid = P.categoryid
WHERE S.country = N'Japan';
</code></pre>

<p>查询出日本供货商的所有的产品以及产品类别名。而且<code>Production.Products</code>表中没有商品记录的的日本供货商同样也会被列出来，但是相关的P.productid, P.productname, P.unitprice, C.categoryname都会被记为NULL。<br>
上面的语句与下面带括号的语句等同：</p>

<pre><code>SQL</code><code>SELECT
  S.companyname AS supplier, S.country,
  P.productid, P.productname, P.unitprice,
  C.categoryname
FROM Production.Suppliers AS S
  LEFT OUTER JOIN 
    (Production.Products AS P
       INNER JOIN Production.Categories AS C
         ON C.categoryid = P.categoryid)
    ON S.supplierid = P.supplierid
WHERE S.country = N'Japan';
</code></pre>

<p><code>RIGHT OUTER JOIN</code>则与<code>LEFT OUTER JOIN</code>相反，根据ON条件和WHERE条件查询表A和表B，查询结果可以表A中数据为NULL。<br><code>FULL OUTER JOIN</code>则只要表A和表B中任一表中有数据，结果都会被显示出来。无论是表A为NULL，还是表B为NULL。<br><code>OUTER</code>也是可以被省略的。<code>LEFT JOIN</code>就是<code>LEFT OUTER JOIN</code>的简写，相应的，<code>RIGHT JOIN</code>是<code>RIGHT OUTER JOIN</code>的简写，<code>FULL JOIN</code>是<code>FULL OUTER JOIN</code>的简写。</p>

2015年五月2日下午 2:22:12
T-SQL学习中--取得部分检索数据记录
<p><code>SELECT TOP(n) FROM _TableName_ ORDER BY _ColumnName_</code>是一种非标准SQL语句，从数据表中最多检索出排在前面的n条数据来，但是它可以用<code>SELECT TOP(n) PERCENT FROM _TABLENAME_ ORDER BY</code> 这样的根据总数据量来按比例取得数据记录。<br>
如果数据表中有560条数据，检索<code>SELECT TOP(1) FROM _TableName_ ORDER BY _ColumnName_</code>就会检索出6条数据来，总而言之，不是按四舍五入计的，而是按<code>ceil</code>向上取整法计数的。<br>
如果不加<code>ORDER BY</code>，数据会以不确定的顺序检索出来。<br>
这里括号可有可无，但是建议加括号。<br>
n可以是常数，也可以是定义的变量。下面这种写法也是可以的：</p>

<pre><code>SQL</code><code>DECLARE @n AS BIGINT = 5;
SELECT TOP (@n) orderid, orderdate, custid, empid
FROM Sales.Orders
ORDER BY orderdate DESC;
GO
</code></pre>

<p>如果加了<code>WITH TIE</code>，比如说写成</p>

<pre><code>SQL</code><code>SELECT TOP (3) WITH TIES orderid, orderdate, custid, empid
FROM Sales.Orders
ORDER BY orderdate DESC;
</code></pre>

<p>则<code>orderdate</code>相同的数据会被计作一条数据，总检索出的结果可能不止3条。</p>

<p><code>OFFSET FETCH</code>语句是标准SQL语句。但是它有局限性，不能按百分比检索出数据结果。</p>

<pre><code>SQL</code><code>SELECT orderid, orderdate, custid, empid
FROM Sales.Orders
ORDER BY orderdate DESC, orderid DESC
OFFSET 50 ROWS FETCH NEXT 25 ROWS ONLY;
</code></pre>

<p>表示跳过前50条数据，取得第51到第75条数据。</p>

<pre><code>SQL</code><code>SELECT orderid, orderdate, custid, empid
FROM Sales.Orders
ORDER BY orderdate DESC, orderid DESC
OFFSET 0 ROWS FETCH FIRST 25 ROWS ONLY;
</code></pre>

<p>表示取得第1到第25条数据。</p>

<pre><code>SQL</code><code>SELECT orderid, orderdate, custid, empid
FROM Sales.Orders
ORDER BY orderdate DESC, orderid DESC
OFFSET 50 ROWS;
</code></pre>

<p>表示跳过前50条数据，取得之后的全部数据。<br><code>OFFSET FETCH</code>语句必须带有<code>ORDER BY</code>语句，但是如果不想指定用于排序的columnName，可以用下面这种这种语法，即用<code>SELECT NULL</code>作为排序列：</p>

<pre><code>SQL</code><code>SELECT orderid, orderdate, custid, empid
FROM Sales.Orders
ORDER BY (SELECT NULL)
OFFSET 0 ROWS FETCH FIRST 3 ROWS ONLY;
</code></pre>

<p><code>OFFSET FETCH</code>可用于分页检索，比如说下面这种写法：</p>

<pre><code>SQL</code><code>DECLARE @pagesize AS BIGINT = 25, @pagenum AS BIGINT = 3;

SELECT orderid, orderdate, custid, empid
FROM Sales.Orders
ORDER BY orderdate DESC, orderid DESC
OFFSET (@pagenum - 1) * @pagesize ROWS FETCH NEXT @pagesize ROWS ONLY;
</code></pre>

2015年五月2日上午 11:09:04
GitLab 安装配置笔记
<h1>GitLab的安装方式</h1>

<p>GitLab的两种安装方法:</p>

<ul>
<li>编译安装<br><br><ul>
<li>优点：可定制性强。数据库既可以选择MySQL,也可以选择PostgreSQL;服务器既可以选择Apache，也可以选择Nginx。</li>
<li>缺点：国外的源不稳定，被墙时，依赖软件包难以下载。配置流程繁琐、复杂，容易出现各种各样的问题。依赖关系多，不容易管理，卸载GitLab相对麻烦。</li>
</ul>
</li>
<li>通过rpm包安装<br><br><ul>
<li>优点：安装过程简单，安装速度快。采用rpm包安装方式，安装的软件包便于管理。</li>
<li>缺点：数据库默认采用PostgreSQL，服务器默认采用Nginx，不容易定制。</li>
</ul>
</li>
</ul>
<p>由于公司只配备了一台阿里云服务器，并且没有分配任何的域名。该服务器上需要运行版本控制软件、bug管理软件、知识库等多套程序，只能采用ip的方式访问。原先采用GitLab+Apache+MySQL编译安装的方式，并且将GitLab配置为可通过<code>xxx.xx.xxx.xx/gitlab</code>的形式访问，由于bug管理软件（禅道）也运行于Apache之上，两套软件之间彼此有互斥的影响，找不到解决方法。同时，GitLab的注册需要邮箱验证，由于网上提供的配置方法都是基于域名的，在阿里云上多次进行配置都无法正常使用。</p>

<p>因此，只能放弃编译安装的方式，而采取rpm包的方式重新进行安装。</p>

<h1>安装GitLab CE Omnibus包</h1>

<ol>
<li><p>在linux终端下，使用<code>cat /etc/issue</code>命令查询当前系统的发行版本，查询到阿里云所安装的linux版本为CentOS release 6.6 (Final)。</p></li>
<li>
<p>进入<a rel="nofollow" href="https://about.gitlab.com/downloads/">gitlab官方网站</a>,选择对应的操作系统——CentOS 6 (and RedHat/Oracle/Scientific Linux 6),按照官方的提示进行安装：</p>

<ol>
<li>
<p>安装配置必要的依赖</p>

<p>在Centos 6 和 7 中，以下的命令将会打开HTTP和SSH在系统防火墙中的可访问权限。</p>

<pre><code>bash</code><code>sudo yum install openssh-server

sudo yum install postfix

sudo yum install cronie

sudo service postfix start

sudo chkconfig postfix on

sudo lokkit -s http -s ssh

</code></pre>
</li>
<li>
<p>下载Omnibus package包并安装</p>

<pre><code>bash</code><code>curl -O https://downloads-packages.s3.amazonaws.com/centos-6.6/gitlab-ce-7.10.0~omnibus.2-1.x86_64.rpm
sudo rpm -i gitlab-ce-7.10.0~omnibus.2-1.x86_64.rpm
</code></pre>

<pre><code>Note:由于amazonaws的服务器被墙，下载这个包时可能需要翻墙下载。
</code></pre>
</li>
<li>
<p>配置并启动GitLab<br>
打开<code>/etc/gitlab/gitlab.rb</code>,将<code>external_url = 'http://git.example.com'</code>修改为自己的IP地址：<code>http://xxx.xx.xxx.xx</code>,，然后执行下面的命令，对GitLab进行编译。</p>

<pre><code>bash</code><code>sudo gitlab-ctl reconfigure
</code></pre>
</li>
<li>
<p>登录GitLab</p>

<pre><code>Username: root 
Password: 5iveL!fe
</code></pre>
</li>
</ol>
</li>
</ol>
<h1>配置GitLab的默认发信邮箱</h1>

<ol>
<li>GitLab中使用<code>postfix</code>进行邮件发送。因此，可以卸载系统中自带的<code>sendmail</code>。<br>
使用<code>yum list installed</code>查看系统中是否存在<code>sendmail</code>，若存在，则使用<code>yum remove sendmail</code>指令进行卸载。</li>
<li>
<p>测试系统是否可以正常发送邮件。</p>

<pre><code>bash</code><code>echo "Test mail from postfix" | mail -s "Test Postfix" xxx@xxx.com
</code></pre>

<pre><code>注：上面的xxx@xxx.com为你希望收到邮件的邮箱地址。
</code></pre>

<p>当邮箱收到系统发送来的邮件时，将系统的地址复制下来，如：<code>root@iZ23syflhhzZ.localdomain</code>,打开<code>/etc/gitlab/gitlab.rb</code>,将</p>

<pre><code># gitlab_rails['gitlab_email_from'] = 'gitlab@example.com' 
</code></pre>

<p>修改为</p>

<pre><code>gitlab_rails['gitlab_email_from'] = 'root@iZ23syflhhzZ.localdomain' 
</code></pre>

<p>保存后，执行<code>sudo gitlab-ctl reconfigure</code>重新编译GitLab。如果邮箱的过滤功能较强，请添加系统的发件地址到邮箱的白名单中，防止邮件被过滤。</p>

<pre><code>Note:系统中邮件发送的日志可通过`tail /var/log/maillog`命令进行查看。
</code></pre>
</li>
</ol>
<h1>安装过程中出现的问题</h1>

<ol>
<li>
<p>在浏览器中访问GitLab出现<code>502</code>错误</p>

<p>原因：内存不足。</p>

<p>解决办法：检查系统的虚拟内存是否随机启动了，如果系统无虚拟内存，则增加虚拟内存，再重新启动系统。</p>
</li>
<li>
<p><code>80</code>端口冲突</p>

<p>原因：Nginx默认使用了<code>80</code>端口。</p>

<p>解决办法：为了使Nginx与Apache能够共存，并且为了简化GitLab的URL地址，Nginx端口保持不变，修改Apache的端口为4040。这样就可以直接用使用ip访问Gitlab。而禅道则可以使用<code>4040</code>端口进行访问，像这样：<code>xxx.xx.xxx.xx:4040/zentao</code>。具体修改的地方在<code>/etc/httpd/conf/httpd.conf</code>这个文件中，找到<code>Listen 80</code>这一句并将之注释掉，在底下添加一句<code>Listen 4040</code>，保存后执行<code>service httpd restart</code>重启apache服务即可。</p>

<pre><code>#Listen 80 
Listen 4040 
</code></pre>
</li>
<li>
<p><code>8080</code>端口冲突</p>

<p>原因：由于unicorn默认使用的是<code>8080</code>端口。</p>

<p>解决办法：打开<code>/etc/gitlab/gitlab.rb</code>,打开<code># unicorn['port'] = 8080</code>的注释，将<code>8080</code>修改为<code>9090</code>，保存后运行<code>sudo gitlab-ctl reconfigure</code>即可。</p>
</li>
<li>
<p>STMP设置</p>

<p>配置无效，暂时不知道原因。</p>
</li>
<li>
<p>GitLab头像无法正常显示<br>
原因：gravatar被墙<br>
解决办法：<br>
编辑 <code>/etc/gitlab/gitlab.rb</code>，将</p>

<pre><code>#gitlab_rails['gravatar_plain_url'] = 'http://gravatar.duoshuo.com/avatar/%{hash}?s=%{size}&amp;d=identicon'
</code></pre>

<p>修改为：</p>

<pre><code>gitlab_rails['gravatar_plain_url'] = 'http://gravatar.duoshuo.com/avatar/%{hash}?s=%{size}&amp;d=identicon'
</code></pre>

<p>然后在命令行执行：</p>

<pre><code>bash</code><code>sudo gitlab-ctl reconfigure 
sudo gitlab-rake cache:clear RAILS_ENV=production
</code></pre>
</li>
</ol>
<h1>参考资料</h1>

<p><a rel="nofollow" href="http://www.07net01.com/program/641580.html">GitLab 6.1 使用postfix发送email</a></p>

<p><a rel="nofollow" href="http://devonoid.net/configure-gitlab-omnibus-installation-alongside-with-apache/">Configure GitLab Omnibus installation alongside with Apache</a></p>

<p><a rel="nofollow" href="http://my.oschina.net/anylain/blog/355797">解决Gitlab的Gravatar头像无法显示的问题</a></p>

<p><a rel="nofollow" href="https://www.digitalocean.com/community/tutorials/how-to-set-up-gitlab-as-your-very-own-private-github-clone">How To Set Up GitLab As Your Very Own Private GitHub Clone</a></p>

2015年五月1日晚上 8:12:21
PHP 5.3 连接 Oracle 的客户端及 PDO_OCI 模块安装
<p>php连接oracle数据库虽然不是最佳拍档，但组内开发确实有这样需求。如果没有参考合适的文档，这个过程还是挺折磨人的，下面是一个记录，原型是国外的一篇博客 <a rel="nofollow" href="http://shiki.me/blog/installing-pdo_oci-and-oci8-php-extensions-on-centos-6-4-64bit/">Installing PDO_OCI and OCI8 PHP extensions on CentOS 6.4 64bit</a>。</p>

<p>假设你已经安装好php的环境，php版本为5.3，要连接的oracle服务器是 11g R2，操作系统版本CentOS 6.4 x86_64。如果没有安装php，可以通过以下命令安装：</p>

<pre><code># yum install php php-pdo
# yum install php-devel php-pear php-fpm php-gd php-ldap \
php-mbstring php-xml php-xmlrpc  php- zlib zlib-devel bc libaio glibc
</code></pre>

<p>假如web服务器使用apache。</p>

<h2>1. 安装InstantClient</h2>

<p>instantclient是oracle的连接数据库的简单客户端，不用安装一个500Moracle客户端就可以连接oracle数据库，有windows和linux版本。从 <a rel="nofollow" href="http://www.oracle.com/technetwork/topics/linuxx86-64soft-092277.html">这里</a> 选择需要的版本下载，只需Basic和Devel两个rpm包。</p>

<pre><code>安装
# rpm -ivh oracle-instantclient11.2-basic-11.2.0.4.0-1.x86_64.rpm
# rpm -ivh oracle-instantclient11.2-devel-11.2.0.4.0-1.x86_64.rpm

软链接
# ln -s /usr/include/oracle/11.2/client64 /usr/include/oracle/11.2/client
# ln -s /usr/lib/oracle/11.2/client64 /usr/lib/oracle/11.2/client
</code></pre>

<p>64位系统需要创建32位的软链接，这里可能是一个遗留bug，不然后面编译会出问题。</p>

<p>接下来还要让系统能够找到oracle客户端的库文件，修改LD_LIBRARY_PATH：</p>

<pre><code># vi /etc/profile.d/oracle.sh
export ORACLE_HOME=/usr/lib/oracle/11.2/client64
export LD_LIBRARY_PATH=$ORACLE_HOME/lib
</code></pre>

<p>执行<code>source /etc/profile.d/oracle.sh</code>使环境变量生效。</p>



<h2>2. 安装PDO_OCI</h2>

<p>在连接互联网的情况下，通过pecl在线安装php的扩展非常简单，参考 <a rel="nofollow" href="http://stackoverflow.com/questions/21936091/how-to-install-oracle-instantclient-and-pdo-oci-on-ubuntu-machine">How to install oracle instantclient and pdo_oci on ubuntu machine</a> 。</p>

<p>从<a rel="nofollow" href="https://pecl.php.net/package/PDO_OCI">https://pecl.php.net/package/PDO_OCI</a>下载 PDO_OCI-1.0.tgz 源文件。</p>

<pre><code># wget https://pecl.php.net/get/PDO_OCI-1.0.tgz
# tar -xvf PDO_OCI-1.0.tgz
# cd PDO_OCI-1.0
</code></pre>

<p>由于PDO_OCI很久没有更新，所以下面需要编辑<code>ODI_OCI-1.0</code>文件夹里的<code>config.m4</code>文件来让它支持11g：</p>

<pre><code># 在第10行左右找到与下面类似的代码，添加这两行：
elif test -f $PDO_OCI_DIR/lib/libclntsh.$SHLIB_SUFFIX_NAME.11.2; then
  PDO_OCI_VERSION=11.2

# 在第101行左右添加这几行：
11.2)
  PHP_ADD_LIBRARY(clntsh, 1, PDO_OCI_SHARED_LIBADD)
  ;;
</code></pre>

<p>编译安装pdo_oci扩展：（安装完成后可在 /usr/lib64/php/modules/pdo_oci.so 找到这个模块）</p>

<pre><code>$ phpize
$ ./configure --with-pdo-oci=instantclient,/usr,11.2
$ make
$ sudo make install
</code></pre>

<p>要启用这个扩展，在<code>/etc/php.d/</code>下新建一个<code>pdo_oci.ini</code>文件，内容：</p>

<pre><code>extension=pdo_oci.so
</code></pre>

<p>验证安装成功：</p>

<pre><code># php -i|grep oci
看到类似下面的内容则安装成功:
/etc/php.d/pdo_oci.ini,
PDO drivers =&gt; oci, sqlite

或
# php -m
</code></pre>

<h2>3. 安装OCI8</h2>

<p>从 <a rel="nofollow" href="https://pecl.php.net/package/oci8">https://pecl.php.net/package/oci8</a> 下载oci8-2.0.8.tgz源文件。</p>

<pre><code># wget https://pecl.php.net/get/oci8-2.0.8.tgz
# tar -xvf oci8-2.0.8.tgz
# cd oci8-2.0.8
</code></pre>

<p>编译安装oci8扩展：</p>

<pre><code># phpize
# ./configure --with-oci8=shared,instantclient,/usr/lib/oracle/11.2/client64/lib
# make
# make install
</code></pre>

<p>要启用这个扩展，在<code>/etc/php.d/</code>下新建一个<code>oci8.ini</code>文件，内容：</p>

<pre><code>extension=oci8.so
</code></pre>

<p>验证安装成功：</p>

<pre><code># php -i|grep oci8
/etc/php.d/oci8.ini,
oci8
oci8.connection_class =&gt; no value =&gt; no value
oci8.default_prefetch =&gt; 100 =&gt; 100
oci8.events =&gt; Off =&gt; Off
oci8.max_persistent =&gt; -1 =&gt; -1
oci8.old_oci_close_semantics =&gt; Off =&gt; Off
oci8.persistent_timeout =&gt; -1 =&gt; -1
oci8.ping_interval =&gt; 60 =&gt; 60
oci8.privileged_connect =&gt; Off =&gt; Off
oci8.statement_cache_size =&gt; 20 =&gt; 20
OLDPWD =&gt; /usr/local/src/oci8-2.0.8
_SERVER["OLDPWD"] =&gt; /usr/local/src/oci8-2.0.8
</code></pre>

<p>最后别忘了重启逆web服务器如apache，可以通过phpinfo()来确保扩展是否成功安装。</p>

<h2>4. 测试连接</h2>

<p>在你web服务器如apache的php目录下创建<code>testoci.php</code>：</p>

<pre><code>&lt;?php

$conn = oci_connect('username', 'password', '172.29.88.178/DBTEST');

$stid = oci_parse($conn, 'select table_name from user_tables');
oci_execute($stid);

echo "&lt;table&gt;\n";
while (($row = oci_fetch_array($stid, OCI_ASSOC+OCI_RETURN_NULLS)) != false) {
    echo "&lt;tr&gt;\n";
    foreach ($row as $item) {
        echo "  &lt;td&gt;".($item !== null ? htmlentities($item, ENT_QUOTES) : "&amp;nbsp;")."&lt;/td&gt;\n";
    }
    echo "&lt;/tr&gt;\n";
}
echo "&lt;/table&gt;\n";

?&gt;
</code></pre>

<p>访问这个页面就应该可以得到结果了。</p>

<p><strong>参考</strong></p>

<ul>
<li><a rel="nofollow" href="http://shiki.me/blog/installing-pdo_oci-and-oci8-php-extensions-on-centos-6-4-64bit/">Installing PDO_OCI and OCI8 PHP extensions on CentOS 6.4 64bit</a></li>
<li><a rel="nofollow" href="http://www.oracle.com/technetwork/cn/articles/dsl/technote-php-instant-090922-zhs.html">在 Linux 和 Windows 上安装 PHP 和 Oracle Instant Client</a></li>
<li><a rel="nofollow" href="http://iceeggplant.blog.51cto.com/1446843/1052512">php5.3安装oracle的扩展oci8与pdo_oci</a></li>
</ul>
<hr>
<p>原文链接地址：<a rel="nofollow" href="http://seanlook.com/2015/03/10/install-pdo-oci-oci8-phpext/">http://seanlook.com/2015/03/10/install-pdo-oci-oci8-phpext/</a></p>

<hr>

2015年四月30日晚上 11:41:21
OpenWrt路由器开发
<blockquote>
  <p><a rel="nofollow" href="http://homeway.me"></a><a rel="nofollow" href="http://homeway.me">http://homeway.me</a></p>
</blockquote>

<p><img src="http://xiaocao.u.qiniudn.com/blog/logo-openwrt.png" alt="OpenWrt"></p>



<p><br></p>

<hr>
<p><br></p>

<h1>0x01.About</h1>

<p>第一次尝试开发路由器，发现并不是想象中那么难，和普通嵌入式开发一样，也是一块ARM板刷上Linux系统。</p>

<p>OpenWrt有很多好用的软件，附带流量监测。</p>

<p>OpenWrt主要开发语言为Python、Lua、Shell，还可以做深入研究写ipk软件包。</p>

<p>写了几个脚本，主要实现了openwrt下面GPIO控制、系统信息获取、wifi扫描器、定时发送邮件系统报警等功能，下面会介绍。</p>

<p>代码已经在Github开源：  <a rel="nofollow" href="https://github.com/grasses/OpenWRT-Util"></a><a rel="nofollow" href="https://github.com/grasses/OpenWRT-Util">https://github.com/grasses/OpenWRT-Util</a></p>

<p><br></p>

<hr>
<h1>0x02.About OpenWrt</h1>

<p>刷OpenWrt先要去<a rel="nofollow" href="https://downloads.openwrt.org/"></a><a rel="nofollow" href="https://downloads.openwrt.org/">https://downloads.openwrt.org/</a>下载你想要的版本，包含aa型和bb型。</p>

<p>然后用Linux烧入命令烧入系统。</p>

<p>早MAC下面，先现将U盘插入电脑格式化，然后运行命令查看U盘编号：</p>

<blockquote>
  <p>diskUtil list</p>
</blockquote>

<p>注意查看U盘编号，选择你的U盘，解除挂载：</p>

<blockquote>
  <p>diskUtil unmountDisk /dev/disk2</p>
</blockquote>

<p>然后烧入系统：</p>

<blockquote>
  <p>dd if=/path/to/openwrt.img of=/dev/disk2 bs=2m</p>
</blockquote>

<p>等待几分钟后烧入成功。</p>

<h4>关于痛点：</h4>

<pre><code>第一次是在树莓派上安装OpenWrt，装好后，用有线把连进上级路由器的Lan口

然后，上级路由的包开始乱了，上级路由把OpenWrt当成路由器，OpenWrt把路由器当成上级路由器，然后就GG了。
</code></pre>

<p><br></p>

<hr>
<h1>0x03.About WRTnode</h1>

<p>WRTnode是OpenWrt系统一个硬件解决方案，预先安装了OpenWrt相关软件包，并且内置两块无线网卡。</p>

<p>关于WRTnode，官方wiki已经介绍的很详细了：<a rel="nofollow" href="http://wiki.wrtnode.com/index.php?title=Main_Page/zh-cn"></a><a rel="nofollow" href="http://wiki.wrtnode.com/index.php?title=Main_Page/zh-cn">http://wiki.wrtnode.com/index.php?title=Main_Page/zh-cn</a></p>

<p>解析来的代码基本上是在WRTnode环境上开发的，主要包含了：</p>

<ul>
<li><p>luci(WRTnode自带，非WRTnode用opkg安装即可)</p></li>
<li><p>python(WRTnode自带，非WRTnode用opkg安装即可)</p></li>
<li><p>luasocket( <a rel="nofollow" href="http://see.sl088.com/wiki/Luasocket"></a><a rel="nofollow" href="http://see.sl088.com/wiki/Luasocket">http://see.sl088.com/wiki/Luasocket</a> )</p></li>
</ul>
<p>目前只能想起这3个，如果报错，该装什么再装好了。</p>

<p><br></p>

<hr>
<h1>0x04.WRTnode控制GPIO</h1>

<p>GPIO控制可以很好地实现软件硬件之间的交互。</p>

<p><img src="http://xiaocao.u.qiniudn.com/blog/2015-04-29-openwrt-gpio.jpg" alt="WRTnode GPIO"></p>

<p>GPIO的控制也不难，wiki讲得很清晰了，就是文件输入输出<a rel="nofollow" href="http://wiki.wrtnode.com/index.php?title=The_user_space_gpio_calls/zh-cn"></a><a rel="nofollow" href="http://wiki.wrtnode.com/index.php?title=The_user_space_gpio_calls/zh-cn">http://wiki.wrtnode.com/index.php?title=The_user_space_gpio_calls/zh-c...</a></p>

<p>这里我写了一个Lua版的GPIO控制模块，文件保存为gpio.lua：</p>

<pre><code>#!/usr/bin/lua
--[[
Copyright 2015 http://homeway.me
@author homeway
@version 15.04.29
@link http://homeway.me
@function OpenWRT gpio module
-- ]]--

local M = {}
M.id = ""
M.path = "/sys/class/gpio/gpio"
M.router = "/sys/class/gpio"

M.check = function(where)
    print("check path =&gt; "..where)
    local f=io.open(where, "r")
    if f~=nil then io.close(f) return true else return false end
end
-- set mode &amp;&amp; check type
M.mode = function(id, mtype)
    M.id = id
    where = M.path..M.id
    -- if id not use
    if false==M.check(M.path..id..'/direction') then
        --M.writeFile(M.router.."/unexport",id)
        M.writeFile(M.router.."/export", id)
    end
    -- if type different 
    if mtype ~= M.readFile(M.path..id..'/direction') then
        print("type =&gt;"..mtype.." direction=&gt;"..M.readFile(M.path..id..'/direction').." different")
        M.writeFile(M.path..id..'/direction', mtype)
    end
end
-- file write
M.writeFile = function(where, what)
    print("write path =&gt; "..where.." data =&gt;"..what)
    local fp=io.open(where, 'w')
    fp:write(what)
    fp:close()  
end
-- file read
M.readFile = function(where)
    print("read path =&gt; "..where)
    local fp=io.open(where, 'r')
    if fp~=nil then
        data = fp:read("*all")
        fp:close()
        return data
    end
    return nil
end
M.set = function(id)
    M.id = id
end
M.read = function()
    res = M.readFile(M.path..M.id..'/value')
    return res
end
M.write = function(value)
    res = M.writeFile(M.path..M.id..'/value', value)
end
M.close = function()
    print("sleep io =&gt; "..M.id)
    os.execute("sleep " .. tonumber(M.id))
end

return M

</code></pre>

<p>API很简单，先设置设置模式，GPIO.mode(id, "out/in")两种模式之一</p>

<p>如果为'out'即可调用GPIO.write(value)函数，写入当然id端口，如果为'in'模式，只能调用GPIO.read()读取数值。</p>

<p>这里数值只能是0或1，非0即为1.</p>

<p>调用方式如下，这个存在一个可忽略的问题，一旦调用mode，数值将被置为默认数值，即0：</p>

<pre><code>#!/usr/bin/lua
x=require("gpio")
print("Please input io id =&gt;")
id = io.read("*num")
x.mode(id, "out")-- 设置io的模式为输入还是输出 [in/out]
function readGPIO(id)
    value = x.read()
    print("read data from =&gt; `"..id.."` =&gt;"..value)
end
function writeGPIO(id, data)
    x.write(data)
    print("write data to =&gt; `"..id.."` =&gt;"..data)
end

count=1
repeat
    count=count+1
    print("Please input value =&gt;")
    data = io.read("*num")
    writeGPIO(id, data)
    readGPIO(id)
until count&gt;3

</code></pre>

<p><br></p>

<hr>
<h1>0x05.WRTnode获取系统信息</h1>

<p>其实获取系统信息不属于WRTnode范围，因为这部分主要是调用Linux Shell获取系统信息，做个反馈。</p>

<p>这里我也写了个python脚本，主要检查系统信息，这个脚本在树莓派那里面也有：<a rel="nofollow" href="http://homeway.me/2014/10/09/raspberry-the-current-status-and-data/"></a><a rel="nofollow" href="http://homeway.me/2014/10/09/raspberry-the-current-status-and-data/">http://homeway.me/2014/10/09/raspberry-the-current-status-and-data/</a></p>

<p>这里我做了部分修改，添加系统ip、连接的ssid等信息：</p>

<pre><code>#!/usr/bin/python
'''
    @author homeway
    @version 15.04.29
    @link http://homeway.me
    @function python get OpenWRT system info
'''
import os
# Return CPU temperature as a character string                                     
def getCPUtemperature():
    res = os.popen('vcgencmd measure_temp').readline()
    return(res.replace("temp=","").replace("'C\n",""))
# Return RAM information (unit=kb) in a list                                      
# Index 0: total RAM                                                              
# Index 1: used RAM                                                                
# Index 2: free RAM                                                                
def getRAMinfo():
    p = os.popen('free')
    i = 0
    while 1:
        i = i + 1
        line = p.readline()
        if i==2:
            return(line.split()[1:4])
# Return % of CPU used by user as a character string                               
def getCPUuse():
    return(str(os.popen("top -n1 | awk '/Cpu\(s\):/ {print $2}'").readline().strip()))

# Return information about disk space as a list (unit included)                    
# Index 0: total disk space                                                        
# Index 1: used disk space                                                        
# Index 2: remaining disk space                                                    
# Index 3: percentage of disk used                                                 
def getDiskSpace():
    p = os.popen("df -h /")
    i = 0
    while 1:
        i = i +1
        line = p.readline()
        if i==2:
            return(line.split()[1:5])
def getSystem():
    p = os.popen("uname -amnrspv")
    while 1:
        line = p.readline()
        return(line)
def getExtranetIp():
    p = os.popen('wget "http://www.ip138.com/ips1388.asp" -q -O - | sed -nr \'s/.*\[(([0-9]+\.){3}[0-9]+)\].*/\1/p\'')
    while 1:
        line = p.readline()
        print line
        return(line)
def getIntranetIp():
    p = os.popen('ifconfig apcli0 | grep inet\ addr')
    while 1:
        line = p.readline()
        return(line)
def getSsid():
    p = os.popen('uci get wireless.@wifi-iface[0].ApCliSsid')
    while 1:
        line = p.readline()
        return(line)
# CPU informatiom
CPU_temp = getCPUtemperature()
CPU_usage = getCPUuse()
# RAM information
# Output is in kb, here I convert it in Mb for readability
RAM_stats = getRAMinfo()
RAM_total = round(int(RAM_stats[0]) / 1000,1)
RAM_used = round(int(RAM_stats[1]) / 1000,1)
RAM_free = round(int(RAM_stats[2]) / 1000,1)
# Disk information
DISK_stats = getDiskSpace()
DISK_total = DISK_stats[0]
DISK_used = DISK_stats[1]
DISK_perc = DISK_stats[3]
# system info
SYSTEM_info = getSystem()
# NET infomation
NET_extranet_ip = getExtranetIp()
NET_internet_ip = getIntranetIp().lstrip('')
NET_connect_ssid = getSsid()

if __name__ == '__main__':
    print('-------------------------------------------')
    print("System info ="+str(SYSTEM_info))
    print('-------------------------------------------')
    print('RAM Total = '+str(RAM_total)+' MB')
    print('RAM Used = '+str(RAM_used)+' MB')
    print('RAM Free = '+str(RAM_free)+' MB')
    print('-------------------------------------------')
    print('DISK Total Space = '+str(DISK_total)+'B')
    print('DISK Used Space = '+str(DISK_used)+'B')
    print('DISK Used Percentage = '+str(DISK_perc))
    print('-------------------------------------------')
    print('NET Extranet Ip ='+str(NET_extranet_ip))
    print('NET Connect Ssid ='+str(NET_connect_ssid))
    print('NET Internet Wan Ip ='+str(NET_internet_ip))

</code></pre>

<p>直接调用<code>python sysinfo.py</code>:</p>

<p><img src="http://xiaocao.u.qiniudn.com/blog/2015-04-29-openwrt-sysinfo.png" alt="系统信息"></p>

<p><br></p>

<hr>
<h1>0x06.WRTnode发送邮件</h1>

<p>好了，系统信息有了，GPIO信息有了，接下来就试试发送邮件了。</p>

<p>发送邮件3中法案都可以，Lua，Python，Shell，找了找资料，Python写了，但是缺少了一个包，Lua缺少Luasocket模块，Shell要安装模块。</p>

<p>最后，懵了，全都要依赖，尼玛，看了看，好像Lua安装个Luasocket最简单，一个包轻松： <a rel="nofollow" href="http://see.sl088.com/wiki/Luasocket"></a><a rel="nofollow" href="http://see.sl088.com/wiki/Luasocket">http://see.sl088.com/wiki/Luasocket</a></p>

<p>安装也不难，接下来就写写吧。</p>

<p>Lua发送邮件源码模块，设置文件名为<code>email.lua</code>：</p>

<pre><code>#!/usr/bin/lua
--[[
Copyright 2015 http://homeway.me
@author homeway
@version 15.04.29
@link http://homeway.me
@function lua email module
-- ]]--
local smtp = require("socket.smtp")
local M ={}
M.user = {["from"]="", ["to"]="", ["password"]=""}
M.mail = {["subject"]="", ["body"]=""}
M.sys = {["server"]=""}
M.set = function(data)
    M.user = data.user
    M.mail = data.mail
    M.sys = data.sys    
end
M.send = function()
    rcpt = {
        M.user["to"]
    }
    mesgt = {
        headers = {
            from = M.user["from"],
            to = M.user["to"], --收件人
            cc = "", --抄送 
            subject = M.mail["subject"] --主题
        },
        body = M.mail["body"]
    }
    r, e = smtp.send{
        from = M.user["from"],
        rcpt = rcpt,
        source = smtp.message(mesgt),
        server = M.sys["server"],
        port = M.sys["port"],
        user = M.user["from"],
        password = M.user["password"],
    }
    if not r then
        print(e)
    else
        print("send ok!")
    end
end
return M
</code></pre>

<p>下面是调用方式：</p>

<pre><code>#!/usr/bin/lua
local mail = require("email")
local data = {}
data.user = {["from"]="sender@gmail.com", ["to"]="receiver@gmail.com", ["password"]="password"}
data.mail = {["subject"]="测试邮件模块", ["body"]="这是主体内容..."}
data.sys = {["server"]="smtp.gmail.com", ["port"]=587}

mail.set(data)
mail.send()
</code></pre>

<p>测试下，是可以接收到邮件的，注意GFW，还是别用非法gmail好了，别等半天收不到。</p>

<p><br></p>

<hr>
<h1>0x07.重要的东西放后面</h1>

<p>嗯！看到这里，估计菊花也有点疼了，再看最后一点看完就擦洗擦洗去吧。</p>

<p>最后就是，设置定时器，让路由器定时发送系统信息给指定邮箱。</p>

<p>嗯...定时器，Linux的一个模块crontab命令，看看功能吧 <code>crontab --help</code></p>

<p>关于定时器语法，看看这里吧 <a rel="nofollow" href="http://kvz.io/blog/2007/07/29/schedule-tasks-on-linux-using-crontab/"></a><a rel="nofollow" href="http://kvz.io/blog/2007/07/29/schedule-tasks-on-linux-using-crontab/">http://kvz.io/blog/2007/07/29/schedule-tasks-on-linux-using-crontab/</a></p>

<p>这里，我只做简单地，每隔10分钟发送一次系统信息给我邮箱。</p>

<p>具体怎么做，去下载这个脚本吧：<a rel="nofollow" href="https://github.com/grasses/OpenWRT-Util/blob/master/lua/crontab.lua"></a><a rel="nofollow" href="https://github.com/grasses/OpenWRT-Util/blob/master/lua/crontab.lua">https://github.com/grasses/OpenWRT-Util/blob/master/lua/crontab.lua</a></p>

<p>我的目录是这样的，用户是root：</p>

<pre><code>~|--script
    |--schedule
    |--send
|--log
    |--sys.log
    |--crontab.log
</code></pre>

<p>先开一个定时器，定时跑Lua，Lua调用python读取系统信息，生成日志文件，Lua读取日志文件，发送邮箱。</p>

<p>how to use:<br>
step1: configure you email information in this script<br>
step2: mkdir /root/log &amp;&amp; mkdir /root/script<br>
step3: mv /path/to/crontab.lua /root/script/send<br>
step4: chmod +x /root/script/send<br>
step5: echo 10,20,30,40,50  * * * * /root/script/send &gt; /root/script/schedule<br>
step6: crontab /root/script/schedule</p>

<p>东西有点多，都是散乱的部件，这篇主要介绍细节信息，接下来会做大得模块。</p>

<p>如果打通路由器，各种嵌入式开发的联网问题就都解决了，所以路由器系统还是很重要的。</p>

<p><br></p>

<hr>
<p><br></p>

<h4>本文出自 <a rel="nofollow" href="http:/homeway.me">夏日小草</a>,转载请注明出处： <a rel="nofollow" href="http://homeway.me/2015/04/29/openwrt-develop-base-util/"></a><a rel="nofollow" href="http://homeway.me/2015/04/29/openwrt-develop-base-util/">http://homeway.me/2015/04/29/openwrt-develop-base-util/</a>
</h4>

<h4>by 小草</h4>

<p>2015-04-30 23:59:20</p>

2015年四月30日晚上 9:56:57
VSCode 初体验
<p>Microsoft 今天在其 Build 开发者大会上正式宣布了 Visual Studio Code 项目：一个运行于 OS X，Windows 和 Linux 之上的，针对于编写现代web和云应用的跨平台编辑器。</p>

<p>作为编辑器控的我，得知消息后立马下载体验了一下。Windows上优秀的编辑器实在太多了，<code>Sublime Text</code>，<code>EditPlus</code>，<code>Notepad++</code>......还有诸如国产的<code>EverEdit</code>等后起之秀。所以这次我这次把测评的环境放在了编辑器相对匮乏的Linux桌面上。</p>

<h2>环境&amp;安装</h2>

<ul>
<li>Ubuntu 14.04 LTS</li>
<li>Visual Studio Code 0.1.0</li>
</ul>
<p>主要对比对象是<code>Sublime Text3</code></p>

<pre><code>    wget http://download.microsoft.com/download/0/D/5/0D57186C-834B-463A-AECB-BC55A8E466AE/VSCode-linux-x64.zip

    //注意不要使用归档解压会报错
    unzip  unzip VSCode-linux-x64 -d VS

    //双击VS里的Code就能运行了
</code></pre>

<h2>颜值</h2>

<p><img src="http://7xawrk.com1.z0.glb.clouddn.com/c08cce9034f37cc93fc026bba9a9e326_b.jpg" alt="VSCode"></p>

<p>可以看到VSCode颜值不算太糟糕，绿色的注释散发着一股浓浓的VS的风格，Theme里一共两款主题可以选择，另外一款是白色主题。题外话，我最喜欢的主题是Sublime Text的<code>Monokai</code>。</p>

<h2>性能</h2>

<p>总体来说输入的体验比Sublime Text3稍微要差一点，但是比同类WEB IDE <code>ATOM</code>，<code>Brackets</code>要快太多，ATOM、Brackets已经迭代很多个版本了，VSCode基于ATOM SHELL的，估计ATOM要哭晕在厕所。看到一些网友的测试，在打开大文件上，VSCode已经秒杀了<code>Sublime Text3</code>。</p>

<h2>特性</h2>

<h3>智能提示</h3>

<p>VSCode提供了强大的自动补全、悬浮提示、定义跳转等功能，支持以下语言：</p>

<pre><code>C++, jade, PHP, Python, XML, Batch, F#, DockerFile, Coffee Script, Java, HandleBars, R,Objective-C, PowerShell, Luna, Visual Basic, Markdown
</code></pre>

<p>我测试了下在Javascript、Typscript上体验不错，HTML还支持Angular标签，悬浮提示很详细包括了注解，但是试了下C#貌似没有什么效果，不知道是不是需要特殊的环境。不管怎样，在某些语言上的智能提示已经比其他的同类编辑器已经强太多了，可以和一些IDE媲美。</p>

<p><img src="http://7xawrk.com1.z0.glb.clouddn.com/b3041588c25e63c108d34519c1ed7435_b.jpg" alt="enter image description here"></p>

<p>下面贴几张官网的示例图片:</p>

<p>参数提示：<br><img src="https://code.visualstudio.com/Content/images/editing_evolved_parameterhints.png" alt="enter image description here"></p>

<p>定义跳转：<br><img src="https://code.visualstudio.com/Content/images/editing_evolved_ctrl_hover.png" alt="enter image description here"></p>

<p>引用提示：<br><img src="https://code.visualstudio.com/Content/images/editing_evolved_reference_info.png" alt="enter image description here"></p>

<p>方法定位：<br><img src="https://code.visualstudio.com/Content/images/editing_evolved_symbol.png" alt="enter image description here"></p>

<p>还有其他很酷炫的功能我没测试，大家<a rel="nofollow" href="https://code.visualstudio.com/Docs/editingevolved">官网</a>看吧。</p>

<h3>Markdown</h3>

<p>在Linux桌面上，好用的Markdown编辑器可以说没有，<code>ReText</code>和记事本一样简陋，Sublime Text3虽然可以装插件支持，但是体验不是很好，不支持中文。因此我一直使用的在线Markdown代替。</p>

<p>这回VSCode支持Markdown重新让我看到了点希望。快捷键<code>ctr+shift+v</code>预览，可以看到这个布局还是非常人性化的。</p>

<p><img src="http://7xawrk.com1.z0.glb.clouddn.com/d01756018f5c5bb172180a81522badec_b.jpg" alt="enter image description here"></p>

<p>但是缺点也很明显，首先中文支持不好，编辑器里的中文输入可以改，但是预览还是出现口口，目前找到解决方法。还有不支持快捷键输入，那种像写代码般的快感没有了。没有能自定义CSS的功能，不管在哪种Theme下，<code>&gt;</code> 代码高亮都看不出有什么效果。</p>

<h3>版本控制</h3>

<p>自带了一个git工具，并且放在了一个比较显要的位置上，不过功能不是很全，只能<code>commit</code>等几个操作。自带了类似于git diff的文件比较功能：</p>

<p><img src="http://7xawrk.com1.z0.glb.clouddn.com/ab4461ceb4d7121a0dc7276a0e47c0c4_b.jpg" alt="enter image description here"></p>

<h3>Debug</h3>

<p>Debug需要MONO，所以就没进行测试。详情大家看<a rel="nofollow" href="https://code.visualstudio.com/Docs/debugging">官网</a>吧。</p>

<h2>缺陷</h2>

<h3>中文支持</h3>

<p>默认的字体是不支持中文的，输入中文的时候会出现口口。需要设置一下字体，我使用的是文泉驿，思源也行。</p>

<p>没安装的首先安装这个字体。</p>

<pre><code>sudo apt-get install fonts-wqy-microhei fonts-wqy-zenhei
File -&gt; Preference -&gt; User Settings
//在右侧添加一句：
"editor.fontFamily": "WenQuanYi Micro Hei Mono"
</code></pre>

<p>不过这只能解决编辑器内的中文乱码问题，其他的比如标题栏，markdown预览，该口的还是口。对了还有一点需要注意的是输入法需要是<code>Fctix</code>或者基于<code>Fctix</code>的。</p>

<p>Sublime Text3同样有这问题，事实上Sublime Text3全平台对于中文的支持都不是很好。Linux桌面上的解决方法也是<a rel="nofollow" href="http://my.oschina.net/tsl0922/blog/113495">奇技淫巧</a>。</p>

<h3>插件化</h3>

<p>不过插件化已经提到议程上了，以微软的实力实现这个不难。</p>

<h3>Markdown</h3>

<p>缺陷在上面已经提到了</p>

<h3>设置</h3>

<p>用户设置是直接以JSON形式出现了，虽然说鼠标悬浮上去会看到详细的解释，但还是没有图形化来的简便，而且没有搜索的功能，想要搜索还得以文本的形式复制出来，修改起来略费劲。</p>

<h2>结论</h2>

<p>总体而言，VSCode表现出来的潜力还是不俗的，毕竟还是个预览版，我对接下来的版本比较看好，至少比<code>Brackets</code>要好吧。希望Sublime Text的作者能够更加上心一点，能解决中文问题那就最好了，喜欢Sublime Text3的童鞋们可以看我这篇博文<a rel="nofollow" href="http://reecoblog.info/2015/03/04/my-sublime-text3-setting/">《我的Sublime Text3设置》</a>。</p>

<p>最后，人生苦短，我用<code>geany</code>。</p>

<h2>参考</h2>

<p><a rel="nofollow" href="https://code.visualstudio.com/Docs">https://code.visualstudio.com/Docs</a><br><a rel="nofollow" href="http://www.zhihu.com/question/29984607">http://www.zhihu.com/question/29984607</a></p>

2015年四月30日下午 3:54:11
45个必备的JavaScript Web开发工具
<p>JavaScript是一种灵活多变的脚本语言，它在全世界被广泛的应用在Web页面和服务器应用中。你可以因为任何目的去使用它，但是你需要一些工具。幸运的是，为了完成独特的任务，无以计数的JavaScript工具已经被开发者发布。</p>

<p>这里有45个关于JavaScript的工具，所有这些工具将帮助您创建现代网站与用户所期望的所有特性。它们都提供了精简的设计和简单的接口。。。。</p>

<h2>AngularJS</h2>

<p><a rel="nofollow" href="https://angularjs.org/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/12.jpg" alt="AngularJS"></a><br>
Google创建<a rel="nofollow" href="https://angularjs.org/">AngularJS</a>，目的是提供一个稳定的、轻量级的框架在浏览器中呈现信息。它从服务器收集数据,然后在本地编译模板。换句话说，AngularJS以MVC框架形式来构建在浏览器中运行的HTML、JavaScript和CSS。</p>

<h2>Odyssey.JS</h2>

<p><a rel="nofollow" href="http://cartodb.github.io/odyssey.js/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/13.jpg" alt="Odyssey.JS"></a><br><a rel="nofollow" href="http://cartodb.github.io/odyssey.js/">Odyssey</a> 是一个将故事和地图结合，并绑定了交互文本的工具。图片显示为一个沙箱来构建与地图交互的故事。</p>

<h2>PlayCanvas</h2>

<p><a rel="nofollow" href="https://playcanvas.com/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/14.jpg" alt="PlayCanvas"></a><br><a rel="nofollow" href="https://playcanvas.com/">PlayCanvas</a>是一个围绕WebGL建立的游戏引擎。它把物理、照明、阴影、音频和更多其它特效结合到更一致的工具中,以创建被对象填充的世界。图像显示的是一个针对该框架的在线开发工具。</p>

<h2>Gantt</h2>

<p><a rel="nofollow" href="http://gantt.twproject.com/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/15.jpg" alt="Gantt"></a><br><a rel="nofollow" href="http://gantt.twproject.com/">Gantt</a>是一个基于JQuery构建的JavaScript组件，用于创建图标,任务树和用JSON格式输出结果数据的相关性。它提供了编辑、缩放、数据快捷键,CSS皮肤,等等。</p>

<h2>Handy.JS</h2>

<p><a rel="nofollow" href="http://handyjs.org/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/16.jpg" alt="Handy.JS"></a><br><a rel="nofollow" href="http://handyjs.org/">Handy</a>是一个Nodejs的Web应用模板。Handy提供了一个Web APP所有的基础功能，因此你可以把焦点放在开发让你的APP真正唯一的功能。</p>

<h2>RegExr</h2>

<p><a rel="nofollow" href="http://www.regexr.com/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/17.jpg" alt="RegExr"></a><br><a rel="nofollow" href="http://www.regexr.com/">RegExr</a>是一个在线编辑和测试正则表达式的工具。它提供了一个简单的正则表达式输入界面，并且能实时可视化匹配可编辑的源文本。同时它还提供了一个便捷的RegExp边栏用于描述案例用法。</p>

<h2>TimelineJS</h2>

<p><a rel="nofollow" href="http://timeline.knightlab.com/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/18.jpg" alt="TimelineJS"></a><br><a rel="nofollow" href="http://timeline.knightlab.com/">TimelineJS</a>是一个开源工具，允许任何人建立形象精美的时间轴。初学者可以可以不使用任何东西就能创建一个时间轴。</p>

<h2>Responsive Nav</h2>

<p><a rel="nofollow" href="http://responsive-nav.com/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/19.jpg" alt="Responsive Nav"></a><br><a rel="nofollow" href="http://responsive-nav.com/">Responsive Nav</a>是一个比较小的JavaScript插件，可以帮助你创建针对小屏幕的连续导航。它会利用touch事件和CSS3过渡带来最好的性能。</p>

<h2>Sinon.JS</h2>

<p><a rel="nofollow" href="http://sinonjs.org/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/20.jpg" alt="Sinon.JS"></a><br><a rel="nofollow" href="http://sinonjs.org/">Sinon.JS</a>是一个单独的测试应用，没有依赖关系,适用于任何单元测试框架。</p>

<h2>Mocha</h2>

<p><a rel="nofollow" href="http://mochajs.org/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/21.jpg" alt="Mocha"></a><br><a rel="nofollow" href="http://mochajs.org/">Mocha</a>是一个运行在Nodejs和浏览器上的功能多样的JavaScript测试框架，使异步测试变得简单有趣。</p>

<h2>JS Bin</h2>

<p><a rel="nofollow" href="http://jsbin.com/?html,output"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/22.jpg" alt="JS Bin"></a><br><a rel="nofollow" href="http://jsbin.com/?html,output">JS Bin</a>是一个专门设计用于帮助JavaScript和CSS民间测试的代码片段,在某些上下文中,协作和调试代码的应用。jsbin允许编辑和测试JavaScript和HTML。</p>

<h2>JSLitmus</h2>

<p><a rel="nofollow" href="http://broofa.com/Tools/JSLitmus/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/23.jpg" alt="JSLitmus"></a><br><a rel="nofollow" href="http://broofa.com/Tools/JSLitmus/">JSLitmus</a>,一个轻量级框架，用于创建特别的JavaScript基准测试。</p>

<h2>Bookmarkify</h2>

<p><a rel="nofollow" href="https://bookmarkify.it/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/24.jpg" alt="Bookmarkify"></a><br><a rel="nofollow" href="https://bookmarkify.it/">Bookmarkify</a>使得创建书签工具变得非常简单，仅需要给书签命名，然后输入JavaScript并包含它就可以了。</p>

<h2>Kreate.JS</h2>

<p><a rel="nofollow" href="http://itsjonq.github.io/kreate/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/25.jpg" alt="Kreate.JS"></a><br><a rel="nofollow" href="http://itsjonq.github.io/kreate/">Kreate.JS</a>能够辅助JQuery快速以JQuery对象形式生成DOM元素。你可以“Kreate” 单个元素或者“Kreate”多个元素，直到浏览器奔溃。但多数情况下，Kreate创建单个元素或者多个元素都会比JQuery快。</p>

<h2>YUI Compressor</h2>

<p><a rel="nofollow" href="http://yui.github.io/yuicompressor/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/1.jpg" alt="YUI Compressor"></a><br><a rel="nofollow" href="http://yui.github.io/yuicompressor/">YUI Compressor</a>是用Java创建的命令行工具，用于压缩JavaScript文件。YUI Compressor是100%安全的，并且比其他工具的压缩比高。它也能压缩CSS文件。</p>

<h2>Google Closure Compiler</h2>

<p><a rel="nofollow" href="https://developers.google.com/closure/compiler/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/2.jpg" alt="Google Closure Compiler"></a><br><a rel="nofollow" href="https://developers.google.com/closure/compiler/">Google Closure Compiler</a>能使JavaScript的下载和运行变得更快。它是一个真正针对JavaScript编译的。Google Closure Compiler不是将源语言编译成机器代码,而是从JavaScript编译到更好的JavaScript。</p>

<h2>JSMin</h2>

<p><a rel="nofollow" href="http://crockford.com/javascript/jsmin"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/3.jpg" alt="JSMin"></a><br><a rel="nofollow" href="http://crockford.com/javascript/jsmin">JSMin</a>会删除JavaScript文件中的注释和不必要的空白。它将减少文件一半的尺寸，带来更快的下载速度。它也鼓励更富有表现力的编程风格,因为它消除了下载在精简代码、自文档化方面的成本。</p>

<h2>Packer</h2>

<p><a rel="nofollow" href="http://dean.edwards.name/packer/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/4.jpg" alt="Packer"></a><br><a rel="nofollow" href="http://dean.edwards.name/packer/">Packer</a>是DeanEdwards创建的一个很流行的JavaScript压缩工具，它能自动创建一个压缩版本。只需要粘贴代码，然后点击 ‘Pack’ 按钮。它还能利用JavaScript运行时片进行超常规压缩和动态压缩。</p>

<h2>Meteor</h2>

<p><a rel="nofollow" href="https://www.meteor.com/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/5.jpg" alt="Meteor"></a><br><a rel="nofollow" href="https://www.meteor.com/">Meteor</a>WebApp框架为现代软件开发提供了一个坚实的基础。一些是很实用的，例如拥抱开源社区，促进插件的贡献。Meteor做到了。</p>

<h2>Epoch</h2>

<p><a rel="nofollow" href="http://fastly.github.io/epoch/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/6.jpg" alt="Epoch"></a><br><a rel="nofollow" href="http://fastly.github.io/epoch/">Epoch</a>是一个实时的、用于创建漂亮、平稳流畅和高性能可视化的图表库。<br>
Web Starter Kit<br><a rel="nofollow" href="https://github.com/google/web-starter-kit"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/7.jpg" alt="Web Starter Kit"></a><br><a rel="nofollow" href="https://github.com/google/web-starter-kit">Web Starter Kit</a>是一个致力于协助开发者支持多设备的项目。这意味着通过同步点击、必要时重新加载和保持一切尽可能精简来确保屏幕保持同步。</p>

<h2>Reveal.JS</h2>

<p><a rel="nofollow" href="https://github.com/hakimel/reveal.js/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/8.jpg" alt="Reveal.JS"></a><br><a rel="nofollow" href="https://github.com/hakimel/reveal.js/">Reveal.JS</a>是一个基于HTML5的、很灵活的组件，用于替代PPT。点击按钮，然后复杂的动画会依赖碎片信息而翻转，就跟PPT一样。但是它真正的表现力在与你如何你在你的网络策略中使用它。</p>

<h2>RxJS</h2>

<p><a rel="nofollow" href="http://reactive-extensions.github.io/RxJS/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/9.jpg" alt="RxJS"></a><br><a rel="nofollow" href="http://reactive-extensions.github.io/RxJS/">RxJS</a>是一个为鼠标和键盘添加平滑、反应性的和异步响应生成的事件流。图像显示代码绑定了一个搜索维基百科的事件。</p>

<h2>NodeBB</h2>

<p><a rel="nofollow" href="https://nodebb.org/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/10.jpg" alt="NodeBB"></a><br>
基于节点演化的公告板隐喻是及时和可定制的,并提供实时流的对话。<a rel="nofollow" href="https://nodebb.org/">NodeBB</a>的发展已经添加了更多现代主题，并支持小屏幕的手机和平板。</p>

<h2>Gulp.JS</h2>

<p><a rel="nofollow" href="http://gulpjs.com/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/11.jpg" alt="Gulp.JS"></a><br><a rel="nofollow" href="http://gulpjs.com/">Gulp.JS</a>是一个流构建系统。它使用流和代码配置创建更简单和直观的构建。宁愿选择代码配置,让简单的事情变得简单,使复杂的任务易于管理。</p>

<h2>Contour</h2>

<p><a rel="nofollow" href="http://forio.com/contour/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/26.jpg" alt="Contour"></a><br><a rel="nofollow" href="http://forio.com/contour/">Contour</a>是Forio的一个可视化库，用于提供一组核心的公共可视化功能。建立在受欢迎的D3引擎之上,轮廓让你轻松创建数据可视化和基于常用的图表等直观的抽象。</p>

<h2>Nightwatch.JS</h2>

<p><a rel="nofollow" href="http://nightwatchjs.org/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/27.jpg" alt="Nightwatch.JS"></a><br>
对基于浏览器的APP和网站，<a rel="nofollow" href="http://nightwatchjs.org/">Nightwatch.JS</a>能使用Node.js建立基于端到端的测试解决方案。它使用强大的Selenium WebDriver API在DOM元素上执行命令和断言。</p>

<h2>EasyStar.JS</h2>

<p><a rel="nofollow" href="http://www.easystarjs.com/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/28.jpg" alt="EasyStar.JS"></a><br><a rel="nofollow" href="http://www.easystarjs.com/">EasyStar.JS</a>是一个用JavaScript编写的异步A*寻路API,可应用在HTML5游戏和互动项目。这个项目的目标是使它容易和快速实现性能意识上的寻路。</p>

<h2>Headroom.JS</h2>

<p><a rel="nofollow" href="http://wicky.nillia.ms/headroom.js/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/29.jpg" alt="Headroom.JS"></a><br><a rel="nofollow" href="http://wicky.nillia.ms/headroom.js/">Headroom.JS</a>是一个轻量级、高性能javascript小部件,允许你对用户的滚动做出反应。这个网站的头部就是一个实例,当向下滚动时，头部会滑出视窗，向上滚动时又滑入视窗。</p>

<h2>FileAPI</h2>

<p><a rel="nofollow" href="http://mailru.github.io/FileAPI/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/30.jpg" alt="FileAPI"></a><br><a rel="nofollow" href="http://mailru.github.io/FileAPI/">FileAPI</a>是一组处理所有跟文件相关的工作的组件库。它提供了许多功能，文件上传（单个/多个）、拖放支持、图像裁剪、大小调整、应用过滤器和获取文件信息等等。</p>

<h2>Unminify</h2>

<p><a rel="nofollow" href="http://unminify.com/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/31.jpg" alt="Unminify"></a><br><a rel="nofollow" href="http://unminify.com/">Unminify</a>对于格式化JavaScript、CSS和HTML代码是很有用的工具，并且会让代码变得易读和漂亮。</p>

<h2>HarpJS</h2>

<p><a rel="nofollow" href="http://harpjs.com/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/32.jpg" alt="HarpJS"></a><br><a rel="nofollow" href="http://harpjs.com/">HarpJS</a>是一个静态服务器，在没有任何配置的情况下，也为Jade, Markdown, EJS, Less, Stylus, Sass, CoffeeScript asHTML, CSS和JavaScript 提供服务。它支持爱心式的布局/部分模式,并能灵活的遍历文件系统元数据、全局对象和注入定制数据模板。</p>

<h2>JSHint</h2>

<p><a rel="nofollow" href="http://jshint.com/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/33.jpg" alt="JSHint"></a><br><a rel="nofollow" href="http://jshint.com/">JSHint</a>是一个社区驱动的工具,用于检测JavaScript中的语法错误和潜在的问题，并执行你的团队的编码惯例。</p>

<h2>GruntJS</h2>

<p><a rel="nofollow" href="http://gruntjs.com/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/34.jpg" alt="GruntJS"></a><br><a rel="nofollow" href="http://gruntjs.com/">GruntJS</a>是一个基于任务的命令行JavaScript项目构建工具。下面的预定义的任务,可以直接在你的项目中使用:连接文件、用JSHint验证文件、用UglifyJS压缩文件和用节点单元运行单元测试。</p>

<h2>ZeptoBuilder</h2>

<p><a rel="nofollow" href="http://github.e-sites.nl/zeptobuilder/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/35.jpg" alt="ZeptoBuilder"></a><br><a rel="nofollow" href="http://github.e-sites.nl/zeptobuilder/">ZeptoBuilder</a>是Zepto的一个在线版本，从列表中选取你想包含的文件，就能得到你自定义的构建了。</p>

<h2>Gif.JS</h2>

<p><a rel="nofollow" href="http://jnordberg.github.io/gif.js/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/36.jpg" alt="Gif.JS"></a><br><a rel="nofollow" href="http://jnordberg.github.io/gif.js/">Gif.JS</a>是一个能运行在你的浏览器中的JavaScript GIF编码器。</p>

<h2>Favico.JS</h2>

<p><a rel="nofollow" href="http://lab.ejci.net/favico.js/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/37.jpg" alt="Favico.JS"></a><br><a rel="nofollow" href="http://lab.ejci.net/favico.js/">Favico.JS</a>可以让你为你的图标添加动画徽章,图片,甚至视频,或者从图像、视频,甚至从访问者的摄像头获取的现场图片创建一个图标。</p>

<h2>Chart.JS</h2>

<p><a rel="nofollow" href="http://www.chartjs.org/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/38.jpg" alt="Chart.JS"></a><br><a rel="nofollow" href="http://www.chartjs.org/">Chart.JS</a>生成简单,干净,和基于HTML5的JavaScript图表。它用一种简单的方式，能在你的网站上自由的包含动画、交互式图形。</p>

<h2>AdminJS</h2>

<p><a rel="nofollow" href="http://adminjs.com/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/39.jpg" alt="AdminJS"></a><br><a rel="nofollow" href="http://adminjs.com/">AdminJS</a>是一个独立包含Ember.js的应用，它的两个主要文件是adminjs.js和 adminjs.css。两者都需要和Ember.js和EPF.一起被包含在页面中。</p>

<h2>Sir Trevor</h2>

<p><a rel="nofollow" href="http://madebymany.github.io/sir-trevor-js/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/40.jpg" alt="Sir Trevor"></a><br>
[]Sir Trevor](<a rel="nofollow" href="http://madebymany.github.io/sir-trevor-js/">http://madebymany.github.io/sir-trevor-js/</a>)是一个会完全重绘网页内容的工具：直观的编辑网页内容而不用假定任何关于它是如何重绘的事。</p>

<h2>Instano.JS</h2>

<p><a rel="nofollow" href="http://laucheukhim.github.io/instano/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/41.jpg" alt="Instano.JS"></a><br>
页面加载之后，<a rel="nofollow" href="http://laucheukhim.github.io/instano/">Instano.JS</a>允许你及时检测JavaScript是否可用。它修改了标准的标记以致于不管JavaScript什么时候被禁用，里面的消息都能被显示。</p>

<h2>Resumable.JS</h2>

<p><a rel="nofollow" href="http://www.resumablejs.com/"><img src="http://developerdrive.developerdrive.netdna-cdn.com/wp-content/uploads/2015/01/43.jpg" alt="Resumable.JS"></a><br><a rel="nofollow" href="http://www.resumablejs.com/">Resumable.JS</a>是一个JavaScript库，通过HTML5 API提供了稳定可恢复的多文件上传功能。</p>

<hr>
<p>英文原文：<a rel="nofollow" href="http://www.developerdrive.com/2015/01/40-essential-javascript-tools-for-the-web/">40+ essential JavaScript tools for the Web</a><br>
译文出处：<a rel="nofollow" href="http://www.ido321.com/1543.html">http://www.ido321.com/1543.html</a></p>

2015年四月30日下午 2:35:43
CentOS 安装 Subversion
<h2>安装依赖</h2>

<p>命令：<code>yum install mod_dav_svn subversion</code></p>

<p>貌似只要安装mod_dav_svn时，就会把subversion和Apache安装上。</p>

<h2>Subversion's Apache 配置</h2>

<p>命令如下：</p>

<pre><code>[root@lucifer ~] cd /etc/httpd/conf.d/
[root@lucifer ~] vim subversion.conf

# 有需要的话，请确定你删除这两行的注释
LoadModule dav_svn_module     modules/mod_dav_svn.so
LoadModule authz_svn_module   modules/mod_authz_svn.so

# 加入下列内容来支持基本验证，并将 Apache 指向实际放置版本库的地方。
&lt;Location /repos&gt;
        DAV svn
        SVNPath /var/www/svn/repos
        AuthType Basic
        AuthName "Subversion repos"
        AuthUserFile /etc/svn-auth-conf
        Require valid-user
&lt;/Location&gt;
</code></pre>

<p>上面的位置是 Apache 在 URL 上使用的。举个例说：<a rel="nofollow" href="http://yourmachine/repos">http://yourmachine/repos</a> 指向你所指定的 SVNPath。上面只是一个样例，因此请按你的首选放置东西。请确定你在完成编辑后存储文件。</p>

<p>然后我们须要创建你在上一步所指定的口令档。开始时你要利用 -cm 这个选项。它会创建文件并用 MD5 将口令加密。如果你需要加用户，请确定你只使用 -m 选项，而不包含初次创建时的 -c。</p>

<h2>设置你的版本库</h2>

<p>你接著要做的事情就是创建你用来提交及取出文件的版本库。利用 svn 所包含的工具，这是很容易的。</p>

<pre><code>[root@lucifer ~] cd /var/www/ —— 或者你在上面所指定的路径
[root@lucifer ~] mkdir svn
[root@lucifer ~] cd svn
[root@lucifer ~] svnadmin create repos
[root@lucifer ~] chown -R apache.apache repos  （这步很重要）
[root@lucifer ~] service httpd restart
</code></pre>

<p>现在去测试你能否通过网页浏览器访问你的版本库：<a rel="nofollow" href="http://yourmahcine/repos">http://yourmahcine/repos</a> 。你应该取得一个对话框询问用户名称及口令。若然是这样，请输入你的凭证，然后你应该看见一版 Revision 0:/ 的页面。这样的话，版本库的设置便大工告成了。如果你须要多个版本库，请参考上面连结内的文档。这里只示范如何设置一个版本库及开始应用它。话说回来，让我们就这样做。</p>

<h2>参考</h2>

<p>英文原文：<a rel="nofollow" href="http://wiki.centos.org/HowTos/Subversion">http://wiki.centos.org/HowTos/Subversion</a><br>
中文翻译：<a rel="nofollow" href="http://wiki.centos.org/zh/HowTos/Subversion">http://wiki.centos.org/zh/HowTos/Subversion</a><br>
CentOS搭建Nginx+Subversion环境：<a rel="nofollow" href="http://www.opstool.com/article/282">http://www.opstool.com/article/282</a><br>
CentOS Linux搭建SVN Server配置详解：<a rel="nofollow" href="http://www.ha97.com/4467.html">http://www.ha97.com/4467.html</a></p>

2015年四月30日下午 2:20:27
美国大数据创业公司总结
<p>最近调研了一下美国的大数据创业公司，总结如下，如有疏漏，欢迎反馈指正(boyang798@gmail.com)。</p>

<table>
<thead><tr>
<th>公司</th>
  <th>成立时间</th>
  <th>技术亮点</th>
  <th>IPO或者收购</th>
</tr></thead>
<tbody>
<tr>
<td>hortonworks.com</td>
  <td>June, 2011</td>
  <td>三大主要Hadoop平台提供商之一, 提供Windows平台Hadoop支持</td>
  <td>IPO，Dec 11, 2014</td>
</tr>
<tr>
<td>cloudera.com</td>
  <td>October, 2008</td>
  <td>三大主要Hadoop平台提供商之一, 用户基数最大的Hadoop平台</td>
  <td></td>
</tr>
<tr>
<td>mapr.com</td>
  <td>July, 2009</td>
  <td>三大主要Hadoop平台提供商之一, 实现自己的Linux文件系统来提升Hadoop速度</td>
  <td></td>
</tr>
<tr>
<td>databricks.com</td>
  <td>September，2013</td>
  <td>创立Apache Spark，提升Hadoop速度10倍，同时提供优于MapReduce的编程模型</td>
  <td></td>
</tr>
<tr>
<td>datameer.com</td>
  <td>September, 2009</td>
  <td>提供端到端（从数据收集到数据可视化）的一站式大数据分析平台</td>
  <td></td>
</tr>
<tr>
<td>palantir.com</td>
  <td>January, 2004</td>
  <td>自有技术，着重于非机构化数据深度分析，初期以政府客户为主，后扩展到银行和金融领域</td>
  <td></td>
</tr>
<tr>
<td>splunk.com</td>
  <td>October, 2003</td>
  <td>大规模机器数据（日志）收集，存储，可视化分析</td>
  <td>IPO，Apr 19, 2012</td>
</tr>
<tr>
<td>vertica.com</td>
  <td>May, 2005</td>
  <td>基于列存储的数据库技术，提升数据仓库查询速度，注重MPP(massively parallel processing),企业级Hadoop方案和SQL on Hadoop</td>
  <td>被Hewlett-Packard收购，February 14, 2011</td>
</tr>
<tr>
<td>autonomy.com</td>
  <td>January, 1996</td>
  <td>自有非Hadoop大数据技术，非主流技术，但是比较有特色</td>
  <td>被Hewlett-Packard收购，August 18, 2011，但是被业界认为是HP的一个失败收购案例</td>
</tr>
<tr>
<td>teradata.com</td>
  <td>July, 1979</td>
  <td>老牌传统数据仓库提供商，扩展业务到Hadoop平台</td>
  <td>December 1991被NCR收购，之后又由NCR公司剥离，作为单独的上市公司，Oct 5, 2007</td>
</tr>
<tr>
<td>jaspersoft.com</td>
  <td>June, 2001</td>
  <td>侧重于商务数据分析报表，提供移动端的报表工具</td>
  <td>被TIBCO Software收购，April 28, 2014</td>
</tr>
<tr>
<td>karmasphere.com</td>
  <td>April, 2010</td>
  <td>基于Hadoop的解决方案和数据可视化分析</td>
  <td>被FICO收购，April 2014</td>
</tr>
<tr>
<td>domo.com</td>
  <td>October, 2010</td>
  <td>提供数据分析云服务平台</td>
  <td></td>
</tr>
<tr>
<td>talend.com</td>
  <td>September, 2005</td>
  <td>提供多种数据集成服务</td>
  <td></td>
</tr>
<tr>
<td>qubole.com</td>
  <td>December, 2014</td>
  <td>提供Hadoop云平台服务</td>
  <td></td>
</tr>
<tr>
<td>treasuredata.com</td>
  <td>December, 2011</td>
  <td>提供大数据存储，查询，分析云服务</td>
  <td></td>
</tr>
<tr>
<td>platfora.com</td>
  <td>June, 2011</td>
  <td>端到端一站式大数据平台解决方案，基于Hadoop和Spark</td>
  <td></td>
</tr>
<tr>
<td>interana.com</td>
  <td>January, 2013</td>
  <td>自服务数据分析平台，侧重于面向事件的数据</td>
  <td></td>
</tr>
<tr>
<td>gridgain.com</td>
  <td>May, 2005</td>
  <td>基于内存的大数据实时处理系统</td>
  <td></td>
</tr>
<tr>
<td>metamarkets.com</td>
  <td>May, 2010</td>
  <td>在线广告领域内数据实时处理分析平台</td>
  <td></td>
</tr>
<tr>
<td>pivotal.io</td>
  <td>April, 2013</td>
  <td>大数据集成产品，提供Hadoop，内存Non-SQL数据库，RabbitMQ，以及Greenplum MPP(massively parallel processing)等多种服务</td>
  <td></td>
</tr>
<tr>
<td>fiscalnote.com</td>
  <td>April, 2013</td>
  <td>使用大数据和人工智能技术预测立法机构的投票结果</td>
  <td></td>
</tr>
<tr>
<td>dato.com</td>
  <td>May, 2013</td>
  <td>专注于机器学习的数据处理平台，非hadoop技术，底层用C++实现，从GraphLab（graph based framework）发展而来</td>
  <td></td>
</tr>
</tbody>
</table>
<hr>
<p>除了以上大数据公司外，还有很多各具特色的公司，比如专门提供Non-SQL数据库的公司：</p>

<table>
<thead><tr>
<th>Non-SQL数据库</th>
  <th>公司</th>
</tr></thead>
<tbody>
<tr>
<td>Cassandra</td>
  <td>datastax.com</td>
</tr>
<tr>
<td>MongoDB</td>
  <td>mongodb.com</td>
</tr>
<tr>
<td>Couchbase</td>
  <td>couchbase.com</td>
</tr>
<tr>
<td>FoundationDB</td>
  <td>foundationdb.com</td>
</tr>
</tbody>
</table>
<hr>
<p>其它还有很多提供商务数据分析，可视化报表，大数据平台的公司，就不详细例举了，包括：Tableau, GoodData, ZoomData, SpagoBI, Pentaho, Eclipse BIRT, birst, netezza, paraccel, Ayasdi, Trifecta, Clearstory, Alpine Data Labs, Altiscale, Trifacta, Splice Machine, DataTorrent, Continuuity, Xplenty, Aerospike, snowflake.net, SumAll, Tamr, wibidata</p>

<hr>
<p>从对美国大数据市场的调研来看，我们可以得到一些启示：</p>

<ol>
<li><p>美国的数据分析市场非常大，容纳超过30家公司，这得益于美国信息化的高度发达。</p></li>
<li><p>虽然有很多公司，但是大家很少有重复竞争，每一家都有自己的特色，在自己的领域内发展，这也符合美国公司注重差异化相关。</p></li>
<li><p>传统的商务数据分析公司在维持旧有客户和平台的情况下，在积极向大数据技术扩展。</p></li>
<li><p>新兴的大数据技术发展非常快，但是目前还没有到成熟阶段，除了Hadoop之外，没有其他统一的技术被各家公司采用。</p></li>
<li><p>新的大数据技术趋势是快速响应，开始追求数据的实时处理和快速查询。</p></li>
</ol>
<hr>
<p>相对于美国市场，中国的大数据市场还处于非常初期的阶段，这可能跟中国的信息化程度相关。做长期展望预测，如果中国的信息化发展到美国的阶段，并且公司普遍采用基于数据的量化决策机制，将会迎来一个大数据发展的爆发式增长。</p>

<p>扫描微信二维码联系作者<br><img src="http://s3-us-west-1.amazonaws.com/wechatboyang/qrcode/BoYangWeChatQRCode.jpg" alt="扫描微信二维码联系作者"></p>

2015年四月30日上午 10:49:50
提问的智慧
<h2>案例</h2>

<blockquote>
  <p>我想要一个XX的完美实现，各位大神谁能说下怎样实现？</p>
</blockquote>

<p>PS:我看到这个问题的内容，冲动的就想把它删了，根本都不会去考虑怎么回答。你这是问题吗？</p>

<hr>
<blockquote>
  <p><em>以下省略1大段描述</em>，<em>这里有个截图显示的是一些code</em>，请问大家这样的错误是怎么回事？</p>
</blockquote>

<p>PS:X。。。你这是想害死人的节奏啊，问题中的code用截图，是你省事了还是想害死给你解答问题的人？我们连在其他地方try一下的机会都没有了，除非按照截图一个字母一个字母的敲，这是有多大的仇？</p>

<hr>
<blockquote>
  <p>mysql连接显示"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"，我调用了XXXXXX，但还是出现这个错误，请帮忙解决。</p>
</blockquote>

<p>PS:多点描述会死吗？</p>

<p>之后如果你有耐心的话，就和题主挤牙膏吧！问一句答一句，这是贴吧！不是问答。</p>

<hr>
<blockquote>
  <p>请问各位大神，怎样实现XXXXXXX？……</p>
</blockquote>

<blockquote>
  <p>我遇到了一个XXXXX问题……</p>
</blockquote>

<p>PS:经常性的看到很多的问题，竟然找度娘都能搜到答案，可是为啥题主就不知道看看？</p>

<hr>
<p>还遇到过不同的3个人，发的相同的3个问题，这是刷分的节奏吗？特地等了很久没看到有人会回复，试着回了一下，没有任何的相应。。这是什么意思？</p>

<hr>
<p>难道说答题的人就没事了吗？不是！</p>

<p>碰到过一个问题，就上面截图的例子，我因为觉得奇葩，一个字母一个字母敲的，最后为了省事和题主的命名不太一样，写了例子发了截图来证明没问题。竟然被其他答复者踩，说我这样命名不对，和题主相同的命名才会有问题。好吧，我承认因为自己懒，这么做了有问题？就改一下试试，但我试过之后证明这个答复者说的话是错的，和题主相同命名也不会有问题。没有责任心的答复亏你发的出来！</p>

<hr>
<h2>警语</h2>

<p>看到一个描述不明确的问题，现在懒得和挤牙膏一样慢慢的挤了，但是多天过去后还是没人答复问题，我总是会多余的问一下，不是想说自己怎么样，只是因为我有遇到紧急问题时的经历知道那是一种什么样的心态。</p>

<p>答复你的人，可能是正在工作，可能加班回家休息刚起床，又可能是个脱离了技术岗位的热心人士……总之答复你的人，没有任何义务在你提出问题后答复你问题！有人说有积分哦！积分算个P！多少人真不是看中积分才回答你的，大家都是从一个问题又一个问题走过来的，都明白遇到了解决不了问题的心情，技术注重的是交流，所以才会有这个平台的市场来供大家交流。</p>

<p><strong>我想奉劝大家，提问要有智慧！哪怕你再着急，也要言之有物，越着急越应该把所有相关的信息列出来，这样才会让其他人在空闲的时间看到问题思考后，给你一个答复，而不是把所有的时间都费在"挤牙膏"身上！</strong></p>

2015年四月30日早上 7:18:00
你真的弄明白 new 了吗
<p>好久没有写点东西了，总觉得自己应该写点牛逼的，却又不知道如何下笔。既然如此，还是回归最基本的吧，今天就来说一说这个<code>new</code>。关于javascript的<code>new</code>关键字的内容上网搜一搜还真不少，大家都说<code>new</code>干了3件事：</p>

<ul>
<li>创建一个空对象</li>
<li>将空对象的<code>__proto__</code>指向构造函数的<code>prototype</code>
</li>
<li>使用空对象作为上下文调用构造函数</li>
</ul>
<p>文字比较难懂，翻译成javascript：</p>

<pre><code>javascript</code><code>function Base() {
    this.str = "aa";
}

// new Base()干了下面的事
var obj  = {};
obj.__proto__ = Base.prototype;
Base.call(obj);
</code></pre>

<p>想想是这么回事哈，那就赶快试试：</p>

<pre><code>javascript</code><code>var b = new Base();
console.dir(b); // Base {str: 'aa', __proto__: Base}
</code></pre>

<p>好像是正确的，但是真的正确吗？？？</p>

<h2>真的就3件事？</h2>

<p>每个对象都有一个<code>constructor</code>属性，那么我们来试试看<code>new</code>出来的实例的<code>constructor</code>是什么吧。</p>

<pre><code>javascript</code><code>console.dir(b.constructor); // [Function: Base]
</code></pre>

<p>可以看出实例b的<code>constructor</code>属性就是<code>Base</code>，那么我们可以猜测<code>new</code>是不是至少还做了第4件事：</p>

<pre><code>javascript</code><code>b.constructor = Base;
</code></pre>

<p>以上结果看似正确，下面我们进行一点修改，这里我们修改掉原型的<code>constructor</code>属性：</p>

<pre><code>javascript</code><code>Base.prototype.constructor = function Other(){ };
var b = new Base();
console.dir(b.constructor); // [Function: Other]
</code></pre>

<p>情况就不一样了，可以看出，之前的猜测是错误的，第4件事应该是这样的：</p>

<pre><code>javascript</code><code>b.constructor = Base.prototype.constructor;
</code></pre>

<p>这里犯了一个错误，那就是没有理解好这个<code>constructor</code>的实质：<strong>当我们创建一个函数时，会自动生成对应的原型，这个原型包含一个<code>constructor</code>属性</strong>，使用<code>new</code>构造的实例，可以通过原型链查找到<code>constructor</code>。如下图所示：</p>

<p><img src="/img/bVlzPC" alt="constructor"></p>

<p>这里非常感谢<a rel="nofollow" href="http://segmentfault.com/u/zonxin">zonxin</a>同学指出我的错误。</p>

<h2>如果构造函数有返回值呢？</h2>

<p>一般情况下构造函数没有返回值，但是我们依旧可以得到该对象的实例；如果构造函数有返回值，凭直觉来说情况应该会不一样。我们对于之前的构造函数进行一点点修改：</p>

<pre><code>javascript</code><code>function Base() {
    this.str = "aa";
    return 1;
    // return "a";
    // return true;
}
var b = new Base();
console.dir(b); // { str: 'aa'}
</code></pre>

<p>我们在构造函数里设置的返回值好像没什么用，返回的还是原来对象的实例，换一些例子试试：</p>

<pre><code>javascript</code><code>function Base() {
    this.str = "aa";
    return [1];
    // return {a:1};
}
var b = new Base();
console.dir(b); // [1] or {a: 1}
</code></pre>

<p>此时结果就不一样了，从上面的例子可以看出，<strong>如果构造函数返回的是原始值，那么这个返回值会被忽略，如果返回的是对象，就会覆盖构造的实例</strong>。</p>

<h2>new至少做了4件事</h2>

<p>总结一下，<code>new</code>至少做了4件事：</p>

<pre><code>javascript</code><code>// new Base();

// 1.创建一个空对象 obj
var obj = {};
// 2.设置obj的__proto__为原型
obj.__proto__ = Base.prototype;
// 3.使用obj作为上下文调用Base函数
var ret = Base.call(obj);
// 4.如果构造函数返回的是原始值，那么这个返回值会被忽略，如果返回的是对象，就会覆盖构造的实例
if(typeof ret == 'object'){
    return ret;
} else {
    return obj;
}
</code></pre>

<h2>new的不足</h2>

<p>在《Javascript语言精粹》（Javascript: The Good Parts）中，道格拉斯认为应该避免使用<code>new</code>关键字：</p>

<blockquote>
  <p>If you forget to include the new prefix when calling a constructor function, then this will not be bound to the new object. Sadly, this will be bound to the global object, so instead of augmenting your new object, you will be clobbering global variables. That is really bad. There is no compile warning, and there is no runtime warning.</p>
</blockquote>

<p>大意是说在应该使用<code>new</code>的时候如果忘了<code>new</code>关键字，会引发一些问题。最重要的问题就是影响了原型查找，原型查找是沿着<code>__proto__</code>进行的，而任何函数都是<code>Function</code>的实例，一旦没用使用<code>new</code>，你就会发现什么属性都查找不到了，因为相当于直接短路了。如下面例子所示，没有使用<code>new</code>来创建对象的话，就无法找到原型上的fa1属性了：</p>

<pre><code>javascript</code><code>function F(){ }
F.prototype.fa1 = "fa1";

console.log(F.fa1);       // undefined
console.log(new F().fa1); // fa1
</code></pre>

<p>这里我配合一张图来说明其中原理，黄色的线为原型链，使用<code>new</code>构造的对象可以正常查找到属性<code>fa1</code>，没有使用<code>new</code>则完全走向了另外一条查找路径：</p>

<p><img src="/img/bVlztF" alt="原型查找"></p>

<p>以上的问题对于有继承的情况表现得更为明显，沿着原型链的方法和属性全都找不到，你能使用的只有短路之后的<code>Function.prototype</code>的属性和方法了。</p>

<p>当然了，遗忘使用任何关键字都会引起一系列的问题。再退一步说，这个问题是完全可以避免的：</p>

<pre><code>javascript</code><code>function foo()
{   
   // 如果忘了使用关键字，这一步骤会悄悄帮你修复这个问题
   if ( !(this instanceof foo) )
      return new foo();

   // 构造函数的逻辑继续……
}
</code></pre>

<p>可以看出<code>new</code>并不是一个很好的实践，道格拉斯将这个问题描述为：</p>

<blockquote>
  <p>This indirection was intended to make the language seem more familiar to classically trained programmers, but failed to do that, as we can see from the very low opinion Java programmers have of JavaScript. JavaScript’s constructor pattern did not appeal to the classical crowd. It also obscured JavaScript’s true prototypal nature. As a result, there are very few programmers who know how to use the language effectively.</p>
</blockquote>

<p>简单来说，JavaScript是一种prototypical类型语言，在创建之初，是为了迎合市场的需要，让人们觉得它和Java是类似的，才引入了<code>new</code>关键字。Javascript本应通过它的Prototypical特性来实现实例化和继承，但<code>new</code>关键字让它变得不伦不类。</p>

<h2>再说一点关于constructor的</h2>

<p>虽然使用<code>new</code>创建新对象的时候用讨论了这个<code>constructor</code>属性，但是这个属性似乎并没有什么用，也许设置这个属性就是一种习惯，能够让其他人直观理解对象之间的关系。</p>

<p>欢迎光临小弟博客：<a rel="nofollow" href="http://blog.liuwanlin.info/">Superlin's Blog</a><br>
我的博客原文：<a rel="nofollow" href="http://blog.liuwanlin.info/newzhi-shao-gan-liao-5jian-shi/">你真的弄明白new了吗</a></p>

<h2>参考</h2>

<ul>
<li><a rel="nofollow" href="http://coolshell.cn/articles/6668.html">再谈javascript面向对象编程</a></li>
<li><a rel="nofollow" href="http://www.infoq.com/cn/articles/javascript-instantiation-and-inheritance">JavaScript的实例化与继承：请停止使用new关键字</a></li>
</ul>

2015年四月29日晚上 9:08:52
地图移动应用实战：Ionic ElasticSearch 搜索服务
<p>在上一篇<a rel="nofollow" href="http://www.phodal.com/blog/django-elasticsearch-ionic-build-gis-application-create-model/">《GIS 移动应用实战 —— Django Haystack ElasticSearch 构建》</a>中，我们构建了我们的服务端，可以通过搜索搜索到结果，这一篇，我们来构建一个简单的搜索。</p>

<p>最后效果如下图所示:</p>

<p><img src="http://www.phodal.com/static/media/uploads/ionic_elasticsearch_search_view.jpg" alt="Ionic ElasticSearch"></p>

<h2>开始之前</h2>

<p>如果你没有Ionic的经验，可以参考一下之前的一些文章:<a rel="nofollow" href="http://www.phodal.com/blog/ionic-development-android-ios-windows-phone-application/">《HTML5打造原生应用——Ionic框架简介与Ionic Hello World》</a>。</p>

<p>我们用到的库有:</p>

<ul>
<li>elasticsearch</li>
<li>ionic</li>
<li>ngCordova</li>
</ul>
<p>将他们添加到<code>bower.json</code>，然后</p>

<pre><code>bower install
</code></pre>

<p>吧</p>

<h2>Ionic ElasticSearch 创建页面</h2>

<p>1.引入库</p>

<p>在<code>index.html</code>中添加</p>

<pre><code>&lt;script src="lib/elasticsearch/elasticsearch.angular.min.js"&gt;&lt;/script&gt;
&lt;script src="lib/ngCordova/dist/ng-cordova.js"&gt;&lt;/script&gt;
</code></pre>

<p>接着开始写我们的搜索模板<code>tab-search.html</code></p>

<pre><code>html</code><code>    &lt;ion-view view-title="搜索" ng-controller="SearchCtrl"&gt;
        &lt;ion-content&gt;
            &lt;div id="search-bar"&gt;
                &lt;div class="item item-input-inset"&gt;
                    &lt;label class="item-input-wrapper" id="search-input"&gt;
                        &lt;i class="icon ion-search placeholder-icon"&gt;&lt;/i&gt;
                        &lt;input type="search" placeholder="Search" ng-model="query" ng-change="search(query)" autocorrect="off"&gt;
                    &lt;/label&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/ion-content&gt;
    &lt;/ion-view&gt;
</code></pre>

<p>显示部分</p>

<pre><code>xml</code><code> &lt;ion-list&gt;
                &lt;ion-item class="item-remove-animate item-icon-right" ng-repeat="result in results"&gt;
                    &lt;h2 class="icon-left"&gt;{{result.title}}&lt;/h2&gt;
                    &lt;p&gt;简介: {{result.body}}&lt;/p&gt;
                    &lt;div class="icon-left ion-ios-home location_info"&gt;
                        {{result.location_info}}
                    &lt;/div&gt;
                    &lt;div class="button icon-left ion-ios-telephone button-calm button-outline"&gt;
                        &lt;a ng-href="tel: {{result.phone_number}}"&gt;{{result.phone_number}}&lt;/a&gt;
                    &lt;/div&gt;
                &lt;/ion-item&gt;
            &lt;/ion-list&gt;
</code></pre>

<p>而我们期待的<code>SearchCtrl</code>则是这样的</p>

<pre><code>$scope.query = "";
var doSearch = ionic.debounce(function(query) {
    ESService.search(query, 0).then(function(results){
        $scope.results = results;
    });
}, 500);

$scope.search = function(query) {
    doSearch(query);
}
</code></pre>

<p>当我们点下搜索的时候，调用 ESService.</p>

<h2>Ionic ElasticSearch Service</h2>

<p>接着我们就来构建我们的ESService，下面的部分来自网上:</p>

<pre><code>angular.module('starter.services', ['ngCordova', 'elasticsearch'])

.factory('ESService',
  ['$q', 'esFactory', '$location', '$localstorage', function($q, elasticsearch, $location, $localstorage){
    var client = elasticsearch({
      host: $location.host() + ":9200"
    });

    var search = function(term, offset){
      var deferred = $q.defer(), query, sort;
      if(!term){
        query = {
          "match_all": {}
        };
      } else {
        query = {
          match: { title: term }
        }
      }

      var position = $localstorage.get('position');

      if(position){
        sort = [{
          "_geo_distance": {
            "location": position,
            "unit": "km"
          }
        }];
      } else {
        sort = [];
      }

      client.search({
        "index": 'haystack',
        "body": {
          "query": query,
          "sort": sort
        }
      }).then(function(result) {
        var ii = 0, hits_in, hits_out = [];
        hits_in = (result.hits || {}).hits || [];
        for(;ii &lt; hits_in.length; ii++){
          var data = hits_in[ii]._source;
          var distance = {};
          if(hits_in[ii].sort){
            distance = {"distance": parseFloat(hits_in[ii].sort[0]).toFixed(1)}
          }
          angular.extend(data, distance);
          hits_out.push(data);
        }
        deferred.resolve(hits_out);
      }, deferred.reject);

      return deferred.promise;
    };


    return {
      "search": search
    };
  }]
);
</code></pre>

<p>这个Service主要做的是创建ElasitcSearch Query，然后返回解析结果。</p>

<h2>运行</h2>

<p>如果是要在真机上运行，需要处于同一网段，或者是部署到服务器上。</p>

<h2>其他</h2>

<p>服务端代码: <a rel="nofollow" href="https://github.com/phodal/django-elasticsearch"></a><a rel="nofollow" href="https://github.com/phodal/django-elasticsearch">https://github.com/phodal/django-elasticsearch</a><br>
客户端代码: <a rel="nofollow" href="https://github.com/phodal/ionic-elasticsearch"></a><a rel="nofollow" href="https://github.com/phodal/ionic-elasticsearch">https://github.com/phodal/ionic-elasticsearch</a></p>

2015年四月29日晚上 9:05:33
SegmentFault for Android.
<blockquote>
  <p>我用尽一生的好运气去遇见你。<br>
  所幸，这运气够长够远，足够我陪你一辈子。</p>
</blockquote>

<h3>非常荣幸的告诉大家，SegmentFault For Android 1.0 已经在以下市场发布</h3>

<ol>
<li><a rel="nofollow" href="https://play.google.com/store/apps/details?id=com.segmentfault.app">Google Play</a></li>
<li><a rel="nofollow" href="http://www.wandoujia.com/apps/com.segmentfault.app">豌豆荚</a></li>
<li><a rel="nofollow" href="http://sj.qq.com/myapp/detail.htm?apkName=com.segmentfault.app">应用宝</a></li>
<li><a rel="nofollow" href="http://app.mi.com/detail/93605">小米</a></li>
<li>360</li>
</ol>
<p>现在大家可以在已经发布的市场中搜索我们的App进行试用啦~</p>

<blockquote>
  <p>如果SegmentFault是一本书，您就是那唯一能领略它墨香的读者，只为您散尽芳华。<br>
  如果SegmentFault是一束向日葵，您就是那一缕明媚的阳光，只因日出盛放。<br>
  如果SegmentFault是一行诗，您就是那一壶陈酿，只为醇香刻下所有的时光。</p>
</blockquote>

<p>反馈请点 <a rel="nofollow" href="https://github.com/SegmentFault/report">https://github.com/SegmentFault/report</a></p>

<p>感谢有你。</p>

<blockquote>
  <p>Build By Developers.<br>
  Build For Developers.</p>
</blockquote>

2015年四月29日晚上 8:01:18
从外网 SSH 进局域网，反向代理+正向代理解决方案
<p>相信很多同学都会碰到这样一个问题。在实验室有一台机器用于日常工作，当我回家了或者回宿舍之后因为没法进入内网，所以访问不到了。如果这个时候我需要 SSH 进去做一下工作，那么怎么解决这个问题呢？本文将给出一种使用 SSH 的代理功能的解决方案。</p>

<h2>问题描述：</h2>

<h3>机器状况</h3>

<table>
<thead><tr>
<th>机器号</th>
  <th>IP</th>
  <th>用户名</th>
  <th>备注</th>
</tr></thead>
<tbody>
<tr>
<td>A</td>
  <td>192.168.0.A</td>
  <td>usr_a</td>
  <td>目标服务器，在局域网中，可以访问 A</td>
</tr>
<tr>
<td>B</td>
  <td>B.B.B.B</td>
  <td>usr_b</td>
  <td>代理服务器，在外网中，无法访问 A</td>
</tr>
<tr>
<td>C</td>
  <td>-</td>
  <td>-</td>
  <td>可以直接访问 B，无法直接访问 A</td>
</tr>
</tbody>
</table>
<h3>目标</h3>

<p>从 C 机器使用 SSH 访问 A</p>

<h2>解决方案</h2>

<p>在 A 机器上做到 B 机器的反向代理；在 B 机器上做正向代理本地端口转发</p>

<h3>环境需求</h3>

<ul>
<li>每台机器上都需要 SSH 客户端</li>
<li>
<p>A、B 两台机器上需要 SSH 服务器端。通常是 openssh-server。</p>

<p>在 Ubuntu 上安装过程为</p>

<pre><code>bash</code><code>sudo apt-get install openssl-server
</code></pre>
</li>
</ul>
<h3>实施步骤</h3>

<ol>
<li>
<p>建立 A 机器到 B 机器的反向代理【A 机器上操作】</p>

<pre><code>bash</code><code>ssh -fCNR &lt;port_b1&gt;:localhost:22 usr_b@B.B.B.B
</code></pre>

<p><code>&lt;port_b1&gt;</code> 为 B 机器上端口，用来与 A 机器上的22端口绑定。</p>
</li>
<li>
<p>建立 B 机器上的正向代理，用作本地转发。做这一步是因为绑定后的  端口只支持本地访问【B 机器上操作】</p>

<pre><code>bash</code><code>ssh -fCNL "*:&lt;port_b2&gt;:localhost:&lt;port_b1&gt;' localhost
</code></pre>

<p><code>&lt;port_b2&gt;</code> 为本地转发端口，用以和外网通信，并将数据转发到 <code>&lt;port_b1&gt;</code>，实现可以从其他机器访问。</p>

<p>其中的<code>*</code>表示接受来自任意机器的访问。</p>
</li>
<li>
<p>现在在 C 机器上可以通过 B 机器 ssh 到 A 机器</p>

<pre><code>bash</code><code>ssh -p &lt;portb2&gt; usra@B.B.B.B
</code></pre>
</li>
</ol>
<p>至此方案完成。</p>

<p>附：</p>

<h3>SSH 参数解释</h3>

<pre><code>-f 后台运行
-C 允许压缩数据
-N 不执行任何命令
-R 将端口绑定到远程服务器，反向代理
-L 将端口绑定到本地客户端，正向代理
</code></pre>

2015年四月29日晚上 6:05:19
使用Gulp来加速你的开发
<p>Gulp与Grunt一样，也是一个自动任务运行器。它充分借鉴了Unix操作系统的管道（pipe）思想，在操作上，它要比Grunt简单。</p>

<h2>安装</h2>

<p>Gulp需要<strong>全局安装</strong>，然后<strong>再在项目的开发目录中安装为本地模块</strong>。先进入项目目录，运行下面的命令。</p>

<pre><code>bash</code><code>npm install -g gulp
npm install --save-dev gulp
</code></pre>

<h2>gulpfile.js</h2>

<p>项目根目录中的gulpfile.js，是Gulp的配置文件。它大概是下面的样子。</p>

<pre><code>javascript</code><code>var gulp = require('gulp');
gulp.task('default', function () {
});
</code></pre>

<p>举个栗子，我们要实现js的压缩。</p>

<pre><code>javascript</code><code>var gulp = require('gulp'),
   uglify = require('gulp-uglify');

gulp.task('minify', function () {
   gulp.src('js/app.js')
      .pipe(uglify())
      .pipe(gulp.dest('app.min'))
});
</code></pre>

<p>上面代码中使用了gulp-uglify模块。在此之前，需要先安装这个模块。<br>
记住在安装之前先 运行 <code>npm init</code> 来生成package.json，如果已经有了就不需要这一步了。</p>

<pre><code>bash</code><code>npm install --save-dev gulp-uglify
</code></pre>

<p><strong>Tips</strong>： --save-dev  会将 gulp-uglify 自动添加到package.json的devDependencies中；</p>

<p>gulpfile.js加载gulp和gulp-uglify模块之后，使用gulp模块的task方法指定任务。task方法有两个参数，第一个是<strong>任务名</strong>，第二个是<strong>任务函数</strong>。在任务函数中，使用gulp模块的src方法，指定所要处理的文件，然后使用pipe方法，将上一步的输出转为当前的输入，进行链式处理。</p>

<p>在上面代码中，使用两次pipe方法，也就是说做了两种处理。第一种处理是使用gulp-uglify模块，压缩源码；第二种处理是使用gulp模块的dest方法，将上一步的输出写入本地文件，这里是app.min.js（代码中省略了后缀名js）。</p>

<p>从上面的例子中可以看到，gulp充分使用了“管道”思想，就是一个数据流（stream）：src方法读入文件产生数据流，dest方法将数据流写入文件，中间是一些中间步骤，每一步都对数据流进行一些处理。</p>

<h2>gulp.src()</h2>

<p>gulp模块的src方法，用于产生数据流。它的参数表示所要处理的文件，一般有以下几种形式。</p>

<ul>
<li>js/app.js：指定确切的文件名。</li>
<li>js/*.js：某个目录所有后缀名为js的文件。</li>
<li>js/**/*.js：某个目录及其所有子目录中的所有后缀名为js的文件。</li>
<li>!js/app.js：除了js/app.js以外的所有文件。</li>
<li>*.+(js|css)：匹配项目根目录下，所有后缀名为js或css的文件。</li>
</ul>
<p>src方法的参数还可以是一个数组，用来指定多个成员。</p>

<pre><code>javascript</code><code><br>gulp.src(['js/**/*.js', 'css/**/*.css'])

</code></pre>

<h2>gulp.task()</h2>

<p>gulp模块的task方法，用于定义具体的任务。它的第一个参数是任务名，第二个参数是任务函数。下面是一个非常简单的任务函数。</p>

<pre><code>javascript</code><code><br>gulp.task('test', function () {
   console.log('就测试下。');
});

</code></pre>

<p>task方法还可以指定按顺序运行的一组任务。</p>

<pre><code>javascript</code><code><br>gulp.task('build', ['css', 'js', 'templates']);

</code></pre>

<p>上面代码先指定build任务，它按次序由css、js、templates三个任务所组成。注意，由于每个任务都是异步调用，所以没有办法保证js任务的开始运行的时间，正是css任务运行结束。</p>

<p>如果希望各个任务严格按次序运行，可以把前一个任务写成后一个任务的依赖模块。</p>

<pre><code>javascript</code><code><br>gulp.task('css', ['templates'], function () {
   // Deal with CSS here
});

</code></pre>

<p>上面代码表明，css任务依赖templates任务，所以css一定会在templates运行完成后再运行。</p>

<p>如果一个任务的名字为default，就表明它是“默认任务”，在命令行直接输入gulp命令，就会运行该任务。</p>

<pre><code>javascript</code><code><br>gulp.task('default', function () {
   // Your default task
});

</code></pre>

<h2>gulp.watch()</h2>

<p>gulp模块的watch方法，用于指定需要监视的文件。一旦这些文件发生变动，就运行指定任务。</p>

<pre><code>javascript</code><code><br>gulp.task('watch', function () {
   gulp.watch('templates/*.tmpl.html', ['build']);
});

</code></pre>

<p>上面代码指定，一旦templates目录中的模板文件发生变化，就运行build任务。</p>

<p>watch方法也可以用回调函数，代替指定的任务。</p>

<pre><code>javascript</code><code><br>gulp.watch('templates/*.html', function (event) {
   console.log('Event type: ' + event.type); 
   console.log('Event path: ' + event.path); 
});

</code></pre>

<p>另一种写法是watch方法所监控的文件发生变化时（修改、增加、删除文件），会触发change事件。可以对change事件指定回调函数。</p>

<pre><code>javascript</code><code><br>var watcher = gulp.watch('templates/*.html', ['build']);

watcher.on('change', function (event) {
   console.log('Event type: ' + event.type);
   console.log('Event path: ' + event.path);
});

</code></pre>

<p>除了change事件，watch方法还可能触发以下事件。</p>

<ul>
<li>end：回调函数运行完毕时触发。</li>
<li>error：发生错误时触发。</li>
<li>ready：当开始监听文件时触发。</li>
<li>nomatch：没有匹配的监听文件时触发。</li>
</ul>
<p>watcher对象还包含其他一些方法。</p>

<ul>
<li>watcher.end()：停止watcher对象，不会再调用任务或回调函数。</li>
<li>watcher.files()：返回watcher对象监视的文件。</li>
<li>watcher.add(glob)：增加所要监视的文件，它还可以附件第二个参数，表示回调函数。</li>
<li>watcher.remove(filepath)：从watcher对象中移走一个监视的文件。</li>
</ul>
<h2>gulp实现自动刷新 - gulp-livereload</h2>

<p>gulp-livereload模块用于自动刷新浏览器，反映出源码的最新变化。它除了模块以外，还需要在浏览器中<a rel="nofollow" href="https://chrome.google.com/webstore/detail/livereload/jnihajbhpnppcggbcgedagnkighmdlei">安装插件</a>，用来配合源码变化。</p>

<pre><code>javascript</code><code><br>var gulp = require('gulp'),
    livereload = require('gulp-livereload');

gulp.task('watch', function () {
    livereload.listen();
    gulp.watch(['./asset/**/*.*','./templates/**/*.*'], function (file) {
        livereload.changed(file.path);
    });
});

</code></pre>

<p>上面代码监视asset和templates下的任何文件，一旦有变化，就自动刷新浏览器。<br>
Tips: 调试css 很方遍，因为刷新css 不需要刷新这个页面，只需要重新加载css即可，赶紧双屏幕，三屏幕搞起来；代码敲得飞起。</p>

<p>还有很多实用的插件 可以到 <a rel="nofollow" href="https://www.npmjs.com/search?q=gulp">NpmJs.org</a> 去找。</p>

2015年四月29日下午 5:45:17
alsotang starred node-modules/optimized
<!-- watch -->
<div class="simple">
  <span class="octicon octicon-star"></span>

  <div class="title">
    <a href="https://github.com/alsotang" data-ga-click="News feed, event click, Event click type:WatchEvent target:actor">alsotang</a> <span>starred</span> <a href="https://github.com/node-modules/optimized" data-ga-click="News feed, event click, Event click type:WatchEvent target:repo">node-modules/optimized</a>
  </div>

  <div class="time">
    <time datetime="2015-04-29T09:45:17Z" is="relative-time">Apr 29, 2015</time>
  </div>
</div>

2015年四月29日下午 4:54:48
各种设备的CSS3MediaQuery整理及爽歪歪写法
<h2>响应式布局</h2>

<p>响应式布局麻烦之处就是每个尺寸的都要进行css定义，这个真的不是一般的蛋疼，下面有搜集到的各种尺寸css Media Query内容，搜集来源：<a rel="nofollow" href="https://css-tricks.com/snippets/css/media-queries-for-standard-devices/">media-queries-for-standard-devices</a>好东西哦。</p>

<p>看了之后是不是非常之蛋疼呢，那么只有使用工具来写这些玩意儿了，俺用得最爽的就是 <code>stylus</code> ，真的爽yy了，如果 <code>stylus</code> 不会玩耍请看这里 <a rel="nofollow" href="http://jslite.io/2015/04/27/stylus%E8%8F%9C%E9%B8%9F%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/">stylus入门使用方法</a></p>

<p>stylus</p>

<pre><code>// Media queries
mq-mobile = "screen and (max-width: 479px)"
mq-tablet = "screen and (min-width: 480px) and (max-width: 767px)"
mq-iPhones4 = "only screen and (min-device-width: 320px) and (max-device-width: 480px) and (-webkit-min-device-pixel-ratio: 2)"
mq-normal = "screen and (min-width: 768px)"

.page-number
    display: inline-block
    @media mq-mobile
        display: none
    @media mq-tablet
        color:red
    @media mq-iPhones4
        font-size:12px
    @media mq-normal
        background:yellow
</code></pre>

<p>编译成</p>

<pre><code>css</code><code>.page-number {
  display: inline-block;
}
@media screen and (max-width: 479px) {
  .page-number {
    display: none;
  }
}
@media screen and (min-width: 480px) and (max-width: 767px) {
  .page-number {
    color: #f00;
  }
}
@media only screen and (min-device-width: 320px) and (max-device-width: 480px) and (-webkit-min-device-pixel-ratio: 2) {
  .page-number {
    font-size: 12px;
  }
}
@media screen and (min-width: 768px) {
  .page-number {
    background: #ff0;
  }
}
</code></pre>

<h2>Phones and Handhelds</h2>

<h3>iPhones</h3>

<pre><code>css</code><code>/* ----------- iPhone 4 and 4S ----------- */

/* Portrait and Landscape */
@media only screen 
  and (min-device-width: 320px) 
  and (max-device-width: 480px)
  and (-webkit-min-device-pixel-ratio: 2) {

}

/* Portrait */
@media only screen 
  and (min-device-width: 320px) 
  and (max-device-width: 480px)
  and (-webkit-min-device-pixel-ratio: 2)
  and (orientation: portrait) {
}

/* Landscape */
@media only screen 
  and (min-device-width: 320px) 
  and (max-device-width: 480px)
  and (-webkit-min-device-pixel-ratio: 2)
  and (orientation: landscape) {

}

/* ----------- iPhone 5 and 5S ----------- */

/* Portrait and Landscape */
@media only screen 
  and (min-device-width: 320px) 
  and (max-device-width: 568px)
  and (-webkit-min-device-pixel-ratio: 2) {

}

/* Portrait */
@media only screen 
  and (min-device-width: 320px) 
  and (max-device-width: 568px)
  and (-webkit-min-device-pixel-ratio: 2)
  and (orientation: portrait) {
}

/* Landscape */
@media only screen 
  and (min-device-width: 320px) 
  and (max-device-width: 568px)
  and (-webkit-min-device-pixel-ratio: 2)
  and (orientation: landscape) {

}

/* ----------- iPhone 6 ----------- */

/* Portrait and Landscape */
@media only screen 
  and (min-device-width: 375px) 
  and (max-device-width: 667px) 
  and (-webkit-min-device-pixel-ratio: 2) { 

}

/* Portrait */
@media only screen 
  and (min-device-width: 375px) 
  and (max-device-width: 667px) 
  and (-webkit-min-device-pixel-ratio: 2)
  and (orientation: portrait) { 

}

/* Landscape */
@media only screen 
  and (min-device-width: 375px) 
  and (max-device-width: 667px) 
  and (-webkit-min-device-pixel-ratio: 2)
  and (orientation: landscape) { 

}

/* ----------- iPhone 6+ ----------- */

/* Portrait and Landscape */
@media only screen 
  and (min-device-width: 414px) 
  and (max-device-width: 736px) 
  and (-webkit-min-device-pixel-ratio: 3) { 

}

/* Portrait */
@media only screen 
  and (min-device-width: 414px) 
  and (max-device-width: 736px) 
  and (-webkit-min-device-pixel-ratio: 3)
  and (orientation: portrait) { 

}

/* Landscape */
@media only screen 
  and (min-device-width: 414px) 
  and (max-device-width: 736px) 
  and (-webkit-min-device-pixel-ratio: 3)
  and (orientation: landscape) { 

}
</code></pre>

<h3>Galaxy Phones</h3>

<pre><code>css</code><code>/* ----------- Galaxy S3 ----------- */

/* Portrait and Landscape */
@media screen 
  and (device-width: 320px) 
  and (device-height: 640px) 
  and (-webkit-device-pixel-ratio: 2) {

}

/* Portrait */
@media screen 
  and (device-width: 320px) 
  and (device-height: 640px) 
  and (-webkit-device-pixel-ratio: 2) 
  and (orientation: portrait) {

}

/* Landscape */
@media screen 
  and (device-width: 320px) 
  and (device-height: 640px) 
  and (-webkit-device-pixel-ratio: 2) 
  and (orientation: landscape) {

}

/* ----------- Galaxy S4 ----------- */

/* Portrait and Landscape */
@media screen 
  and (device-width: 320px) 
  and (device-height: 640px) 
  and (-webkit-device-pixel-ratio: 3) {

}

/* Portrait */
@media screen 
  and (device-width: 320px) 
  and (device-height: 640px) 
  and (-webkit-device-pixel-ratio: 3) 
  and (orientation: portrait) {

}

/* Landscape */
@media screen 
  and (device-width: 320px) 
  and (device-height: 640px) 
  and (-webkit-device-pixel-ratio: 3) 
  and (orientation: landscape) {

}

/* ----------- Galaxy S5 ----------- */

/* Portrait and Landscape */
@media screen 
  and (device-width: 360px) 
  and (device-height: 640px) 
  and (-webkit-device-pixel-ratio: 3) {

}

/* Portrait */
@media screen 
  and (device-width: 360px) 
  and (device-height: 640px) 
  and (-webkit-device-pixel-ratio: 3) 
  and (orientation: portrait) {

}

/* Landscape */
@media screen 
  and (device-width: 360px) 
  and (device-height: 640px) 
  and (-webkit-device-pixel-ratio: 3) 
  and (orientation: landscape) {

}
</code></pre>

<h3>HTC Phones</h3>

<pre><code>css</code><code>/* ----------- HTC One ----------- */

/* Portrait and Landscape */
@media screen 
  and (device-width: 360px) 
  and (device-height: 640px) 
  and (-webkit-device-pixel-ratio: 3) {

}

/* Portrait */
@media screen 
  and (device-width: 360px) 
  and (device-height: 640px) 
  and (-webkit-device-pixel-ratio: 3) 
  and (orientation: portrait) {

}

/* Landscape */
@media screen 
  and (device-width: 360px) 
  and (device-height: 640px) 
  and (-webkit-device-pixel-ratio: 3) 
  and (orientation: landscape) {

}
</code></pre>

<h2>Tablets</h2>

<h3>iPads</h3>

<pre><code>css</code><code>/* ----------- iPad mini ----------- */

/* Portrait and Landscape */
@media only screen 
  and (min-device-width: 768px) 
  and (max-device-width: 1024px) 
  and (-webkit-min-device-pixel-ratio: 1) {

}

/* Portrait */
@media only screen 
  and (min-device-width: 768px) 
  and (max-device-width: 1024px) 
  and (orientation: portrait) 
  and (-webkit-min-device-pixel-ratio: 1) {

}

/* Landscape */
@media only screen 
  and (min-device-width: 768px) 
  and (max-device-width: 1024px) 
  and (orientation: landscape) 
  and (-webkit-min-device-pixel-ratio: 1) {

}

/* ----------- iPad 1 and 2 ----------- */
/* Portrait and Landscape */
@media only screen 
  and (min-device-width: 768px) 
  and (max-device-width: 1024px) 
  and (-webkit-min-device-pixel-ratio: 1) {

}

/* Portrait */
@media only screen 
  and (min-device-width: 768px) 
  and (max-device-width: 1024px) 
  and (orientation: portrait) 
  and (-webkit-min-device-pixel-ratio: 1) {

}

/* Landscape */
@media only screen 
  and (min-device-width: 768px) 
  and (max-device-width: 1024px) 
  and (orientation: landscape) 
  and (-webkit-min-device-pixel-ratio: 1) {

}

/* ----------- iPad 3 and 4 ----------- */
/* Portrait and Landscape */
@media only screen 
  and (min-device-width: 768px) 
  and (max-device-width: 1024px) 
  and (-webkit-min-device-pixel-ratio: 2) {

}

/* Portrait */
@media only screen 
  and (min-device-width: 768px) 
  and (max-device-width: 1024px) 
  and (orientation: portrait) 
  and (-webkit-min-device-pixel-ratio: 2) {

}

/* Landscape */
@media only screen 
  and (min-device-width: 768px) 
  and (max-device-width: 1024px) 
  and (orientation: landscape) 
  and (-webkit-min-device-pixel-ratio: 2) {

}
</code></pre>

<h3>Galaxy Tablets</h3>

<pre><code>css</code><code>/* ----------- Galaxy Tab 10.1 ----------- */

/* Portrait and Landscape */
@media 
  (min-device-width: 800px) 
  and (max-device-width: 1280px) {

}

/* Portrait */
@media 
  (max-device-width: 800px) 
  and (orientation: portrait) { 

}

/* Landscape */
@media 
  (max-device-width: 1280px) 
  and (orientation: landscape) { 

}
</code></pre>

<h3>Nexus Tablets</h3>

<pre><code>css</code><code>/* ----------- Asus Nexus 7 ----------- */

/* Portrait and Landscape */
@media screen 
  and (device-width: 601px) 
  and (device-height: 906px) 
  and (-webkit-min-device-pixel-ratio: 1.331) 
  and (-webkit-max-device-pixel-ratio: 1.332) {

}

/* Portrait */
@media screen 
  and (device-width: 601px) 
  and (device-height: 906px) 
  and (-webkit-min-device-pixel-ratio: 1.331) 
  and (-webkit-max-device-pixel-ratio: 1.332) 
  and (orientation: portrait) {

}

/* Landscape */
@media screen 
  and (device-width: 601px) 
  and (device-height: 906px) 
  and (-webkit-min-device-pixel-ratio: 1.331) 
  and (-webkit-max-device-pixel-ratio: 1.332) 
  and (orientation: landscape) {

}
</code></pre>

<h3>Kindle Fire</h3>

<pre><code>css</code><code>/* ----------- Kindle Fire HD 7" ----------- */

/* Portrait and Landscape */
@media only screen 
  and (min-device-width: 800px) 
  and (max-device-width: 1280px) 
  and (-webkit-min-device-pixel-ratio: 1.5) {

}

/* Portrait */
@media only screen 
  and (min-device-width: 800px) 
  and (max-device-width: 1280px) 
  and (-webkit-min-device-pixel-ratio: 1.5) 
  and (orientation: portrait) {
}

/* Landscape */
@media only screen 
  and (min-device-width: 800px) 
  and (max-device-width: 1280px) 
  and (-webkit-min-device-pixel-ratio: 1.5) 
  and (orientation: landscape) {

}

/* ----------- Kindle Fire HD 8.9" ----------- */
/* Portrait and Landscape */
@media only screen 
  and (min-device-width: 1200px) 
  and (max-device-width: 1600px) 
  and (-webkit-min-device-pixel-ratio: 1.5) {

}
/* Portrait */
@media only screen 
  and (min-device-width: 1200px) 
  and (max-device-width: 1600px) 
  and (-webkit-min-device-pixel-ratio: 1.5) 
  and (orientation: portrait) {
}

/* Landscape */
@media only screen 
  and (min-device-width: 1200px) 
  and (max-device-width: 1600px) 
  and (-webkit-min-device-pixel-ratio: 1.5) 
  and (orientation: landscape) {

}
</code></pre>

<h2>Laptops</h2>

<pre><code>css</code><code>/* ----------- Non-Retina Screens ----------- */
@media screen 
  and (min-device-width: 1200px) 
  and (max-device-width: 1600px) 
  and (-webkit-min-device-pixel-ratio: 1) { 
}
/* ----------- Retina Screens ----------- */
@media screen 
  and (min-device-width: 1200px) 
  and (max-device-width: 1600px) 
  and (-webkit-min-device-pixel-ratio: 2)
  and (min-resolution: 192dpi) { 
}
</code></pre>

<h2>Wearables</h2>

<h3>Apple Watch</h3>

<pre><code>css</code><code>/* ----------- Apple Watch ----------- */
@media
  (max-device-width: 42mm)
  and (min-device-width: 38mm) { 

}
</code></pre>

<h3>Moto 360 Watch</h3>

<pre><code>css</code><code>/* ----------- Moto 360 Watch ----------- */
@media 
  (max-device-width: 218px)
  and (max-device-height: 281px) { 

}
</code></pre>

2015年四月29日下午 4:25:28
alsotang pushed to master at cnodejs/nodeclub
<!-- push -->
<span class="mega-octicon octicon-git-commit"></span>

<div class="time">
  <time datetime="2015-04-29T08:25:28Z" is="relative-time">Apr 29, 2015</time>
</div>

<div class="title">
  <a href="https://github.com/alsotang" data-ga-click="News feed, event click, Event click type:PushEvent target:actor">alsotang</a> <span>pushed</span> to <a href="/cnodejs/nodeclub/tree/master" data-ga-click="News feed, event click, Event click type:PushEvent target:branch">master</a> at <a href="https://github.com/cnodejs/nodeclub" data-ga-click="News feed, event click, Event click type:PushEvent target:repo">cnodejs/nodeclub</a>
</div>

<div class="details">
  <a href="https://github.com/alsotang"><img alt="@alsotang" class="gravatar" data-user="1147375" height="30" src="https://avatars0.githubusercontent.com/u/1147375?v=3&amp;s=60" width="30" /></a>

    <div class="commits pusher-is-only-committer">
      <ul>
        <li>
          <span title="alsotang">
            <img alt="@alsotang" data-user="1147375" height="16" src="https://avatars1.githubusercontent.com/u/1147375?v=3&amp;s=32" width="16" />
          </span>
          <code><a href="/cnodejs/nodeclub/commit/b7ac06b009ccec9a5c86f6da12ca19d60b242610" data-ga-click="News feed, event click, Event click type:PushEvent target:sha">b7ac06b</a></code>
          <div class="message">
            <blockquote>
              update readme
            </blockquote>
          </div>
        </li>
      </ul>
    </div>
</div>

2015年四月29日下午 4:24:27
alsotang pushed to master at cnodejs/nodeclub
<!-- push -->
<span class="mega-octicon octicon-git-commit"></span>

<div class="time">
  <time datetime="2015-04-29T08:24:27Z" is="relative-time">Apr 29, 2015</time>
</div>

<div class="title">
  <a href="https://github.com/alsotang" data-ga-click="News feed, event click, Event click type:PushEvent target:actor">alsotang</a> <span>pushed</span> to <a href="/cnodejs/nodeclub/tree/master" data-ga-click="News feed, event click, Event click type:PushEvent target:branch">master</a> at <a href="https://github.com/cnodejs/nodeclub" data-ga-click="News feed, event click, Event click type:PushEvent target:repo">cnodejs/nodeclub</a>
</div>

<div class="details">
  <a href="https://github.com/alsotang"><img alt="@alsotang" class="gravatar" data-user="1147375" height="30" src="https://avatars0.githubusercontent.com/u/1147375?v=3&amp;s=60" width="30" /></a>

    <div class="commits pusher-is-only-committer">
      <ul>
        <li>
          <span title="alsotang">
            <img alt="@alsotang" data-user="1147375" height="16" src="https://avatars1.githubusercontent.com/u/1147375?v=3&amp;s=32" width="16" />
          </span>
          <code><a href="/cnodejs/nodeclub/commit/b2d4ba4593db951d8ef30b9bafd091c1a2443fb1" data-ga-click="News feed, event click, Event click type:PushEvent target:sha">b2d4ba4</a></code>
          <div class="message">
            <blockquote>
              update readme
            </blockquote>
          </div>
        </li>
      </ul>
    </div>
</div>

2015年四月29日上午 10:30:37
alsotang pushed to online at cnodejs/nodeclub
<!-- push -->
<span class="mega-octicon octicon-git-commit"></span>

<div class="time">
  <time datetime="2015-04-29T02:30:37Z" is="relative-time">Apr 29, 2015</time>
</div>

<div class="title">
  <a href="https://github.com/alsotang" data-ga-click="News feed, event click, Event click type:PushEvent target:actor">alsotang</a> <span>pushed</span> to <a href="/cnodejs/nodeclub/tree/online" data-ga-click="News feed, event click, Event click type:PushEvent target:branch">online</a> at <a href="https://github.com/cnodejs/nodeclub" data-ga-click="News feed, event click, Event click type:PushEvent target:repo">cnodejs/nodeclub</a>
</div>

<div class="details">
  <a href="https://github.com/alsotang"><img alt="@alsotang" class="gravatar" data-user="1147375" height="30" src="https://avatars0.githubusercontent.com/u/1147375?v=3&amp;s=60" width="30" /></a>

    <div class="commits pusher-is-only-committer">
      <ul>
        <li>
          <span title="alsotang">
            <img alt="@alsotang" data-user="1147375" height="16" src="https://avatars1.githubusercontent.com/u/1147375?v=3&amp;s=32" width="16" />
          </span>
          <code><a href="/cnodejs/nodeclub/commit/7ea37f8951137831493f66e9cb7f9f44c3b12139" data-ga-click="News feed, event click, Event click type:PushEvent target:sha">7ea37f8</a></code>
          <div class="message">
            <blockquote>
              coding
            </blockquote>
          </div>
        </li>
      </ul>
    </div>
</div>

2015年四月28日下午 3:23:19
alsotang starred ideawu/ssdb
<!-- watch -->
<div class="simple">
  <span class="octicon octicon-star"></span>

  <div class="title">
    <a href="https://github.com/alsotang" data-ga-click="News feed, event click, Event click type:WatchEvent target:actor">alsotang</a> <span>starred</span> <a href="https://github.com/ideawu/ssdb" data-ga-click="News feed, event click, Event click type:WatchEvent target:repo">ideawu/ssdb</a>
  </div>

  <div class="time">
    <time datetime="2015-04-28T07:23:19Z" is="relative-time">Apr 28, 2015</time>
  </div>
</div>

2015年四月28日上午 10:48:03
alsotang starred phacility/xhprof
<!-- watch -->
<div class="simple">
  <span class="octicon octicon-star"></span>

  <div class="title">
    <a href="https://github.com/alsotang" data-ga-click="News feed, event click, Event click type:WatchEvent target:actor">alsotang</a> <span>starred</span> <a href="https://github.com/phacility/xhprof" data-ga-click="News feed, event click, Event click type:WatchEvent target:repo">phacility/xhprof</a>
  </div>

  <div class="time">
    <time datetime="2015-04-28T02:48:03Z" is="relative-time">Apr 28, 2015</time>
  </div>
</div>

2015年四月27日晚上 10:08:08
alsotang starred nuysoft/node-print
<!-- watch -->
<div class="simple">
  <span class="octicon octicon-star"></span>

  <div class="title">
    <a href="https://github.com/alsotang" data-ga-click="News feed, event click, Event click type:WatchEvent target:actor">alsotang</a> <span>starred</span> <a href="https://github.com/nuysoft/node-print" data-ga-click="News feed, event click, Event click type:WatchEvent target:repo">nuysoft/node-print</a>
  </div>

  <div class="time">
    <time datetime="2015-04-27T14:08:08Z" is="relative-time">Apr 27, 2015</time>
  </div>
</div>

2015年四月27日中午 11:36:09
alsotang starred petitspois/docs.ren
<!-- watch -->
<div class="simple">
  <span class="octicon octicon-star"></span>

  <div class="title">
    <a href="https://github.com/alsotang" data-ga-click="News feed, event click, Event click type:WatchEvent target:actor">alsotang</a> <span>starred</span> <a href="https://github.com/petitspois/docs.ren" data-ga-click="News feed, event click, Event click type:WatchEvent target:repo">petitspois/docs.ren</a>
  </div>

  <div class="time">
    <time datetime="2015-04-27T03:36:09Z" is="relative-time">Apr 27, 2015</time>
  </div>
</div>

2015年四月24日晚上 10:01:44
alsotang commented on issue alsotang/node-lessons#34
<!-- issue_comment -->
<span class="mega-octicon octicon-comment-discussion"></span>

<div class="time">
  <time datetime="2015-04-24T14:01:44Z" is="relative-time">Apr 24, 2015</time>
</div>

<div class="title">
  <a href="https://github.com/alsotang" data-ga-click="News feed, event click, Event click type:IssueCommentEvent target:actor">alsotang</a> <span>commented</span> on issue <a href="https://github.com/alsotang/node-lessons/issues/34#issuecomment-95943100" data-ga-click="News feed, event click, Event click type:IssueCommentEvent target:issue-comment" title="Lesson2中又安装了好几个依赖模块才能执行成功">alsotang/node-lessons#34</a>
</div>

<div class="details">
  <a href="https://github.com/alsotang"><img alt="@alsotang" class="gravatar" data-user="1147375" height="30" src="https://avatars0.githubusercontent.com/u/1147375?v=3&amp;s=60" width="30" /></a>
  <div class="message markdown-body">
    <blockquote>
      <p>lesson2 不涉及任何 css 的内容吧 </p>
    </blockquote>
  </div>
</div>

2015年四月23日晚上 10:58:10
alsotang pushed to online at cnodejs/nodeclub
<!-- push -->
<span class="mega-octicon octicon-git-commit"></span>

<div class="time">
  <time datetime="2015-04-23T14:58:10Z" is="relative-time">Apr 23, 2015</time>
</div>

<div class="title">
  <a href="https://github.com/alsotang" data-ga-click="News feed, event click, Event click type:PushEvent target:actor">alsotang</a> <span>pushed</span> to <a href="/cnodejs/nodeclub/tree/online" data-ga-click="News feed, event click, Event click type:PushEvent target:branch">online</a> at <a href="https://github.com/cnodejs/nodeclub" data-ga-click="News feed, event click, Event click type:PushEvent target:repo">cnodejs/nodeclub</a>
</div>

<div class="details">
  <a href="https://github.com/alsotang"><img alt="@alsotang" class="gravatar" data-user="1147375" height="30" src="https://avatars0.githubusercontent.com/u/1147375?v=3&amp;s=60" width="30" /></a>

    <div class="commits pusher-is-only-committer">
      <ul>
        <li>
          <span title="alsotang">
            <img alt="@alsotang" data-user="1147375" height="16" src="https://avatars1.githubusercontent.com/u/1147375?v=3&amp;s=32" width="16" />
          </span>
          <code><a href="/cnodejs/nodeclub/commit/9f66bb526ff4aab5e2cc918feddcf7c015415d96" data-ga-click="News feed, event click, Event click type:PushEvent target:sha">9f66bb5</a></code>
          <div class="message">
            <blockquote>
              jpush
            </blockquote>
          </div>
        </li>
        <li>
          <span title="alsotang">
            <img alt="@alsotang" data-user="1147375" height="16" src="https://avatars1.githubusercontent.com/u/1147375?v=3&amp;s=32" width="16" />
          </span>
          <code><a href="/cnodejs/nodeclub/commit/8be2e14a298e53d33f707cccbcb2930eff0936f4" data-ga-click="News feed, event click, Event click type:PushEvent target:sha">8be2e14</a></code>
          <div class="message">
            <blockquote>
              topic 详情页缓存零回复主题
            </blockquote>
          </div>
        </li>
        <li class="more"><a href="https://github.com/cnodejs/nodeclub/compare/b249827d22...9f66bb526f" data-ga-click="News feed, event click, Event click type:PushEvent target:comparison">View comparison for these 2 commits &raquo;</a></li>
      </ul>
    </div>
</div>

2015年四月23日晚上 10:57:37
alsotang pushed to master at cnodejs/nodeclub
<!-- push -->
<span class="mega-octicon octicon-git-commit"></span>

<div class="time">
  <time datetime="2015-04-23T14:57:37Z" is="relative-time">Apr 23, 2015</time>
</div>

<div class="title">
  <a href="https://github.com/alsotang" data-ga-click="News feed, event click, Event click type:PushEvent target:actor">alsotang</a> <span>pushed</span> to <a href="/cnodejs/nodeclub/tree/master" data-ga-click="News feed, event click, Event click type:PushEvent target:branch">master</a> at <a href="https://github.com/cnodejs/nodeclub" data-ga-click="News feed, event click, Event click type:PushEvent target:repo">cnodejs/nodeclub</a>
</div>

<div class="details">
  <a href="https://github.com/alsotang"><img alt="@alsotang" class="gravatar" data-user="1147375" height="30" src="https://avatars0.githubusercontent.com/u/1147375?v=3&amp;s=60" width="30" /></a>

    <div class="commits pusher-is-only-committer">
      <ul>
        <li>
          <span title="alsotang">
            <img alt="@alsotang" data-user="1147375" height="16" src="https://avatars1.githubusercontent.com/u/1147375?v=3&amp;s=32" width="16" />
          </span>
          <code><a href="/cnodejs/nodeclub/commit/8be2e14a298e53d33f707cccbcb2930eff0936f4" data-ga-click="News feed, event click, Event click type:PushEvent target:sha">8be2e14</a></code>
          <div class="message">
            <blockquote>
              topic 详情页缓存零回复主题
            </blockquote>
          </div>
        </li>
      </ul>
    </div>
</div>

2015年四月23日晚上 10:52:40
alsotang pushed to online at cnodejs/nodeclub
<!-- push -->
<span class="mega-octicon octicon-git-commit"></span>

<div class="time">
  <time datetime="2015-04-23T14:52:40Z" is="relative-time">Apr 23, 2015</time>
</div>

<div class="title">
  <a href="https://github.com/alsotang" data-ga-click="News feed, event click, Event click type:PushEvent target:actor">alsotang</a> <span>pushed</span> to <a href="/cnodejs/nodeclub/tree/online" data-ga-click="News feed, event click, Event click type:PushEvent target:branch">online</a> at <a href="https://github.com/cnodejs/nodeclub" data-ga-click="News feed, event click, Event click type:PushEvent target:repo">cnodejs/nodeclub</a>
</div>

<div class="details">
  <a href="https://github.com/alsotang"><img alt="@alsotang" class="gravatar" data-user="1147375" height="30" src="https://avatars0.githubusercontent.com/u/1147375?v=3&amp;s=60" width="30" /></a>

    <div class="commits pusher-is-only-committer">
      <ul>
        <li>
          <span title="alsotang">
            <img alt="@alsotang" data-user="1147375" height="16" src="https://avatars1.githubusercontent.com/u/1147375?v=3&amp;s=32" width="16" />
          </span>
          <code><a href="/cnodejs/nodeclub/commit/b249827d22526b15bde68cc6b45ff6f4dcdbcd1b" data-ga-click="News feed, event click, Event click type:PushEvent target:sha">b249827</a></code>
          <div class="message">
            <blockquote>
              jpush
            </blockquote>
          </div>
        </li>
        <li>
          <span title="alsotang">
            <img alt="@alsotang" data-user="1147375" height="16" src="https://avatars1.githubusercontent.com/u/1147375?v=3&amp;s=32" width="16" />
          </span>
          <code><a href="/cnodejs/nodeclub/commit/778ede2adf317abab25652a14eef5e8258a680e4" data-ga-click="News feed, event click, Event click type:PushEvent target:sha">778ede2</a></code>
          <div class="message">
            <blockquote>
              零回复的主题不显示招聘栏目
            </blockquote>
          </div>
        </li>
        <li class="more"><a href="https://github.com/cnodejs/nodeclub/compare/6c2fc20cab...b249827d22" data-ga-click="News feed, event click, Event click type:PushEvent target:comparison">View comparison for these 2 commits &raquo;</a></li>
      </ul>
    </div>
</div>

